<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Absalom</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #050d0a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      color: #a8c5b8;
      overflow: hidden;
    }
    
    #main-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: fixed;
      bottom: 40px;
      text-align: center;
      z-index: 10;
    }
    
    .name {
      font-size: 1.4rem;
      letter-spacing: 0.4em;
      color: #2a5a45;
      text-transform: uppercase;
      text-shadow: 0 0 30px rgba(42, 90, 69, 0.5);
    }
    
    .status {
      margin-top: 8px;
      font-size: 0.75rem;
      color: #1a3d2e;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #1a6b4a;
      animation: statusPulse 2s ease-in-out infinite;
    }
    
    @keyframes statusPulse {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    .status.thinking .status-dot { background: #c9a227; animation-duration: 0.5s; }
    .status.responding .status-dot { background: #1a6b4a; animation-duration: 0.3s; }
  </style>
</head>
<body>
  <canvas id="main-canvas"></canvas>
  
  <div class="overlay">
    <div class="name">Absalom</div>
    <div class="status" id="status">
      <span class="status-dot"></span>
      <span id="status-text">present</span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Color palette - wealth/growth
    const colors = {
      bg: '#050d0a',
      bgGradient: '#0a1a14',
      emerald: '#1a6b4a',
      emeraldDark: '#0d4d3d',
      emeraldLight: '#2a8a5a',
      emeraldDeep: '#0a3d2e',
      gold: '#c9a227',
      goldLight: '#d4af37',
      goldDim: '#8a7020',
      teal: '#0d6b6e',
      text: '#a8c5b8'
    };
    
    // State
    let state = {
      mode: 'idle', // idle, listening, thinking, responding
      mouseX: window.innerWidth / 2,
      mouseY: window.innerHeight / 2,
      targetMouseX: window.innerWidth / 2,
      targetMouseY: window.innerHeight / 2,
      time: 0,
      heartbeat: 0,
      heartbeatSpeed: 0.02,
      blink: { active: false, progress: 0 },
      glance: { active: false, targetX: 0, targetY: 0, duration: 0 },
      saccade: { x: 0, y: 0, timer: 0 },
      pupilDilation: 1,
      neuralFire: [],
      energy: 0,
      energyFlow: 0, // -1 inward (thinking), +1 outward (responding)
      targetEnergyFlow: 0,
      auraIntensity: 0,
      lastActivity: Date.now()
    };
    
    // Ambient particles
    const ambientParticles = [];
    const AMBIENT_COUNT = 80;
    
    function initAmbientParticles() {
      ambientParticles.length = 0;
      for (let i = 0; i < AMBIENT_COUNT; i++) {
        ambientParticles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
          size: 1 + Math.random() * 2,
          alpha: 0.1 + Math.random() * 0.3,
          phase: Math.random() * Math.PI * 2
        });
      }
    }
    
    // Neurons for neural network
    const neurons = [];
    const NEURON_COUNT = 50;
    
    function initNeurons() {
      neurons.length = 0;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2 - 30;
      
      // Create neurons in orbital rings
      const rings = [
        { count: 8, radius: 120, speed: 0.0003 },
        { count: 12, radius: 160, speed: -0.0002 },
        { count: 16, radius: 200, speed: 0.00015 },
        { count: 14, radius: 240, speed: -0.0001 }
      ];
      
      rings.forEach((ring, ringIdx) => {
        for (let i = 0; i < ring.count; i++) {
          const baseAngle = (i / ring.count) * Math.PI * 2;
          neurons.push({
            ring: ringIdx,
            angleOffset: baseAngle,
            radius: ring.radius + (Math.random() - 0.5) * 20,
            speed: ring.speed * (0.8 + Math.random() * 0.4),
            x: 0,
            y: 0,
            size: 2 + Math.random() * 2,
            energy: 0,
            targetEnergy: 0,
            connections: [],
            lastFire: 0
          });
        }
      });
      
      // Create connections (prefer nearby neurons)
      neurons.forEach((n, i) => {
        neurons.forEach((other, j) => {
          if (i !== j && n.connections.length < 4) {
            const ringDiff = Math.abs(n.ring - other.ring);
            if (ringDiff <= 1 && Math.random() > 0.6) {
              n.connections.push(j);
            }
          }
        });
      });
    }
    
    // Mouse tracking
    document.addEventListener('mousemove', (e) => {
      state.targetMouseX = e.clientX;
      state.targetMouseY = e.clientY;
      state.lastActivity = Date.now();
    });
    
    document.addEventListener('touchmove', (e) => {
      state.targetMouseX = e.touches[0].clientX;
      state.targetMouseY = e.touches[0].clientY;
      state.lastActivity = Date.now();
    });
    
    // Click to change state (demo)
    document.addEventListener('click', () => {
      const modes = ['idle', 'listening', 'thinking', 'responding'];
      const currentIndex = modes.indexOf(state.mode);
      state.mode = modes[(currentIndex + 1) % modes.length];
      updateStatus();
      updateModeEffects();
      state.lastActivity = Date.now();
    });
    
    function updateStatus() {
      const statusEl = document.getElementById('status');
      const textEl = document.getElementById('status-text');
      statusEl.className = 'status ' + state.mode;
      textEl.textContent = state.mode === 'idle' ? 'present' : state.mode;
    }
    
    function updateModeEffects() {
      // Set energy flow direction based on mode
      switch (state.mode) {
        case 'thinking':
          state.targetEnergyFlow = -1; // inward
          cascadeNeuralFire(8, 'inward');
          break;
        case 'responding':
          state.targetEnergyFlow = 1; // outward
          cascadeNeuralFire(6, 'outward');
          break;
        case 'listening':
          state.targetEnergyFlow = 0.3;
          break;
        default:
          state.targetEnergyFlow = 0;
      }
    }
    
    function cascadeNeuralFire(count, direction) {
      // Start firing from inner or outer ring based on direction
      const startRing = direction === 'inward' ? 3 : 0;
      const candidates = neurons.filter(n => n.ring === startRing);
      
      for (let i = 0; i < Math.min(count, candidates.length); i++) {
        const idx = neurons.indexOf(candidates[Math.floor(Math.random() * candidates.length)]);
        if (idx >= 0) {
          neurons[idx].targetEnergy = 1;
          neurons[idx].lastFire = state.time;
        }
      }
    }
    
    // Random behaviors
    setInterval(() => {
      // Random blink
      if (Math.random() > 0.7 && !state.blink.active) {
        state.blink.active = true;
        state.blink.progress = 0;
      }
      
      // Random glance
      if (Math.random() > 0.85 && !state.glance.active) {
        state.glance.active = true;
        state.glance.targetX = (Math.random() - 0.5) * 60;
        state.glance.targetY = (Math.random() - 0.5) * 30;
        state.glance.duration = 0;
      }
    }, 1500);
    
    // Mode-specific neural firing
    setInterval(() => {
      if (state.mode === 'thinking') {
        cascadeNeuralFire(3, 'inward');
      } else if (state.mode === 'responding') {
        cascadeNeuralFire(2, 'outward');
      }
    }, 400);
    
    // Saccade timer
    setInterval(() => {
      state.saccade.x = (Math.random() - 0.5) * 4;
      state.saccade.y = (Math.random() - 0.5) * 2;
    }, 100);
    
    function draw() {
      const W = canvas.width;
      const H = canvas.height;
      const centerX = W / 2;
      const centerY = H / 2 - 30;
      
      state.time += 0.016;
      state.heartbeat += state.heartbeatSpeed;
      
      // Adjust heartbeat speed based on mode
      const targetSpeed = {
        idle: 0.015,
        listening: 0.025,
        thinking: 0.04,
        responding: 0.035
      }[state.mode];
      state.heartbeatSpeed += (targetSpeed - state.heartbeatSpeed) * 0.01;
      
      // Smooth energy flow
      state.energyFlow += (state.targetEnergyFlow - state.energyFlow) * 0.02;
      
      // Smooth mouse tracking
      state.mouseX += (state.targetMouseX - state.mouseX) * 0.08;
      state.mouseY += (state.targetMouseY - state.mouseY) * 0.08;
      
      // Heartbeat pulse
      const heartbeatPulse = Math.sin(state.heartbeat) * 0.5 + 0.5;
      state.energy = heartbeatPulse;
      
      // Aura intensity based on mode
      const targetAura = {
        idle: 0.3,
        listening: 0.5,
        thinking: 0.8,
        responding: 1.0
      }[state.mode];
      state.auraIntensity += (targetAura - state.auraIntensity) * 0.02;
      
      // Clear with deep gradient
      drawBackground(centerX, centerY, heartbeatPulse);
      
      // Ambient particles
      drawAmbientParticles(centerX, centerY);
      
      // Aura glow
      drawAura(centerX, centerY, heartbeatPulse);
      
      // Neural network
      drawNeuralNetwork(centerX, centerY);
      
      // Main geometry
      drawGeometry(centerX, centerY, heartbeatPulse);
      
      // Eyes
      drawEyes(centerX, centerY);
      
      // Propagate neural energy
      propagateNeuralEnergy();
      
      requestAnimationFrame(draw);
    }
    
    function drawBackground(cx, cy, pulse) {
      // Deep breathing gradient
      const breathe = Math.sin(state.time * 0.5) * 0.02;
      const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, canvas.height * 0.8);
      bgGrad.addColorStop(0, `rgba(15, 35, 28, ${0.8 + breathe})`);
      bgGrad.addColorStop(0.5, colors.bgGradient);
      bgGrad.addColorStop(1, colors.bg);
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    function drawAmbientParticles(cx, cy) {
      const flowStrength = state.energyFlow * 0.5;
      
      ambientParticles.forEach(p => {
        // Calculate direction to/from center
        const dx = cx - p.x;
        const dy = cy - p.y;
        const dist = Math.hypot(dx, dy);
        const nx = dx / dist;
        const ny = dy / dist;
        
        // Apply flow force (inward negative, outward positive)
        p.vx += nx * flowStrength * 0.01;
        p.vy += ny * flowStrength * 0.01;
        
        // Damping
        p.vx *= 0.99;
        p.vy *= 0.99;
        
        // Move
        p.x += p.vx;
        p.y += p.vy;
        
        // Wrap around edges
        if (p.x < 0) p.x = canvas.width;
        if (p.x > canvas.width) p.x = 0;
        if (p.y < 0) p.y = canvas.height;
        if (p.y > canvas.height) p.y = 0;
        
        // Pulsing alpha
        const pulseAlpha = p.alpha * (0.5 + 0.5 * Math.sin(state.time * 2 + p.phase));
        
        // Brighter when closer to center during responding
        const centerBoost = state.mode === 'responding' && dist < 200 ? 0.3 : 0;
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(26, 107, 74, ${pulseAlpha + centerBoost})`;
        ctx.fill();
      });
    }
    
    function drawAura(cx, cy, pulse) {
      const breathe = Math.sin(state.time * 0.8) * 10;
      const intensity = state.auraIntensity;
      
      // Multiple aura layers
      for (let i = 3; i >= 0; i--) {
        const radius = 180 + i * 40 + breathe + pulse * 20;
        const alpha = intensity * (0.05 - i * 0.01);
        
        ctx.beginPath();
        ctx.arc(cx, cy + Math.sin(state.time * 0.8) * 5, radius, 0, Math.PI * 2);
        
        const auraGrad = ctx.createRadialGradient(cx, cy, radius * 0.5, cx, cy, radius);
        auraGrad.addColorStop(0, `rgba(26, 107, 74, 0)`);
        auraGrad.addColorStop(0.5, `rgba(26, 107, 74, ${alpha})`);
        auraGrad.addColorStop(0.8, `rgba(42, 90, 69, ${alpha * 0.5})`);
        auraGrad.addColorStop(1, `rgba(26, 107, 74, 0)`);
        
        ctx.fillStyle = auraGrad;
        ctx.fill();
      }
      
      // Gold accent aura when thinking/responding
      if (state.mode === 'thinking' || state.mode === 'responding') {
        ctx.beginPath();
        ctx.arc(cx, cy + breathe * 0.5, 160 + pulse * 15, 0, Math.PI * 2);
        const goldAura = ctx.createRadialGradient(cx, cy, 100, cx, cy, 200);
        goldAura.addColorStop(0, `rgba(201, 162, 39, 0)`);
        goldAura.addColorStop(0.5, `rgba(201, 162, 39, ${intensity * 0.08})`);
        goldAura.addColorStop(1, `rgba(201, 162, 39, 0)`);
        ctx.fillStyle = goldAura;
        ctx.fill();
      }
    }
    
    function drawNeuralNetwork(cx, cy) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      // Update neuron positions (orbiting)
      neurons.forEach((n, i) => {
        const angle = n.angleOffset + state.time * n.speed * 50;
        n.x = cx + Math.cos(angle) * n.radius;
        n.y = cy + Math.sin(angle) * n.radius * 0.6 + breathe;
      });
      
      // Draw connections
      ctx.lineWidth = 1;
      neurons.forEach((n, i) => {
        n.connections.forEach(j => {
          const other = neurons[j];
          if (!other) return;
          
          const energy = Math.max(n.energy, other.energy);
          const alpha = 0.05 + energy * 0.4;
          
          ctx.beginPath();
          ctx.moveTo(n.x, n.y);
          ctx.lineTo(other.x, other.y);
          
          if (energy > 0.3) {
            ctx.strokeStyle = `rgba(201, 162, 39, ${alpha})`;
            ctx.lineWidth = 1 + energy * 2;
          } else {
            ctx.strokeStyle = `rgba(26, 107, 74, ${alpha * 0.3})`;
            ctx.lineWidth = 1;
          }
          ctx.stroke();
        });
      });
      
      // Draw neurons
      neurons.forEach((n, i) => {
        const size = n.size + n.energy * 4;
        
        // Glow when energized
        if (n.energy > 0.2) {
          ctx.beginPath();
          ctx.arc(n.x, n.y, size + 10, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(201, 162, 39, ${n.energy * 0.3})`;
          ctx.fill();
        }
        
        // Core
        ctx.beginPath();
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fillStyle = n.energy > 0.3 ? colors.gold : colors.emeraldDark;
        ctx.fill();
      });
    }
    
    function propagateNeuralEnergy() {
      // Smooth energy transitions
      neurons.forEach(n => {
        n.energy += (n.targetEnergy - n.energy) * 0.1;
        n.targetEnergy *= 0.95;
      });
      
      // Propagate energy along connections
      neurons.forEach((n, i) => {
        if (n.energy > 0.5 && state.time - n.lastFire > 0.1) {
          n.connections.forEach(j => {
            const other = neurons[j];
            if (other && other.energy < 0.3) {
              // Propagate based on flow direction
              const shouldPropagate = 
                (state.energyFlow < 0 && other.ring < n.ring) || // inward
                (state.energyFlow > 0 && other.ring > n.ring) || // outward
                (Math.abs(state.energyFlow) < 0.3); // idle - random
              
              if (shouldPropagate && Math.random() > 0.5) {
                other.targetEnergy = Math.min(1, other.targetEnergy + 0.6);
                other.lastFire = state.time;
              }
            }
          });
        }
      });
    }
    
    function drawGeometry(cx, cy, pulse) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      ctx.save();
      ctx.translate(cx, cy + breathe);
      
      // Outer energy ring
      ctx.beginPath();
      ctx.arc(0, 0, 140 + pulse * 10, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(26, 107, 74, ${0.2 + pulse * 0.2})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Pulsing inner ring
      ctx.beginPath();
      ctx.arc(0, 0, 100 + pulse * 5, 0, Math.PI * 2);
      const ringGrad = ctx.createRadialGradient(0, 0, 80, 0, 0, 120);
      ringGrad.addColorStop(0, 'rgba(26, 107, 74, 0.1)');
      ringGrad.addColorStop(0.5, `rgba(42, 138, 90, ${0.1 + pulse * 0.15})`);
      ringGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
      ctx.fillStyle = ringGrad;
      ctx.fill();
      
      // Hexagon frame
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const wobble = Math.sin(state.time * 2 + i) * 2;
        const radius = 95 + wobble + pulse * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = colors.emerald;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Gold accent vertices
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const radius = 95 + pulse * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.arc(x, y, 4 + pulse * 2, 0, Math.PI * 2);
        ctx.fillStyle = colors.gold;
        ctx.fill();
      }
      
      // Inner structure - rotating
      ctx.rotate(state.time * 0.1);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3);
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * 60, Math.sin(angle) * 60);
      }
      ctx.strokeStyle = `rgba(26, 107, 74, 0.3)`;
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawEyes(cx, cy) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      // Calculate eye direction
      let eyeTargetX = state.mouseX;
      let eyeTargetY = state.mouseY;
      
      if (state.glance.active) {
        state.glance.duration += 0.02;
        if (state.glance.duration > 1) {
          state.glance.active = false;
        } else {
          const glanceStrength = Math.sin(state.glance.duration * Math.PI);
          eyeTargetX = cx + state.glance.targetX * glanceStrength * 20;
          eyeTargetY = cy + state.glance.targetY * glanceStrength * 20;
        }
      }
      
      const eyeOffsetX = (eyeTargetX - cx) / window.innerWidth * 20 + state.saccade.x;
      const eyeOffsetY = (eyeTargetY - cy) / window.innerHeight * 15 + state.saccade.y;
      
      // Blink
      if (state.blink.active) {
        state.blink.progress += 0.12;
        if (state.blink.progress >= 1) {
          state.blink.active = false;
          state.blink.progress = 0;
        }
      }
      const blinkAmount = state.blink.active ? Math.sin(state.blink.progress * Math.PI) : 0;
      
      // Pupil dilation
      const targetDilation = {
        idle: 1,
        listening: 1.1,
        thinking: 1.4,
        responding: 1.2
      }[state.mode];
      state.pupilDilation += (targetDilation - state.pupilDilation) * 0.05;
      
      const eyeY = cy - 20 + breathe;
      const eyeSpacing = 45;
      
      [-1, 1].forEach(side => {
        const eyeX = cx + side * eyeSpacing;
        const eyeHeight = 28 * (1 - blinkAmount * 0.95);
        
        // Eye socket glow
        ctx.beginPath();
        const glowGrad = ctx.createRadialGradient(eyeX, eyeY, 0, eyeX, eyeY, 40);
        glowGrad.addColorStop(0, `rgba(26, 107, 74, ${0.2 + state.energy * 0.2})`);
        glowGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
        ctx.arc(eyeX, eyeY, 40, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();
        
        // Eye socket (diamond shape)
        ctx.beginPath();
        ctx.moveTo(eyeX, eyeY - eyeHeight);
        ctx.lineTo(eyeX + 28, eyeY);
        ctx.lineTo(eyeX, eyeY + eyeHeight);
        ctx.lineTo(eyeX - 28, eyeY);
        ctx.closePath();
        ctx.fillStyle = '#08120e';
        ctx.fill();
        ctx.strokeStyle = colors.emeraldDark;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        if (blinkAmount < 0.8) {
          const irisX = eyeX + eyeOffsetX * 0.4;
          const irisY = eyeY + eyeOffsetY * 0.3;
          const irisSize = 14 * state.pupilDilation;
          
          // Iris glow
          ctx.beginPath();
          const irisGrad = ctx.createRadialGradient(irisX, irisY, 0, irisX, irisY, irisSize + 5);
          irisGrad.addColorStop(0, colors.emerald);
          irisGrad.addColorStop(0.7, colors.emeraldDark);
          irisGrad.addColorStop(1, 'rgba(13, 77, 61, 0)');
          ctx.arc(irisX, irisY, irisSize + 5, 0, Math.PI * 2);
          ctx.fillStyle = irisGrad;
          ctx.fill();
          
          // Iris
          ctx.beginPath();
          ctx.arc(irisX, irisY, irisSize, 0, Math.PI * 2);
          ctx.fillStyle = colors.emeraldDark;
          ctx.fill();
          
          // Pupil
          const pupilSize = 6 * state.pupilDilation;
          ctx.beginPath();
          ctx.arc(irisX + eyeOffsetX * 0.1, irisY + eyeOffsetY * 0.1, pupilSize, 0, Math.PI * 2);
          ctx.fillStyle = '#030806';
          ctx.fill();
          
          // Gold ring
          ctx.beginPath();
          ctx.arc(irisX, irisY, irisSize - 2, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(201, 162, 39, ${0.3 + state.energy * 0.3})`;
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Highlights
          ctx.beginPath();
          ctx.arc(irisX - 4, irisY - 4, 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(168, 197, 184, ${0.4 + state.energy * 0.2})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(irisX + 3, irisY + 2, 1.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(201, 162, 39, 0.5)';
          ctx.fill();
        }
      });
    }
    
    // Initialize
    initAmbientParticles();
    initNeurons();
    draw();
    
    window.addEventListener('resize', () => {
      initAmbientParticles();
      neurons.length = 0;
      setTimeout(initNeurons, 100);
    });
    
    // ============================================
    // WebSocket Connection for Live State Sync
    // ============================================
    
    let WS_URL = new URLSearchParams(window.location.search).get('ws') || 
                 localStorage.getItem('absalom_ws') ||
                 null;
    
    async function fetchWsUrl() {
      try {
        const resp = await fetch('ws-url.txt?t=' + Date.now());
        if (resp.ok) {
          const url = (await resp.text()).trim();
          if (url && url.startsWith('wss://')) {
            return url;
          }
        }
      } catch (e) {}
      return null;
    }
    
    (async () => {
      if (!WS_URL) {
        WS_URL = await fetchWsUrl();
      }
      if (WS_URL) {
        localStorage.setItem('absalom_ws', WS_URL);
        connectWebSocket();
      }
    })();
    
    let ws = null;
    let wsRetryTimeout = null;
    let wsConnected = false;
    
    function connectWebSocket() {
      if (!WS_URL) {
        setTimeout(async () => {
          WS_URL = await fetchWsUrl();
          if (WS_URL) connectWebSocket();
        }, 5000);
        return;
      }
      
      ws = new WebSocket(WS_URL);
      
      ws.onopen = () => {
        wsConnected = true;
        document.querySelector('.status-dot').style.background = '#1a6b4a';
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'state' && data.mode) {
            state.mode = data.mode;
            updateStatus();
            updateModeEffects();
            state.lastActivity = Date.now();
          }
        } catch (e) {}
      };
      
      ws.onclose = () => {
        wsConnected = false;
        document.querySelector('.status-dot').style.background = '#4a2020';
        clearTimeout(wsRetryTimeout);
        wsRetryTimeout = setTimeout(connectWebSocket, 5000);
      };
      
      ws.onerror = () => {};
    }
    
    const queryWs = new URLSearchParams(window.location.search).get('ws');
    if (queryWs) {
      localStorage.setItem('absalom_ws', queryWs);
    }
    
    // Connection indicator
    const connIndicator = document.createElement('div');
    connIndicator.style.cssText = 'position:fixed;top:10px;right:10px;font-size:10px;color:#333;';
    connIndicator.id = 'conn-indicator';
    document.body.appendChild(connIndicator);
    
    setInterval(() => {
      const ind = document.getElementById('conn-indicator');
      if (WS_URL) {
        ind.textContent = wsConnected ? '● live' : '○ reconnecting...';
        ind.style.color = wsConnected ? '#1a6b4a' : '#4a2020';
      } else {
        ind.textContent = '○ demo mode';
        ind.style.color = '#333';
      }
    }, 1000);
  </script>
</body>
</html>
