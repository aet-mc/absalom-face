<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Absalom</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #050d0a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      color: #a8c5b8;
      overflow: hidden;
    }
    
    #main-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: fixed;
      bottom: 40px;
      text-align: center;
      z-index: 10;
    }
    
    .name {
      font-size: 1.4rem;
      letter-spacing: 0.4em;
      color: #2a5a45;
      text-transform: uppercase;
      text-shadow: 0 0 30px rgba(42, 90, 69, 0.5);
    }
    
    .status {
      margin-top: 8px;
      font-size: 0.75rem;
      color: #1a3d2e;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #1a6b4a;
      animation: statusPulse 2s ease-in-out infinite;
    }
    
    @keyframes statusPulse {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    .status.thinking .status-dot { background: #c9a227; animation-duration: 0.5s; }
    .status.responding .status-dot { background: #1a6b4a; animation-duration: 0.3s; }
  </style>
</head>
<body>
  <canvas id="main-canvas"></canvas>
  
  <div class="overlay">
    <div class="name">Absalom</div>
    <div class="status" id="status">
      <span class="status-dot"></span>
      <span id="status-text">present</span>
    </div>
  </div>

  <!-- Include GraphClient for WebSocket protocol -->
  <script src="renderer/graph-client.js"></script>
  
  <script>
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Color palette - wealth/growth
    const colors = {
      bg: '#050d0a',
      bgGradient: '#0a1a14',
      emerald: '#1a6b4a',
      emeraldDark: '#0d4d3d',
      emeraldLight: '#2a8a5a',
      emeraldDeep: '#0a3d2e',
      gold: '#c9a227',
      goldLight: '#d4af37',
      goldDim: '#8a7020',
      teal: '#0d6b6e',
      text: '#a8c5b8',
      // Mycelium colors (from spec)
      depthBg: '#0a1f1a',
      nodeInactive: '#1a3a30',
      nodeActive: '#2dd4a8',
      nodeHot: '#fbbf24',
      connectionDim: 'rgba(26, 58, 48, 0.4)',
      connectionLit: 'rgba(45, 212, 168, 0.53)',
      waterCaustic: 'rgba(94, 234, 212, 0.4)'
    };
    
    // State
    let state = {
      mode: 'idle', // idle, listening, thinking, responding
      mouseX: window.innerWidth / 2,
      mouseY: window.innerHeight / 2,
      targetMouseX: window.innerWidth / 2,
      targetMouseY: window.innerHeight / 2,
      time: 0,
      heartbeat: 0,
      heartbeatSpeed: 0.02,
      blink: { active: false, progress: 0 },
      glance: { active: false, targetX: 0, targetY: 0, duration: 0 },
      saccade: { x: 0, y: 0, timer: 0 },
      pupilDilation: 1,
      neuralFire: [],
      energy: 0,
      energyFlow: 0, // -1 inward (thinking), +1 outward (responding)
      targetEnergyFlow: 0,
      auraIntensity: 0,
      lastActivity: Date.now(),
      // Water line state
      waterLineY: 0.65, // Relative position (0.65 = 65% down the screen)
      tideLevel: 0.3,
      targetTideLevel: 0.3
    };
    
    // ============================================
    // Knowledge Graph State (for mycelium layer)
    // ============================================
    let graphData = {
      nodes: [],
      edges: [],
      layout: null // Will hold computed positions
    };
    
    let graphActivations = new Map(); // nodeId -> { intensity, time }
    
    // Layout computed nodes for rendering
    let layoutNodes = []; // { id, x, y, type, label, displayWeight, ... }
    let layoutEdges = []; // { source, target, weight, ... }
    
    // Ambient particles
    const ambientParticles = [];
    const AMBIENT_COUNT = 80;
    
    // Depth particles (below water line)
    const depthParticles = [];
    const DEPTH_PARTICLE_COUNT = 40;
    
    function initAmbientParticles() {
      ambientParticles.length = 0;
      for (let i = 0; i < AMBIENT_COUNT; i++) {
        ambientParticles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
          size: 1 + Math.random() * 2,
          alpha: 0.1 + Math.random() * 0.3,
          phase: Math.random() * Math.PI * 2
        });
      }
    }
    
    function initDepthParticles() {
      depthParticles.length = 0;
      const waterLine = canvas.height * state.waterLineY;
      for (let i = 0; i < DEPTH_PARTICLE_COUNT; i++) {
        depthParticles.push({
          x: Math.random() * canvas.width,
          y: waterLine + Math.random() * (canvas.height - waterLine),
          vx: (Math.random() - 0.5) * 0.1,
          vy: (Math.random() - 0.5) * 0.1,
          size: 0.5 + Math.random() * 1.5,
          alpha: 0.05 + Math.random() * 0.15,
          phase: Math.random() * Math.PI * 2
        });
      }
    }
    
    // Neurons for neural network
    const neurons = [];
    const NEURON_COUNT = 50;
    
    function initNeurons() {
      neurons.length = 0;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2 - 30;
      
      // Create neurons in orbital rings
      const rings = [
        { count: 8, radius: 120, speed: 0.0003 },
        { count: 12, radius: 160, speed: -0.0002 },
        { count: 16, radius: 200, speed: 0.00015 },
        { count: 14, radius: 240, speed: -0.0001 }
      ];
      
      rings.forEach((ring, ringIdx) => {
        for (let i = 0; i < ring.count; i++) {
          const baseAngle = (i / ring.count) * Math.PI * 2;
          neurons.push({
            ring: ringIdx,
            angleOffset: baseAngle,
            radius: ring.radius + (Math.random() - 0.5) * 20,
            speed: ring.speed * (0.8 + Math.random() * 0.4),
            x: 0,
            y: 0,
            size: 2 + Math.random() * 2,
            energy: 0,
            targetEnergy: 0,
            connections: [],
            lastFire: 0
          });
        }
      });
      
      // Create connections (prefer nearby neurons)
      neurons.forEach((n, i) => {
        neurons.forEach((other, j) => {
          if (i !== j && n.connections.length < 4) {
            const ringDiff = Math.abs(n.ring - other.ring);
            if (ringDiff <= 1 && Math.random() > 0.6) {
              n.connections.push(j);
            }
          }
        });
      });
    }
    
    // ============================================
    // Graph Layout - Force-directed positioning
    // ============================================
    
    function layoutGraph(graph) {
      if (!graph.nodes || graph.nodes.length === 0) {
        layoutNodes = [];
        layoutEdges = [];
        return;
      }
      
      const waterLine = canvas.height * state.waterLineY;
      const depthHeight = canvas.height - waterLine;
      const centerX = canvas.width / 2;
      const centerY = waterLine + depthHeight * 0.5;
      
      // Initial positions - radial layout based on node type
      const typeAngles = {
        topics: 0,
        people: Math.PI * 0.4,
        projects: Math.PI * 0.8,
        decisions: Math.PI * 1.2,
        tools: Math.PI * 1.6
      };
      
      layoutNodes = graph.nodes.map((node, idx) => {
        const typeAngle = typeAngles[node.type] || (idx / graph.nodes.length) * Math.PI * 2;
        const jitter = (Math.random() - 0.5) * 0.5;
        const baseRadius = 100 + Math.random() * 150;
        
        // Older nodes go deeper (lower Y)
        const age = Date.now() - (node.lastSeen || Date.now());
        const depthFactor = Math.min(1, age / (30 * 24 * 60 * 60 * 1000)); // 30 days max
        
        return {
          ...node,
          x: centerX + Math.cos(typeAngle + jitter) * baseRadius,
          y: centerY + depthFactor * depthHeight * 0.3 + Math.sin(typeAngle + jitter) * 50,
          vx: 0,
          vy: 0,
          targetX: null,
          targetY: null
        };
      });
      
      layoutEdges = graph.edges.map(edge => ({ ...edge }));
      
      // Run simple force simulation
      for (let i = 0; i < 50; i++) {
        forceSimulationStep();
      }
    }
    
    function forceSimulationStep() {
      const waterLine = canvas.height * state.waterLineY;
      const centerX = canvas.width / 2;
      
      // Repulsion between nodes
      for (let i = 0; i < layoutNodes.length; i++) {
        for (let j = i + 1; j < layoutNodes.length; j++) {
          const a = layoutNodes[i];
          const b = layoutNodes[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          
          if (dist < 100) {
            const force = (100 - dist) * 0.05;
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;
            a.vx -= fx;
            a.vy -= fy;
            b.vx += fx;
            b.vy += fy;
          }
        }
      }
      
      // Attraction along edges
      for (const edge of layoutEdges) {
        const a = layoutNodes.find(n => n.id === edge.source);
        const b = layoutNodes.find(n => n.id === edge.target);
        if (!a || !b) continue;
        
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        
        if (dist > 50) {
          const force = (dist - 50) * 0.01;
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          a.vx += fx;
          a.vy += fy;
          b.vx -= fx;
          b.vy -= fy;
        }
      }
      
      // Apply velocities and constraints
      for (const node of layoutNodes) {
        node.x += node.vx;
        node.y += node.vy;
        node.vx *= 0.8;
        node.vy *= 0.8;
        
        // Keep below water line
        node.y = Math.max(waterLine + 30, node.y);
        node.y = Math.min(canvas.height - 30, node.y);
        
        // Keep within screen bounds
        node.x = Math.max(50, Math.min(canvas.width - 50, node.x));
        
        // Gentle center pull
        node.vx += (centerX - node.x) * 0.001;
      }
    }
    
    // ============================================
    // Graph Activation Logic
    // ============================================
    
    function activateRandomNodes(count, intensity = 1) {
      if (layoutNodes.length === 0) return;
      
      const now = Date.now();
      for (let i = 0; i < count; i++) {
        const node = layoutNodes[Math.floor(Math.random() * layoutNodes.length)];
        graphActivations.set(node.id, { intensity, time: now });
      }
    }
    
    function activateOutwardPath(intensity = 1) {
      if (layoutNodes.length === 0) return;
      
      const now = Date.now();
      const waterLine = canvas.height * state.waterLineY;
      const centerX = canvas.width / 2;
      const centerY = waterLine + (canvas.height - waterLine) * 0.5;
      
      // Find nodes closest to center, activate outward
      const sortedByDist = [...layoutNodes].sort((a, b) => {
        const distA = Math.hypot(a.x - centerX, a.y - centerY);
        const distB = Math.hypot(b.x - centerX, b.y - centerY);
        return distA - distB;
      });
      
      // Activate with staggered timing
      sortedByDist.forEach((node, idx) => {
        const delayedIntensity = intensity * Math.max(0.3, 1 - idx * 0.1);
        graphActivations.set(node.id, { 
          intensity: delayedIntensity, 
          time: now + idx * 50 
        });
      });
    }
    
    function getNodeActivation(nodeId) {
      const activation = graphActivations.get(nodeId);
      if (!activation) return 0;
      
      const age = Date.now() - activation.time;
      if (age < 0) return 0; // Future activation (staggered)
      
      // Decay over 2 seconds
      return activation.intensity * Math.exp(-age / 2000);
    }
    
    function pruneActivations() {
      const now = Date.now();
      for (const [nodeId, activation] of graphActivations) {
        const age = now - activation.time;
        if (age > 5000) {
          graphActivations.delete(nodeId);
        }
      }
    }
    
    // Mouse tracking
    document.addEventListener('mousemove', (e) => {
      state.targetMouseX = e.clientX;
      state.targetMouseY = e.clientY;
      state.lastActivity = Date.now();
    });
    
    document.addEventListener('touchmove', (e) => {
      state.targetMouseX = e.touches[0].clientX;
      state.targetMouseY = e.touches[0].clientY;
      state.lastActivity = Date.now();
    });
    
    // Click to change state (demo)
    document.addEventListener('click', () => {
      const modes = ['idle', 'listening', 'thinking', 'responding'];
      const currentIndex = modes.indexOf(state.mode);
      state.mode = modes[(currentIndex + 1) % modes.length];
      updateStatus();
      updateModeEffects();
      state.lastActivity = Date.now();
    });
    
    function updateStatus() {
      const statusEl = document.getElementById('status');
      const textEl = document.getElementById('status-text');
      statusEl.className = 'status ' + state.mode;
      textEl.textContent = state.mode === 'idle' ? 'present' : state.mode;
    }
    
    function updateModeEffects() {
      // Set energy flow direction based on mode
      switch (state.mode) {
        case 'thinking':
          state.targetEnergyFlow = -1; // inward
          cascadeNeuralFire(8, 'inward');
          activateRandomNodes(5, 1);
          break;
        case 'responding':
          state.targetEnergyFlow = 1; // outward
          cascadeNeuralFire(6, 'outward');
          activateOutwardPath(1);
          break;
        case 'listening':
          state.targetEnergyFlow = 0.3;
          break;
        default:
          state.targetEnergyFlow = 0;
      }
    }
    
    function cascadeNeuralFire(count, direction) {
      // Start firing from inner or outer ring based on direction
      const startRing = direction === 'inward' ? 3 : 0;
      const candidates = neurons.filter(n => n.ring === startRing);
      
      for (let i = 0; i < Math.min(count, candidates.length); i++) {
        const idx = neurons.indexOf(candidates[Math.floor(Math.random() * candidates.length)]);
        if (idx >= 0) {
          neurons[idx].targetEnergy = 1;
          neurons[idx].lastFire = state.time;
        }
      }
    }
    
    // Random behaviors
    setInterval(() => {
      // Random blink
      if (Math.random() > 0.7 && !state.blink.active) {
        state.blink.active = true;
        state.blink.progress = 0;
      }
      
      // Random glance
      if (Math.random() > 0.85 && !state.glance.active) {
        state.glance.active = true;
        state.glance.targetX = (Math.random() - 0.5) * 60;
        state.glance.targetY = (Math.random() - 0.5) * 30;
        state.glance.duration = 0;
      }
    }, 1500);
    
    // Mode-specific neural firing
    setInterval(() => {
      if (state.mode === 'thinking') {
        cascadeNeuralFire(3, 'inward');
        activateRandomNodes(2, 0.7);
      } else if (state.mode === 'responding') {
        cascadeNeuralFire(2, 'outward');
        if (Math.random() > 0.5) activateOutwardPath(0.5);
      }
      
      // Clean up old activations
      pruneActivations();
    }, 400);
    
    // Saccade timer
    setInterval(() => {
      state.saccade.x = (Math.random() - 0.5) * 4;
      state.saccade.y = (Math.random() - 0.5) * 2;
    }, 100);
    
    // ============================================
    // Main Render Loop
    // ============================================
    
    function draw() {
      const W = canvas.width;
      const H = canvas.height;
      const centerX = W / 2;
      const centerY = H / 2 - 30;
      const waterLine = H * state.waterLineY;
      
      state.time += 0.016;
      state.heartbeat += state.heartbeatSpeed;
      
      // Smooth tide level changes
      state.tideLevel += (state.targetTideLevel - state.tideLevel) * 0.01;
      
      // Adjust heartbeat speed based on mode
      const targetSpeed = {
        idle: 0.015,
        listening: 0.025,
        thinking: 0.04,
        responding: 0.035
      }[state.mode];
      state.heartbeatSpeed += (targetSpeed - state.heartbeatSpeed) * 0.01;
      
      // Smooth energy flow
      state.energyFlow += (state.targetEnergyFlow - state.energyFlow) * 0.02;
      
      // Smooth mouse tracking
      state.mouseX += (state.targetMouseX - state.mouseX) * 0.08;
      state.mouseY += (state.targetMouseY - state.mouseY) * 0.08;
      
      // Heartbeat pulse
      const heartbeatPulse = Math.sin(state.heartbeat) * 0.5 + 0.5;
      state.energy = heartbeatPulse;
      
      // Aura intensity based on mode
      const targetAura = {
        idle: 0.3,
        listening: 0.5,
        thinking: 0.8,
        responding: 1.0
      }[state.mode];
      state.auraIntensity += (targetAura - state.auraIntensity) * 0.02;
      
      // Clear with deep gradient
      drawBackground(centerX, centerY, heartbeatPulse);
      
      // ===== DEPTH LAYER (below water line) =====
      drawMyceliumLayer(waterLine);
      
      // ===== WATER LINE with caustics =====
      drawWaterLine(waterLine);
      
      // ===== SURFACE LAYER (above water line) =====
      // Ambient particles
      drawAmbientParticles(centerX, centerY, waterLine);
      
      // Aura glow
      drawAura(centerX, centerY, heartbeatPulse);
      
      // Neural network
      drawNeuralNetwork(centerX, centerY);
      
      // Main geometry
      drawGeometry(centerX, centerY, heartbeatPulse);
      
      // Eyes
      drawEyes(centerX, centerY);
      
      // Propagate neural energy
      propagateNeuralEnergy();
      
      requestAnimationFrame(draw);
    }
    
    function drawBackground(cx, cy, pulse) {
      // Deep breathing gradient
      const breathe = Math.sin(state.time * 0.5) * 0.02;
      const waterLine = canvas.height * state.waterLineY;
      
      // Upper gradient (tidal pool / surface)
      const bgGrad = ctx.createLinearGradient(0, 0, 0, waterLine);
      bgGrad.addColorStop(0, colors.bg);
      bgGrad.addColorStop(0.5, colors.bgGradient);
      bgGrad.addColorStop(1, '#0a1f1a');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, canvas.width, waterLine);
      
      // Lower gradient (mycelium depths)
      const depthGrad = ctx.createLinearGradient(0, waterLine, 0, canvas.height);
      depthGrad.addColorStop(0, colors.depthBg);
      depthGrad.addColorStop(1, '#050a08');
      ctx.fillStyle = depthGrad;
      ctx.fillRect(0, waterLine, canvas.width, canvas.height - waterLine);
    }
    
    // ============================================
    // Mycelium Layer (Knowledge Graph Visualization)
    // ============================================
    
    function drawMyceliumLayer(waterLine) {
      if (layoutNodes.length === 0) return;
      
      const breathe = Math.sin(state.time * 0.3) * 3;
      
      // Draw edges first (below nodes)
      ctx.lineWidth = 1;
      for (const edge of layoutEdges) {
        const sourceNode = layoutNodes.find(n => n.id === edge.source);
        const targetNode = layoutNodes.find(n => n.id === edge.target);
        if (!sourceNode || !targetNode) continue;
        
        const sourceActivation = getNodeActivation(edge.source);
        const targetActivation = getNodeActivation(edge.target);
        const edgeActivation = Math.max(sourceActivation, targetActivation);
        
        // Base alpha + activation boost
        const alpha = 0.1 + edgeActivation * 0.5;
        const width = 1 + edgeActivation * 2;
        
        ctx.beginPath();
        ctx.moveTo(sourceNode.x, sourceNode.y + breathe);
        
        // Bezier curve for organic feel
        const midX = (sourceNode.x + targetNode.x) / 2;
        const midY = (sourceNode.y + targetNode.y) / 2 + breathe;
        const ctrl1X = sourceNode.x + (midX - sourceNode.x) * 0.5 + (Math.random() - 0.5) * 10;
        const ctrl1Y = sourceNode.y + (midY - sourceNode.y) * 0.5 + breathe;
        
        ctx.quadraticCurveTo(ctrl1X, ctrl1Y, targetNode.x, targetNode.y + breathe);
        
        if (edgeActivation > 0.3) {
          ctx.strokeStyle = `rgba(45, 212, 168, ${alpha})`;
          ctx.lineWidth = width;
        } else {
          ctx.strokeStyle = `rgba(26, 58, 48, ${alpha})`;
          ctx.lineWidth = 1;
        }
        ctx.stroke();
      }
      
      // Draw nodes
      for (const node of layoutNodes) {
        const activation = getNodeActivation(node.id);
        const nodeY = node.y + breathe;
        
        // Node size based on weight and activation
        const baseSize = 4 + (node.displayWeight || 1) * 2;
        const size = baseSize + activation * 4;
        
        // Glow when activated
        if (activation > 0.1) {
          ctx.beginPath();
          ctx.arc(node.x, nodeY, size + 15, 0, Math.PI * 2);
          const glowColor = node.type === 'people' ? colors.goldLight : colors.nodeActive;
          ctx.fillStyle = glowColor.replace(')', `, ${activation * 0.4})`).replace('rgb', 'rgba');
          ctx.fill();
        }
        
        // Core node
        ctx.beginPath();
        ctx.arc(node.x, nodeY, size, 0, Math.PI * 2);
        
        // Color by type
        let nodeColor;
        if (activation > 0.5) {
          nodeColor = node.type === 'people' ? colors.nodeHot : colors.nodeActive;
        } else if (activation > 0.1) {
          nodeColor = colors.emeraldLight;
        } else {
          nodeColor = colors.nodeInactive;
        }
        ctx.fillStyle = nodeColor;
        ctx.fill();
        
        // Idle state: gentle pulse for all nodes
        if (state.mode === 'idle' && activation < 0.1) {
          const idlePulse = (Math.sin(state.time * 0.8 + node.x * 0.01) * 0.5 + 0.5) * 0.3;
          ctx.beginPath();
          ctx.arc(node.x, nodeY, size + 5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(26, 107, 74, ${idlePulse * 0.2})`;
          ctx.fill();
        }
      }
      
      // Draw depth particles
      drawDepthParticles(waterLine, breathe);
    }
    
    function drawDepthParticles(waterLine, breathe) {
      for (const p of depthParticles) {
        // Slow drift
        p.x += p.vx + Math.sin(state.time * 0.5 + p.phase) * 0.05;
        p.y += p.vy + Math.cos(state.time * 0.3 + p.phase) * 0.03;
        
        // Wrap around
        if (p.x < 0) p.x = canvas.width;
        if (p.x > canvas.width) p.x = 0;
        if (p.y < waterLine + 10) p.y = canvas.height - 10;
        if (p.y > canvas.height - 10) p.y = waterLine + 10;
        
        // Pulsing glow
        const pulseAlpha = p.alpha * (0.5 + 0.5 * Math.sin(state.time + p.phase));
        
        ctx.beginPath();
        ctx.arc(p.x, p.y + breathe, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(45, 212, 168, ${pulseAlpha})`;
        ctx.fill();
      }
    }
    
    // ============================================
    // Water Line with Caustic Effect
    // ============================================
    
    function drawWaterLine(waterLine) {
      const W = canvas.width;
      
      // Main water line - undulating
      ctx.beginPath();
      ctx.moveTo(0, waterLine);
      
      for (let x = 0; x <= W; x += 10) {
        const wave1 = Math.sin(x * 0.02 + state.time * 0.8) * 3;
        const wave2 = Math.sin(x * 0.01 + state.time * 0.5) * 5;
        const y = waterLine + wave1 + wave2;
        ctx.lineTo(x, y);
      }
      
      ctx.strokeStyle = `rgba(94, 234, 212, 0.3)`;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Caustic shimmer effect
      drawCaustics(waterLine);
      
      // Gradient fade at water line
      const fadeGrad = ctx.createLinearGradient(0, waterLine - 30, 0, waterLine + 30);
      fadeGrad.addColorStop(0, 'rgba(10, 31, 26, 0)');
      fadeGrad.addColorStop(0.4, 'rgba(10, 31, 26, 0.3)');
      fadeGrad.addColorStop(0.5, 'rgba(94, 234, 212, 0.1)');
      fadeGrad.addColorStop(0.6, 'rgba(10, 31, 26, 0.3)');
      fadeGrad.addColorStop(1, 'rgba(10, 31, 26, 0)');
      ctx.fillStyle = fadeGrad;
      ctx.fillRect(0, waterLine - 30, W, 60);
    }
    
    function drawCaustics(waterLine) {
      const W = canvas.width;
      const causticCount = 8;
      
      for (let i = 0; i < causticCount; i++) {
        const baseX = (i / causticCount) * W + (state.time * 20) % (W / causticCount);
        const x = baseX % W;
        const waveOffset = Math.sin(state.time * 1.2 + i) * 15;
        
        // Caustic light ray
        ctx.beginPath();
        ctx.moveTo(x + waveOffset, waterLine - 10);
        ctx.lineTo(x + waveOffset + 5, waterLine + 40);
        ctx.lineTo(x + waveOffset + 15, waterLine + 40);
        ctx.lineTo(x + waveOffset + 10, waterLine - 10);
        ctx.closePath();
        
        const causticAlpha = (Math.sin(state.time * 2 + i * 0.7) * 0.5 + 0.5) * 0.15;
        ctx.fillStyle = `rgba(94, 234, 212, ${causticAlpha})`;
        ctx.fill();
      }
      
      // Dancing light spots
      for (let i = 0; i < 12; i++) {
        const x = (Math.sin(state.time * 0.5 + i * 2) * 0.5 + 0.5) * W;
        const y = waterLine + Math.sin(state.time * 0.8 + i) * 20;
        const size = 2 + Math.sin(state.time * 1.5 + i * 0.3) * 2;
        const alpha = (Math.sin(state.time * 1.2 + i * 0.5) * 0.5 + 0.5) * 0.3;
        
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(94, 234, 212, ${alpha})`;
        ctx.fill();
      }
    }
    
    function drawAmbientParticles(cx, cy, waterLine) {
      const flowStrength = state.energyFlow * 0.5;
      
      ambientParticles.forEach(p => {
        // Keep above water line
        if (p.y > waterLine - 20) {
          p.y = 20 + Math.random() * (waterLine - 60);
        }
        
        // Calculate direction to/from center
        const dx = cx - p.x;
        const dy = cy - p.y;
        const dist = Math.hypot(dx, dy);
        const nx = dx / dist;
        const ny = dy / dist;
        
        // Apply flow force (inward negative, outward positive)
        p.vx += nx * flowStrength * 0.01;
        p.vy += ny * flowStrength * 0.01;
        
        // Damping
        p.vx *= 0.99;
        p.vy *= 0.99;
        
        // Move
        p.x += p.vx;
        p.y += p.vy;
        
        // Wrap around edges (but stay above water)
        if (p.x < 0) p.x = canvas.width;
        if (p.x > canvas.width) p.x = 0;
        if (p.y < 0) p.y = waterLine - 40;
        
        // Pulsing alpha
        const pulseAlpha = p.alpha * (0.5 + 0.5 * Math.sin(state.time * 2 + p.phase));
        
        // Brighter when closer to center during responding
        const centerBoost = state.mode === 'responding' && dist < 200 ? 0.3 : 0;
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(26, 107, 74, ${pulseAlpha + centerBoost})`;
        ctx.fill();
      });
    }
    
    function drawAura(cx, cy, pulse) {
      const breathe = Math.sin(state.time * 0.8) * 10;
      const intensity = state.auraIntensity;
      
      // Multiple aura layers
      for (let i = 3; i >= 0; i--) {
        const radius = 180 + i * 40 + breathe + pulse * 20;
        const alpha = intensity * (0.05 - i * 0.01);
        
        ctx.beginPath();
        ctx.arc(cx, cy + Math.sin(state.time * 0.8) * 5, radius, 0, Math.PI * 2);
        
        const auraGrad = ctx.createRadialGradient(cx, cy, radius * 0.5, cx, cy, radius);
        auraGrad.addColorStop(0, `rgba(26, 107, 74, 0)`);
        auraGrad.addColorStop(0.5, `rgba(26, 107, 74, ${alpha})`);
        auraGrad.addColorStop(0.8, `rgba(42, 90, 69, ${alpha * 0.5})`);
        auraGrad.addColorStop(1, `rgba(26, 107, 74, 0)`);
        
        ctx.fillStyle = auraGrad;
        ctx.fill();
      }
      
      // Gold accent aura when thinking/responding
      if (state.mode === 'thinking' || state.mode === 'responding') {
        ctx.beginPath();
        ctx.arc(cx, cy + breathe * 0.5, 160 + pulse * 15, 0, Math.PI * 2);
        const goldAura = ctx.createRadialGradient(cx, cy, 100, cx, cy, 200);
        goldAura.addColorStop(0, `rgba(201, 162, 39, 0)`);
        goldAura.addColorStop(0.5, `rgba(201, 162, 39, ${intensity * 0.08})`);
        goldAura.addColorStop(1, `rgba(201, 162, 39, 0)`);
        ctx.fillStyle = goldAura;
        ctx.fill();
      }
    }
    
    function drawNeuralNetwork(cx, cy) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      // Update neuron positions (orbiting)
      neurons.forEach((n, i) => {
        const angle = n.angleOffset + state.time * n.speed * 50;
        n.x = cx + Math.cos(angle) * n.radius;
        n.y = cy + Math.sin(angle) * n.radius * 0.6 + breathe;
      });
      
      // Draw connections
      ctx.lineWidth = 1;
      neurons.forEach((n, i) => {
        n.connections.forEach(j => {
          const other = neurons[j];
          if (!other) return;
          
          const energy = Math.max(n.energy, other.energy);
          const alpha = 0.05 + energy * 0.4;
          
          ctx.beginPath();
          ctx.moveTo(n.x, n.y);
          ctx.lineTo(other.x, other.y);
          
          if (energy > 0.3) {
            ctx.strokeStyle = `rgba(201, 162, 39, ${alpha})`;
            ctx.lineWidth = 1 + energy * 2;
          } else {
            ctx.strokeStyle = `rgba(26, 107, 74, ${alpha * 0.3})`;
            ctx.lineWidth = 1;
          }
          ctx.stroke();
        });
      });
      
      // Draw neurons
      neurons.forEach((n, i) => {
        const size = n.size + n.energy * 4;
        
        // Glow when energized
        if (n.energy > 0.2) {
          ctx.beginPath();
          ctx.arc(n.x, n.y, size + 10, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(201, 162, 39, ${n.energy * 0.3})`;
          ctx.fill();
        }
        
        // Core
        ctx.beginPath();
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fillStyle = n.energy > 0.3 ? colors.gold : colors.emeraldDark;
        ctx.fill();
      });
    }
    
    function propagateNeuralEnergy() {
      // Smooth energy transitions
      neurons.forEach(n => {
        n.energy += (n.targetEnergy - n.energy) * 0.1;
        n.targetEnergy *= 0.95;
      });
      
      // Propagate energy along connections
      neurons.forEach((n, i) => {
        if (n.energy > 0.5 && state.time - n.lastFire > 0.1) {
          n.connections.forEach(j => {
            const other = neurons[j];
            if (other && other.energy < 0.3) {
              // Propagate based on flow direction
              const shouldPropagate = 
                (state.energyFlow < 0 && other.ring < n.ring) || // inward
                (state.energyFlow > 0 && other.ring > n.ring) || // outward
                (Math.abs(state.energyFlow) < 0.3); // idle - random
              
              if (shouldPropagate && Math.random() > 0.5) {
                other.targetEnergy = Math.min(1, other.targetEnergy + 0.6);
                other.lastFire = state.time;
              }
            }
          });
        }
      });
    }
    
    function drawGeometry(cx, cy, pulse) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      ctx.save();
      ctx.translate(cx, cy + breathe);
      
      // Outer energy ring
      ctx.beginPath();
      ctx.arc(0, 0, 140 + pulse * 10, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(26, 107, 74, ${0.2 + pulse * 0.2})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Pulsing inner ring
      ctx.beginPath();
      ctx.arc(0, 0, 100 + pulse * 5, 0, Math.PI * 2);
      const ringGrad = ctx.createRadialGradient(0, 0, 80, 0, 0, 120);
      ringGrad.addColorStop(0, 'rgba(26, 107, 74, 0.1)');
      ringGrad.addColorStop(0.5, `rgba(42, 138, 90, ${0.1 + pulse * 0.15})`);
      ringGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
      ctx.fillStyle = ringGrad;
      ctx.fill();
      
      // Hexagon frame
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const wobble = Math.sin(state.time * 2 + i) * 2;
        const radius = 95 + wobble + pulse * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = colors.emerald;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Gold accent vertices
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const radius = 95 + pulse * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.arc(x, y, 4 + pulse * 2, 0, Math.PI * 2);
        ctx.fillStyle = colors.gold;
        ctx.fill();
      }
      
      // Inner structure - rotating
      ctx.rotate(state.time * 0.1);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3);
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * 60, Math.sin(angle) * 60);
      }
      ctx.strokeStyle = `rgba(26, 107, 74, 0.3)`;
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawEyes(cx, cy) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      // Calculate eye direction
      let eyeTargetX = state.mouseX;
      let eyeTargetY = state.mouseY;
      
      if (state.glance.active) {
        state.glance.duration += 0.02;
        if (state.glance.duration > 1) {
          state.glance.active = false;
        } else {
          const glanceStrength = Math.sin(state.glance.duration * Math.PI);
          eyeTargetX = cx + state.glance.targetX * glanceStrength * 20;
          eyeTargetY = cy + state.glance.targetY * glanceStrength * 20;
        }
      }
      
      const eyeOffsetX = (eyeTargetX - cx) / window.innerWidth * 20 + state.saccade.x;
      const eyeOffsetY = (eyeTargetY - cy) / window.innerHeight * 15 + state.saccade.y;
      
      // Blink
      if (state.blink.active) {
        state.blink.progress += 0.12;
        if (state.blink.progress >= 1) {
          state.blink.active = false;
          state.blink.progress = 0;
        }
      }
      const blinkAmount = state.blink.active ? Math.sin(state.blink.progress * Math.PI) : 0;
      
      // Pupil dilation
      const targetDilation = {
        idle: 1,
        listening: 1.1,
        thinking: 1.4,
        responding: 1.2
      }[state.mode];
      state.pupilDilation += (targetDilation - state.pupilDilation) * 0.05;
      
      const eyeY = cy - 20 + breathe;
      const eyeSpacing = 45;
      
      [-1, 1].forEach(side => {
        const eyeX = cx + side * eyeSpacing;
        const eyeHeight = 28 * (1 - blinkAmount * 0.95);
        
        // Eye socket glow
        ctx.beginPath();
        const glowGrad = ctx.createRadialGradient(eyeX, eyeY, 0, eyeX, eyeY, 40);
        glowGrad.addColorStop(0, `rgba(26, 107, 74, ${0.2 + state.energy * 0.2})`);
        glowGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
        ctx.arc(eyeX, eyeY, 40, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();
        
        // Eye socket (diamond shape)
        ctx.beginPath();
        ctx.moveTo(eyeX, eyeY - eyeHeight);
        ctx.lineTo(eyeX + 28, eyeY);
        ctx.lineTo(eyeX, eyeY + eyeHeight);
        ctx.lineTo(eyeX - 28, eyeY);
        ctx.closePath();
        ctx.fillStyle = '#08120e';
        ctx.fill();
        ctx.strokeStyle = colors.emeraldDark;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        if (blinkAmount < 0.8) {
          const irisX = eyeX + eyeOffsetX * 0.4;
          const irisY = eyeY + eyeOffsetY * 0.3;
          const irisSize = 14 * state.pupilDilation;
          
          // Iris glow
          ctx.beginPath();
          const irisGrad = ctx.createRadialGradient(irisX, irisY, 0, irisX, irisY, irisSize + 5);
          irisGrad.addColorStop(0, colors.emerald);
          irisGrad.addColorStop(0.7, colors.emeraldDark);
          irisGrad.addColorStop(1, 'rgba(13, 77, 61, 0)');
          ctx.arc(irisX, irisY, irisSize + 5, 0, Math.PI * 2);
          ctx.fillStyle = irisGrad;
          ctx.fill();
          
          // Iris
          ctx.beginPath();
          ctx.arc(irisX, irisY, irisSize, 0, Math.PI * 2);
          ctx.fillStyle = colors.emeraldDark;
          ctx.fill();
          
          // Pupil
          const pupilSize = 6 * state.pupilDilation;
          ctx.beginPath();
          ctx.arc(irisX + eyeOffsetX * 0.1, irisY + eyeOffsetY * 0.1, pupilSize, 0, Math.PI * 2);
          ctx.fillStyle = '#030806';
          ctx.fill();
          
          // Gold ring
          ctx.beginPath();
          ctx.arc(irisX, irisY, irisSize - 2, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(201, 162, 39, ${0.3 + state.energy * 0.3})`;
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Highlights
          ctx.beginPath();
          ctx.arc(irisX - 4, irisY - 4, 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(168, 197, 184, ${0.4 + state.energy * 0.2})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(irisX + 3, irisY + 2, 1.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(201, 162, 39, 0.5)';
          ctx.fill();
        }
      });
    }
    
    // Initialize
    initAmbientParticles();
    initDepthParticles();
    initNeurons();
    draw();
    
    window.addEventListener('resize', () => {
      initAmbientParticles();
      initDepthParticles();
      neurons.length = 0;
      setTimeout(() => {
        initNeurons();
        // Re-layout graph if we have data
        if (graphData.nodes.length > 0) {
          layoutGraph(graphData);
        }
      }, 100);
    });
    
    // ============================================
    // WebSocket Connection via GraphClient
    // ============================================
    
    let WS_URL = new URLSearchParams(window.location.search).get('ws') || 
                 localStorage.getItem('absalom_ws') ||
                 null;
    
    async function fetchWsUrl() {
      try {
        const resp = await fetch('ws-url.txt?t=' + Date.now());
        if (resp.ok) {
          const url = (await resp.text()).trim();
          if (url && url.startsWith('wss://')) {
            return url;
          }
        }
      } catch (e) {}
      return null;
    }
    
    // GraphClient instance
    let graphClient = null;
    
    (async () => {
      if (!WS_URL) {
        WS_URL = await fetchWsUrl();
      }
      if (WS_URL) {
        localStorage.setItem('absalom_ws', WS_URL);
        initGraphClient(WS_URL);
      }
    })();
    
    function initGraphClient(wsUrl) {
      // Check if GraphClient is available (from renderer/graph-client.js)
      if (typeof GraphClient === 'undefined') {
        console.warn('GraphClient not loaded, falling back to basic WebSocket');
        connectBasicWebSocket(wsUrl);
        return;
      }
      
      graphClient = new GraphClient(wsUrl, {
        reconnectDelay: 1000,
        maxReconnectDelay: 30000,
        autoConnect: true
      });
      
      // Connection events
      graphClient.on('connect', () => {
        document.querySelector('.status-dot').style.background = '#1a6b4a';
        updateConnectionIndicator(true);
      });
      
      graphClient.on('disconnect', () => {
        document.querySelector('.status-dot').style.background = '#4a2020';
        updateConnectionIndicator(false);
      });
      
      // Graph events
      graphClient.on('graph', (graph) => {
        console.log('[Absalom] Received graph:', graph.nodes?.length, 'nodes,', graph.edges?.length, 'edges');
        graphData = graph;
        layoutGraph(graph);
      });
      
      // State events
      graphClient.on('state', (newState, oldState) => {
        console.log('[Absalom] State change:', oldState, '->', newState);
        state.mode = newState;
        updateStatus();
        updateModeEffects();
        state.lastActivity = Date.now();
      });
      
      // Activation events
      graphClient.on('activate', (nodeIds, intensity) => {
        console.log('[Absalom] Activate nodes:', nodeIds.length, 'intensity:', intensity);
        const now = Date.now();
        for (const nodeId of nodeIds) {
          graphActivations.set(nodeId, { intensity, time: now });
        }
      });
      
      graphClient.on('activate:path', (path, intensity) => {
        console.log('[Absalom] Activate path:', path.length, 'nodes');
        const now = Date.now();
        path.forEach((nodeId, idx) => {
          graphActivations.set(nodeId, { 
            intensity: intensity * Math.max(0.3, 1 - idx * 0.1), 
            time: now + idx * 100 
          });
        });
      });
      
      // Tide events
      graphClient.on('tide', (level, oldLevel) => {
        console.log('[Absalom] Tide level:', level);
        state.targetTideLevel = level;
      });
      
      // Context events (for future surface layer creatures)
      graphClient.on('context:add', (concept, creatureType) => {
        console.log('[Absalom] Context add:', concept, creatureType);
        // TODO: Add creature to surface layer when mycelium layer is ready
      });
      
      graphClient.on('context:clear', () => {
        console.log('[Absalom] Context cleared (session end)');
        // TODO: Clear surface layer creatures
      });
      
      // Sub-agent events
      graphClient.on('agent:spawn', (agent) => {
        console.log('[Absalom] Agent spawned:', agent.label);
        // TODO: Visualize sub-agent tendril
      });
      
      graphClient.on('agent:complete', (sessionKey, findings) => {
        console.log('[Absalom] Agent complete:', sessionKey, findings);
        // TODO: Animate findings integration
      });
    }
    
    // Fallback for basic WebSocket (no GraphClient)
    function connectBasicWebSocket(wsUrl) {
      const ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        document.querySelector('.status-dot').style.background = '#1a6b4a';
        updateConnectionIndicator(true);
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'state' && (data.mode || data.state)) {
            state.mode = data.mode || data.state;
            updateStatus();
            updateModeEffects();
            state.lastActivity = Date.now();
          }
          if (data.type === 'graph:full' && data.graph) {
            graphData = data.graph;
            layoutGraph(data.graph);
          }
        } catch (e) {}
      };
      
      ws.onclose = () => {
        document.querySelector('.status-dot').style.background = '#4a2020';
        updateConnectionIndicator(false);
        setTimeout(() => connectBasicWebSocket(wsUrl), 5000);
      };
      
      ws.onerror = () => {};
    }
    
    // Query param override
    const queryWs = new URLSearchParams(window.location.search).get('ws');
    if (queryWs) {
      localStorage.setItem('absalom_ws', queryWs);
    }
    
    // Connection indicator
    const connIndicator = document.createElement('div');
    connIndicator.style.cssText = 'position:fixed;top:10px;right:10px;font-size:10px;color:#333;';
    connIndicator.id = 'conn-indicator';
    document.body.appendChild(connIndicator);
    
    function updateConnectionIndicator(connected) {
      const ind = document.getElementById('conn-indicator');
      if (connected) {
        ind.textContent = '● live';
        ind.style.color = '#1a6b4a';
      } else {
        ind.textContent = '○ reconnecting...';
        ind.style.color = '#4a2020';
      }
    }
    
    // Initial indicator state
    setInterval(() => {
      const ind = document.getElementById('conn-indicator');
      if (!graphClient && !WS_URL) {
        ind.textContent = '○ demo mode';
        ind.style.color = '#333';
      }
    }, 2000);
    
    // ============================================
    // Public API for Mycelium Layer Integration
    // ============================================
    
    /**
     * Set the graph data and trigger layout
     * Called by mycelium layer when it's ready
     */
    window.absalomSetGraph = function(graph) {
      graphData = graph;
      layoutGraph(graph);
    };
    
    /**
     * Get the current laid-out graph for rendering
     * Mycelium layer can use this for custom rendering
     */
    window.absalomGetLayout = function() {
      return {
        nodes: layoutNodes,
        edges: layoutEdges,
        waterLine: canvas.height * state.waterLineY,
        activations: graphActivations
      };
    };
    
    /**
     * Activate specific nodes in the graph
     */
    window.absalomActivate = function(nodeIds, intensity = 1) {
      const now = Date.now();
      for (const nodeId of nodeIds) {
        graphActivations.set(nodeId, { intensity, time: now });
      }
    };
    
    /**
     * Get the GraphClient instance for direct protocol access
     */
    window.absalomGetClient = function() {
      return graphClient;
    };
    
    /**
     * Hook for mycelium layer to inject custom depth rendering
     * Set this function to override the default mycelium rendering
     */
    window.absalomMyceliumRenderer = null;
    
    // Modify drawMyceliumLayer to check for custom renderer
    const originalDrawMyceliumLayer = drawMyceliumLayer;
    drawMyceliumLayer = function(waterLine) {
      if (typeof window.absalomMyceliumRenderer === 'function') {
        // Custom mycelium layer rendering
        window.absalomMyceliumRenderer(ctx, {
          waterLine,
          nodes: layoutNodes,
          edges: layoutEdges,
          activations: graphActivations,
          state: state,
          colors: colors
        });
      } else {
        // Default rendering
        originalDrawMyceliumLayer(waterLine);
      }
    };
  </script>
</body>
</html>
