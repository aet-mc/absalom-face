<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Absalom</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #050d0a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      color: #a8c5b8;
      overflow: hidden;
    }
    
    #main-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: fixed;
      bottom: 40px;
      text-align: center;
      z-index: 10;
    }
    
    .name {
      font-size: 1.4rem;
      letter-spacing: 0.4em;
      color: #2a5a45;
      text-transform: uppercase;
      text-shadow: 0 0 30px rgba(42, 90, 69, 0.5);
    }
    
    .status {
      margin-top: 8px;
      font-size: 0.75rem;
      color: #1a3d2e;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #1a6b4a;
      animation: statusPulse 2s ease-in-out infinite;
    }
    
    @keyframes statusPulse {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    .status.thinking .status-dot { background: #c9a227; animation-duration: 0.5s; }
    .status.responding .status-dot { background: #1a6b4a; animation-duration: 0.3s; }
  </style>
</head>
<body>
  <canvas id="main-canvas"></canvas>
  
  <div class="overlay">
    <div class="name">Absalom</div>
    <div class="status" id="status">
      <span class="status-dot"></span>
      <span id="status-text">present</span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    // Resize handler
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Color palette - wealth/growth
    const colors = {
      bg: '#050d0a',
      bgGradient: '#0a1a14',
      emerald: '#1a6b4a',
      emeraldDark: '#0d4d3d',
      emeraldLight: '#2a8a5a',
      gold: '#c9a227',
      goldLight: '#d4af37',
      goldDim: '#8a7020',
      teal: '#0d6b6e',
      text: '#a8c5b8'
    };
    
    // State
    let state = {
      mode: 'idle', // idle, listening, thinking, responding
      mouseX: window.innerWidth / 2,
      mouseY: window.innerHeight / 2,
      targetMouseX: window.innerWidth / 2,
      targetMouseY: window.innerHeight / 2,
      time: 0,
      heartbeat: 0,
      heartbeatSpeed: 0.02,
      blink: { active: false, progress: 0 },
      glance: { active: false, targetX: 0, targetY: 0, duration: 0 },
      saccade: { x: 0, y: 0, timer: 0 },
      pupilDilation: 1,
      neuralFire: [],
      energy: 0,
      lastActivity: Date.now()
    };
    
    // Particles for neural network
    const neurons = [];
    const connections = [];
    
    // Initialize neurons in a brain-like pattern
    function initNeurons() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2 - 30;
      
      for (let i = 0; i < 60; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 100 + Math.random() * 120;
        neurons.push({
          x: centerX + Math.cos(angle) * radius,
          y: centerY + Math.sin(angle) * radius * 0.7,
          baseX: centerX + Math.cos(angle) * radius,
          baseY: centerY + Math.sin(angle) * radius * 0.7,
          size: 2 + Math.random() * 3,
          energy: 0,
          connections: []
        });
      }
      
      // Create connections
      neurons.forEach((n, i) => {
        neurons.forEach((other, j) => {
          if (i !== j) {
            const dist = Math.hypot(n.x - other.x, n.y - other.y);
            if (dist < 80 && Math.random() > 0.6) {
              n.connections.push(j);
            }
          }
        });
      });
    }
    
    // Mouse tracking
    document.addEventListener('mousemove', (e) => {
      state.targetMouseX = e.clientX;
      state.targetMouseY = e.clientY;
      state.lastActivity = Date.now();
    });
    
    // Touch support
    document.addEventListener('touchmove', (e) => {
      state.targetMouseX = e.touches[0].clientX;
      state.targetMouseY = e.touches[0].clientY;
      state.lastActivity = Date.now();
    });
    
    // Click to change state (demo)
    document.addEventListener('click', () => {
      const modes = ['idle', 'listening', 'thinking', 'responding'];
      const currentIndex = modes.indexOf(state.mode);
      state.mode = modes[(currentIndex + 1) % modes.length];
      updateStatus();
      state.lastActivity = Date.now();
      
      // Fire neurons on click
      fireNeurons(5);
    });
    
    function updateStatus() {
      const statusEl = document.getElementById('status');
      const textEl = document.getElementById('status-text');
      statusEl.className = 'status ' + state.mode;
      textEl.textContent = state.mode === 'idle' ? 'present' : state.mode;
    }
    
    function fireNeurons(count) {
      for (let i = 0; i < count; i++) {
        const idx = Math.floor(Math.random() * neurons.length);
        neurons[idx].energy = 1;
        state.neuralFire.push({
          from: idx,
          to: neurons[idx].connections[Math.floor(Math.random() * neurons[idx].connections.length)],
          progress: 0
        });
      }
    }
    
    // Random behaviors
    setInterval(() => {
      // Random blink
      if (Math.random() > 0.7 && !state.blink.active) {
        state.blink.active = true;
        state.blink.progress = 0;
      }
      
      // Random glance
      if (Math.random() > 0.85 && !state.glance.active) {
        state.glance.active = true;
        state.glance.targetX = (Math.random() - 0.5) * 60;
        state.glance.targetY = (Math.random() - 0.5) * 30;
        state.glance.duration = 0;
      }
      
      // Random neural fire when thinking
      if (state.mode === 'thinking' && Math.random() > 0.3) {
        fireNeurons(3);
      }
    }, 1500);
    
    // Saccade timer (micro eye movements)
    setInterval(() => {
      state.saccade.x = (Math.random() - 0.5) * 4;
      state.saccade.y = (Math.random() - 0.5) * 2;
    }, 100);
    
    // Mode-based behavior
    setInterval(() => {
      if (state.mode === 'responding') {
        fireNeurons(2);
      }
    }, 200);
    
    function draw() {
      const W = canvas.width;
      const H = canvas.height;
      const centerX = W / 2;
      const centerY = H / 2 - 30;
      
      state.time += 0.016;
      state.heartbeat += state.heartbeatSpeed;
      
      // Adjust heartbeat speed based on mode
      const targetSpeed = {
        idle: 0.015,
        listening: 0.025,
        thinking: 0.04,
        responding: 0.035
      }[state.mode];
      state.heartbeatSpeed += (targetSpeed - state.heartbeatSpeed) * 0.01;
      
      // Smooth mouse tracking
      state.mouseX += (state.targetMouseX - state.mouseX) * 0.08;
      state.mouseY += (state.targetMouseY - state.mouseY) * 0.08;
      
      // Clear with gradient
      const bgGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, H);
      bgGrad.addColorStop(0, colors.bgGradient);
      bgGrad.addColorStop(1, colors.bg);
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);
      
      // Heartbeat energy
      const heartbeatPulse = Math.sin(state.heartbeat) * 0.5 + 0.5;
      state.energy = heartbeatPulse;
      
      // Draw neural network
      drawNeuralNetwork(centerX, centerY);
      
      // Draw main geometry
      drawGeometry(centerX, centerY, heartbeatPulse);
      
      // Draw eyes
      drawEyes(centerX, centerY);
      
      // Update neural fires
      state.neuralFire = state.neuralFire.filter(fire => {
        fire.progress += 0.05;
        return fire.progress < 1;
      });
      
      // Decay neuron energy
      neurons.forEach(n => {
        n.energy *= 0.95;
      });
      
      requestAnimationFrame(draw);
    }
    
    function drawNeuralNetwork(cx, cy) {
      // Draw connections
      neurons.forEach((n, i) => {
        n.connections.forEach(j => {
          const other = neurons[j];
          if (!other) return;
          
          const energy = Math.max(n.energy, other.energy);
          const alpha = 0.1 + energy * 0.4;
          
          ctx.beginPath();
          ctx.moveTo(n.x, n.y);
          ctx.lineTo(other.x, other.y);
          ctx.strokeStyle = energy > 0.3 ? 
            `rgba(201, 162, 39, ${alpha})` : 
            `rgba(26, 107, 74, ${alpha * 0.5})`;
          ctx.lineWidth = 1 + energy * 2;
          ctx.stroke();
        });
      });
      
      // Draw neurons
      neurons.forEach((n, i) => {
        // Subtle movement
        const offset = Math.sin(state.time * 2 + i) * 3;
        n.x = n.baseX + offset;
        n.y = n.baseY + Math.cos(state.time * 1.5 + i) * 2;
        
        const glow = n.energy > 0.1;
        const size = n.size + n.energy * 4;
        
        if (glow) {
          ctx.beginPath();
          ctx.arc(n.x, n.y, size + 8, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(201, 162, 39, ${n.energy * 0.3})`;
          ctx.fill();
        }
        
        ctx.beginPath();
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fillStyle = n.energy > 0.3 ? colors.gold : colors.emeraldDark;
        ctx.fill();
      });
      
      // Draw firing signals
      state.neuralFire.forEach(fire => {
        if (!neurons[fire.from] || !neurons[fire.to]) return;
        
        const from = neurons[fire.from];
        const to = neurons[fire.to];
        const x = from.x + (to.x - from.x) * fire.progress;
        const y = from.y + (to.y - from.y) * fire.progress;
        
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = colors.goldLight;
        ctx.fill();
        
        // Trail
        ctx.beginPath();
        ctx.moveTo(from.x + (to.x - from.x) * Math.max(0, fire.progress - 0.2), 
                   from.y + (to.y - from.y) * Math.max(0, fire.progress - 0.2));
        ctx.lineTo(x, y);
        ctx.strokeStyle = `rgba(212, 175, 55, ${1 - fire.progress})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      });
    }
    
    function drawGeometry(cx, cy, pulse) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      ctx.save();
      ctx.translate(cx, cy + breathe);
      
      // Outer energy ring
      ctx.beginPath();
      ctx.arc(0, 0, 140 + pulse * 10, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(26, 107, 74, ${0.2 + pulse * 0.2})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Pulsing inner ring
      ctx.beginPath();
      ctx.arc(0, 0, 100 + pulse * 5, 0, Math.PI * 2);
      const ringGrad = ctx.createRadialGradient(0, 0, 80, 0, 0, 120);
      ringGrad.addColorStop(0, 'rgba(26, 107, 74, 0.1)');
      ringGrad.addColorStop(0.5, `rgba(42, 138, 90, ${0.1 + pulse * 0.15})`);
      ringGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
      ctx.fillStyle = ringGrad;
      ctx.fill();
      
      // Hexagon frame
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const wobble = Math.sin(state.time * 2 + i) * 2;
        const radius = 95 + wobble + pulse * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = colors.emerald;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Gold accent vertices
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const radius = 95 + pulse * 5;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.arc(x, y, 4 + pulse * 2, 0, Math.PI * 2);
        ctx.fillStyle = colors.gold;
        ctx.fill();
      }
      
      // Inner structure - rotating slowly
      ctx.rotate(state.time * 0.1);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3);
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * 60, Math.sin(angle) * 60);
      }
      ctx.strokeStyle = `rgba(26, 107, 74, 0.3)`;
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function drawEyes(cx, cy) {
      const breathe = Math.sin(state.time * 0.8) * 5;
      
      // Calculate eye direction with glance and saccade
      let eyeTargetX = state.mouseX;
      let eyeTargetY = state.mouseY;
      
      if (state.glance.active) {
        state.glance.duration += 0.02;
        if (state.glance.duration > 1) {
          state.glance.active = false;
        } else {
          const glanceStrength = Math.sin(state.glance.duration * Math.PI);
          eyeTargetX = cx + state.glance.targetX * glanceStrength * 20;
          eyeTargetY = cy + state.glance.targetY * glanceStrength * 20;
        }
      }
      
      const eyeOffsetX = (eyeTargetX - cx) / window.innerWidth * 20 + state.saccade.x;
      const eyeOffsetY = (eyeTargetY - cy) / window.innerHeight * 15 + state.saccade.y;
      
      // Blink
      if (state.blink.active) {
        state.blink.progress += 0.12;
        if (state.blink.progress >= 1) {
          state.blink.active = false;
          state.blink.progress = 0;
        }
      }
      const blinkAmount = state.blink.active ? Math.sin(state.blink.progress * Math.PI) : 0;
      
      // Pupil dilation based on mode
      const targetDilation = {
        idle: 1,
        listening: 1.1,
        thinking: 1.4,
        responding: 1.2
      }[state.mode];
      state.pupilDilation += (targetDilation - state.pupilDilation) * 0.05;
      
      const eyeY = cy - 20 + breathe;
      const eyeSpacing = 45;
      
      // Draw each eye
      [-1, 1].forEach(side => {
        const eyeX = cx + side * eyeSpacing;
        const eyeHeight = 28 * (1 - blinkAmount * 0.95);
        
        // Eye socket glow
        ctx.beginPath();
        const glowGrad = ctx.createRadialGradient(eyeX, eyeY, 0, eyeX, eyeY, 40);
        glowGrad.addColorStop(0, `rgba(26, 107, 74, ${0.2 + state.energy * 0.2})`);
        glowGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
        ctx.arc(eyeX, eyeY, 40, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();
        
        // Eye socket (diamond shape)
        ctx.beginPath();
        ctx.moveTo(eyeX, eyeY - eyeHeight);
        ctx.lineTo(eyeX + 28, eyeY);
        ctx.lineTo(eyeX, eyeY + eyeHeight);
        ctx.lineTo(eyeX - 28, eyeY);
        ctx.closePath();
        ctx.fillStyle = '#08120e';
        ctx.fill();
        ctx.strokeStyle = colors.emeraldDark;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        if (blinkAmount < 0.8) {
          // Iris
          const irisX = eyeX + eyeOffsetX * 0.4;
          const irisY = eyeY + eyeOffsetY * 0.3;
          const irisSize = 14 * state.pupilDilation;
          
          // Iris glow
          ctx.beginPath();
          const irisGrad = ctx.createRadialGradient(irisX, irisY, 0, irisX, irisY, irisSize + 5);
          irisGrad.addColorStop(0, colors.emerald);
          irisGrad.addColorStop(0.7, colors.emeraldDark);
          irisGrad.addColorStop(1, 'rgba(13, 77, 61, 0)');
          ctx.arc(irisX, irisY, irisSize + 5, 0, Math.PI * 2);
          ctx.fillStyle = irisGrad;
          ctx.fill();
          
          // Iris
          ctx.beginPath();
          ctx.arc(irisX, irisY, irisSize, 0, Math.PI * 2);
          ctx.fillStyle = colors.emeraldDark;
          ctx.fill();
          
          // Pupil
          const pupilSize = 6 * state.pupilDilation;
          ctx.beginPath();
          ctx.arc(irisX + eyeOffsetX * 0.1, irisY + eyeOffsetY * 0.1, pupilSize, 0, Math.PI * 2);
          ctx.fillStyle = '#030806';
          ctx.fill();
          
          // Gold ring in iris (wealth accent)
          ctx.beginPath();
          ctx.arc(irisX, irisY, irisSize - 2, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(201, 162, 39, ${0.3 + state.energy * 0.3})`;
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Highlight
          ctx.beginPath();
          ctx.arc(irisX - 4, irisY - 4, 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(168, 197, 184, ${0.4 + state.energy * 0.2})`;
          ctx.fill();
          
          // Secondary highlight
          ctx.beginPath();
          ctx.arc(irisX + 3, irisY + 2, 1.5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(201, 162, 39, 0.5)';
          ctx.fill();
        }
      });
    }
    
    // Initialize and start
    initNeurons();
    draw();
    
    // Reinit neurons on resize
    window.addEventListener('resize', () => {
      neurons.length = 0;
      setTimeout(initNeurons, 100);
    });
  </script>
</body>
</html>
