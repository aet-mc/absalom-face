<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
  <title>Absalom â€” City of Mind</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; height: 100%; 
      overflow: hidden; 
      background: #0a0a12;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif;
    }
    #canvas { display: block; }
    
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      pointer-events: none;
    }
    .city-stats {
      background: rgba(10, 10, 20, 0.8);
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      backdrop-filter: blur(10px);
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-bottom: 4px;
    }
    .stat-label { color: rgba(100, 200, 255, 0.6); }
    .stat-value { color: rgba(100, 200, 255, 1); font-weight: 500; }
    #fps { opacity: 0.5; font-size: 10px; margin-top: 8px; }
    
    .time-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.5);
      font-size: 11px;
      text-align: right;
    }
    
    .cognitive-indicator {
      position: fixed;
      bottom: 60px;
      left: 20px;
      z-index: 100;
      padding: 10px 14px;
      background: rgba(10, 10, 20, 0.85);
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      backdrop-filter: blur(10px);
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      transition: all 0.3s ease;
    }
    .cognitive-indicator.thinking {
      border-color: rgba(0, 200, 255, 0.6);
      box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
    }
    .cognitive-indicator.responding {
      border-color: rgba(255, 200, 0, 0.6);
      box-shadow: 0 0 20px rgba(255, 200, 0, 0.3);
    }
    .cognitive-mode {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: rgba(100, 200, 255, 0.6);
      margin-bottom: 4px;
    }
    .cognitive-mode.thinking { color: rgba(0, 200, 255, 0.9); }
    .cognitive-mode.responding { color: rgba(255, 200, 0, 0.9); }
    .cognitive-district {
      font-size: 13px;
      font-weight: 500;
      color: rgba(255,255,255,0.9);
    }
    .activity-dot {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-right: 6px;
      background: rgba(100, 200, 255, 0.5);
      animation: none;
    }
    .activity-dot.active {
      animation: pulse-dot 1s ease-in-out infinite;
    }
    .activity-dot.thinking { background: rgba(0, 200, 255, 1); }
    .activity-dot.responding { background: rgba(255, 200, 0, 1); }
    
    @keyframes pulse-dot {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.7; }
    }
    
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: rgba(255,255,255,0.3);
      font-size: 11px;
      text-align: center;
    }
    
    /* Sound controls */
    .sound-indicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      gap: 8px;
    }
    .sound-btn {
      background: rgba(10, 10, 20, 0.8);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 6px;
      color: rgba(100, 200, 255, 0.7);
      font-size: 11px;
      padding: 6px 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.2s;
      pointer-events: auto;
    }
    .sound-btn:hover {
      border-color: rgba(100, 200, 255, 0.6);
      color: rgba(100, 200, 255, 1);
    }
    .sound-btn.active {
      background: rgba(0, 255, 255, 0.15);
      border-color: rgba(0, 255, 255, 0.5);
    }
    .sound-btn.muted {
      opacity: 0.5;
    }
    
    .weather-indicator {
      position: fixed;
      top: 60px;
      right: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.5);
      font-size: 11px;
      text-align: right;
    }
    .weather-indicator .weather-state {
      color: rgba(100, 200, 255, 0.8);
      font-weight: 500;
    }
    
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       INTERACTIVE UI ELEMENTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Tooltip for hover */
    .tooltip {
      position: fixed;
      padding: 8px 12px;
      background: rgba(10, 15, 25, 0.95);
      border: 1px solid rgba(100, 200, 255, 0.4);
      border-radius: 6px;
      color: rgba(100, 200, 255, 1);
      font-size: 12px;
      font-weight: 500;
      pointer-events: none;
      z-index: 200;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      backdrop-filter: blur(10px);
      white-space: nowrap;
      max-width: 200px;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    .tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .tooltip .district-tag {
      font-size: 10px;
      opacity: 0.6;
      margin-top: 2px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Info Panel */
    .info-panel {
      position: fixed;
      top: 50%;
      right: -320px;
      transform: translateY(-50%);
      width: 280px;
      background: rgba(10, 15, 25, 0.95);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-right: none;
      border-radius: 12px 0 0 12px;
      padding: 20px;
      z-index: 150;
      transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(15px);
      box-shadow: -5px 0 30px rgba(0, 0, 0, 0.5);
    }
    .info-panel.visible {
      right: 0;
    }
    .info-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
    }
    .info-panel-title {
      color: rgba(100, 200, 255, 1);
      font-size: 16px;
      font-weight: 600;
      line-height: 1.3;
      flex: 1;
      margin-right: 10px;
    }
    .info-panel-close {
      width: 28px;
      height: 28px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 50%;
      background: transparent;
      color: rgba(100, 200, 255, 0.7);
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }
    .info-panel-close:hover {
      background: rgba(100, 200, 255, 0.1);
      color: rgba(100, 200, 255, 1);
      border-color: rgba(100, 200, 255, 0.5);
    }
    .info-panel-district {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
    }
    .info-panel-section {
      margin-bottom: 14px;
    }
    .info-panel-label {
      color: rgba(100, 200, 255, 0.5);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    .info-panel-value {
      color: rgba(255, 255, 255, 0.9);
      font-size: 13px;
    }
    .info-panel-sources {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }
    .info-panel-source {
      padding: 4px 8px;
      background: rgba(100, 200, 255, 0.1);
      border: 1px solid rgba(100, 200, 255, 0.2);
      border-radius: 4px;
      font-size: 10px;
      color: rgba(100, 200, 255, 0.8);
    }
    .info-panel-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(100, 200, 255, 0.3), transparent);
      margin: 16px 0;
    }
    
    /* Focus mode indicator */
    .focus-indicator {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(10, 15, 25, 0.9);
      border: 1px solid rgba(100, 200, 255, 0.4);
      border-radius: 20px;
      color: rgba(100, 200, 255, 1);
      font-size: 12px;
      font-weight: 500;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(10px);
    }
    .focus-indicator.visible {
      opacity: 1;
    }
    .focus-indicator span {
      opacity: 0.6;
      margin-left: 8px;
    }
    
    /* Pause indicator */
    .pause-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      background: rgba(10, 15, 25, 0.95);
      border: 2px solid rgba(100, 200, 255, 0.5);
      border-radius: 12px;
      color: rgba(100, 200, 255, 1);
      font-size: 18px;
      font-weight: 600;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .pause-indicator.visible {
      opacity: 1;
    }
    
    /* Interactive cursor states */
    canvas.interactive-hover {
      cursor: pointer;
    }
    canvas.interactive-grabbing {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="hud">
    <div class="city-stats">
      <div class="stat-row">
        <span class="stat-label">structures</span>
        <span class="stat-value" id="buildingCount">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">districts</span>
        <span class="stat-value" id="districtCount">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">connections</span>
        <span class="stat-value" id="connectionCount">0</span>
      </div>
      <div id="fps"></div>
    </div>
  </div>
  
  <div class="time-indicator">
    <div id="timeDisplay">--:--</div>
    <div id="cyclePhase">dawn</div>
  </div>
  
  <div class="controls-hint">
    drag to orbit Â· scroll to zoom Â· click to select Â· 1-5 districts Â· 0/ESC reset Â· SPACE pause Â· arrows rotate
  </div>
  
  <div class="cognitive-indicator" id="cognitiveIndicator">
    <div class="cognitive-mode" id="cognitiveMode">
      <span class="activity-dot" id="activityDot"></span>idle
    </div>
    <div class="cognitive-district" id="cognitiveDistrict">â€”</div>
  </div>
  
  <div class="weather-indicator">
    <div>weather: <span class="weather-state" id="weatherState">clear</span></div>
  </div>
  
  <div class="sound-indicator">
    <button class="sound-btn" id="soundToggle" title="Toggle Sound (S)">ğŸ”‡ Off</button>
    <button class="sound-btn" id="muteToggle" title="Mute (M)" style="display:none;">ğŸ”Š</button>
  </div>
  
  <!-- Interactive UI Elements -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-name"></div>
    <div class="district-tag"></div>
  </div>
  
  <div class="info-panel" id="infoPanel">
    <div class="info-panel-header">
      <div class="info-panel-title" id="infoPanelTitle">Building Name</div>
      <button class="info-panel-close" id="infoPanelClose">Ã—</button>
    </div>
    <div class="info-panel-district" id="infoPanelDistrict">DISTRICT</div>
    <div class="info-panel-divider"></div>
    <div class="info-panel-section">
      <div class="info-panel-label">Type</div>
      <div class="info-panel-value" id="infoPanelType">Structure</div>
    </div>
    <div class="info-panel-section">
      <div class="info-panel-label">Dimensions</div>
      <div class="info-panel-value" id="infoPanelDimensions">--</div>
    </div>
    <div class="info-panel-section">
      <div class="info-panel-label">Memory Sources</div>
      <div class="info-panel-sources" id="infoPanelSources"></div>
    </div>
  </div>
  
  <div class="focus-indicator" id="focusIndicator">
    <span id="focusDistrictName">DISTRICT</span>
    <span>(0 or ESC to exit)</span>
  </div>
  
  <div class="pause-indicator" id="pauseIndicator">â¸ PAUSED</div>

  <!-- Three.js with post-processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ABSALOM CITY â€” A Mind Made Manifest (Cyberpunk Utopia Edition)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const canvas = document.getElementById('canvas');
    const buildingCountEl = document.getElementById('buildingCount');
    const districtCountEl = document.getElementById('districtCount');
    const connectionCountEl = document.getElementById('connectionCount');
    const fpsEl = document.getElementById('fps');
    const timeDisplayEl = document.getElementById('timeDisplay');
    const cyclePhaseEl = document.getElementById('cyclePhase');
    
    // Performance detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const qualityLevel = isMobile ? 'low' : 'high';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a15, 0.006);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 40, 50);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: !isMobile,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    renderer.shadowMap.enabled = !isMobile;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    
    // Post-processing: Bloom
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      isMobile ? 0.8 : 1.2,  // strength
      0.4,                    // radius
      0.85                    // threshold
    );
    composer.addPass(bloomPass);
    
    // Orbit controls
    const controls = new THREE.OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 10;
    controls.maxDistance = 150;
    controls.target.set(0, 5, 0);
    
    // Zoom sound trigger
    let lastZoomDistance = camera.position.distanceTo(controls.target);
    let zoomSoundThrottle = 0;
    canvas.addEventListener('wheel', (e) => {
      const now = Date.now();
      if (now - zoomSoundThrottle < 200) return; // Throttle
      
      const currentDistance = camera.position.distanceTo(controls.target);
      const delta = currentDistance - lastZoomDistance;
      
      if (Math.abs(delta) > 2) {
        soundManager.playZoomSound(delta < 0); // Zooming in = negative delta
        zoomSoundThrottle = now;
      }
      lastZoomDistance = currentDistance;
    }, { passive: true });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT DEFINITIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const DISTRICTS = {
      core: { 
        name: 'NEXUS CORE', 
        color: new THREE.Color(0x00ffff),
        emissive: new THREE.Color(0x003344),
        position: new THREE.Vector3(0, 0, 0),
        keywords: ['self', 'identity', 'soul', 'absalom']
      },
      trading: { 
        name: 'MARKET SPIRES', 
        color: new THREE.Color(0xffd700),
        emissive: new THREE.Color(0x332200),
        position: new THREE.Vector3(25, 0, 10),
        keywords: ['stock', 'trading', 'market', 'options', 'scanner', 'asymmetry']
      },
      infrastructure: { 
        name: 'DATAFORGE', 
        color: new THREE.Color(0xff6b9d),
        emissive: new THREE.Color(0x331122),
        position: new THREE.Vector3(-20, 0, 15),
        keywords: ['server', 'deploy', 'docker', 'tailscale', 'coolify', 'pm2']
      },
      projects: { 
        name: 'CREATION LABS', 
        color: new THREE.Color(0x9d6bff),
        emissive: new THREE.Color(0x220033),
        position: new THREE.Vector3(10, 0, -25),
        keywords: ['project', 'build', 'create', 'app', 'visualization']
      },
      memory: { 
        name: 'MEMORY BANKS', 
        color: new THREE.Color(0x6bff9d),
        emissive: new THREE.Color(0x113322),
        position: new THREE.Vector3(-15, 0, -20),
        keywords: ['memory', 'remember', 'decision', 'learned', 'preference']
      },
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CITY STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const city = {
      buildings: [],
      connections: [],
      districts: new Map(),
      drones: [],
      particles: null,
      districtLabels: [],
      stars: null,
      coreRings: [],
      time: 0,
      realTime: new Date(),
      sunPosition: new THREE.Vector3(),
      nightIntensity: 0,
      // Ambient life systems
      trafficLights: [],
      elevators: [],
      fireflies: null,
      dustMotes: null,
      dataStreams: [],
      aircraft: [],
      shootingStars: [],
      windowStates: new Map(), // Track individual window states
      // Weather system
      weather: 'clear', // 'clear' | 'rain' | 'fog' | 'aurora'
      weatherTransition: 0, // 0-1 transition progress
      targetWeather: 'clear',
      rainSystem: null,
      puddles: [],
      fogPlanes: [],
      aurora: null,
      weatherIntensity: 0, // Current effect intensity (for transitions)
    };
    
    const weatherStateEl = document.getElementById('weatherState');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT RHYTHM PROFILES - Each district has its own "personality"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT RHYTHM PROFILES - CALMED DOWN for peaceful idle state
    // Activity should only be noticeable during actual cognitive work
    // Idle = quiet city at 3am, not epileptic lightshow
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const DISTRICT_RHYTHMS = {
      core: {
        baseSpeed: 0.3,         // Slow, meditative
        pulseFrequency: 0.4,    // Very gentle breathing
        activityLevel: 0.15,    // Minimal idle activity
        burstChance: 0.0001,    // Almost never in idle
        color: 0x00ffff
      },
      trading: {
        baseSpeed: 0.5,         // Calmed from 1.8
        pulseFrequency: 0.6,    // Slow pulse, not frantic ticker
        activityLevel: 0.2,     // Low idle activity
        burstChance: 0.0002,    // Very rare (only during actual trading)
        color: 0xffd700
      },
      infrastructure: {
        baseSpeed: 0.2,         // Steady, quiet
        pulseFrequency: 0.3,    // Slow server heartbeat
        activityLevel: 0.1,     // Minimal, steady
        burstChance: 0.00005,   // Servers rarely spike when idle
        color: 0xff6b9d
      },
      projects: {
        baseSpeed: 0.3,         // Dormant until active
        pulseFrequency: 0.4,
        activityLevel: 0.12,
        burstChance: 0.0001,    // Creative work is intentional
        color: 0x9d6bff
      },
      memory: {
        baseSpeed: 0.15,        // Slowest, archival silence
        pulseFrequency: 0.2,    // Barely perceptible breathing
        activityLevel: 0.05,    // Archives at rest
        burstChance: 0.00002,   // Memories only recalled when needed
        color: 0x6bff9d
      }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: TRAFFIC LIGHTS (vehicles/data packets on roads)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createTrafficLights() {
      const trafficCount = isMobile ? 12 : 30; // Reduced for calmer traffic
      const trafficGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(trafficCount * 3);
      const colors = new Float32Array(trafficCount * 3);
      const velocities = [];
      const paths = [];
      
      // Define road paths between districts
      const districtPositions = Object.values(DISTRICTS).map(d => d.position);
      const roadPaths = [];
      
      // Core to each district
      districtPositions.forEach(pos => {
        if (pos.x !== 0 || pos.z !== 0) {
          roadPaths.push({ start: { x: 0, z: 0 }, end: { x: pos.x, z: pos.z } });
        }
      });
      
      // Between adjacent districts
      for (let i = 1; i < districtPositions.length; i++) {
        const curr = districtPositions[i];
        const next = districtPositions[(i % (districtPositions.length - 1)) + 1];
        if (curr && next) {
          roadPaths.push({ start: { x: curr.x, z: curr.z }, end: { x: next.x, z: next.z } });
        }
      }
      
      for (let i = 0; i < trafficCount; i++) {
        const path = roadPaths[i % roadPaths.length];
        const progress = Math.random();
        
        // Position along path
        const x = path.start.x + (path.end.x - path.start.x) * progress;
        const z = path.start.z + (path.end.z - path.start.z) * progress;
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = 0.3 + Math.random() * 0.3; // Slightly above ground
        positions[i * 3 + 2] = z;
        
        // Color based on direction (cyan going out, warm coming in)
        const outbound = Math.random() > 0.5;
        const color = outbound ? new THREE.Color(0x00ffff) : new THREE.Color(0xffaa44);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
        
        velocities.push({
          progress: progress,
          speed: 0.0008 + Math.random() * 0.0012, // Slower, calmer traffic
          direction: outbound ? 1 : -1,
          pathIndex: i % roadPaths.length
        });
        paths.push(path);
      }
      
      trafficGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      trafficGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const trafficMaterial = new THREE.PointsMaterial({
        size: isMobile ? 0.4 : 0.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
      });
      
      city.trafficLights = new THREE.Points(trafficGeometry, trafficMaterial);
      city.trafficLights.userData = { velocities, paths, roadPaths };
      scene.add(city.trafficLights);
    }
    
    function updateTrafficLights(dt) {
      if (!city.trafficLights) return;
      
      const positions = city.trafficLights.geometry.attributes.position.array;
      const { velocities, roadPaths } = city.trafficLights.userData;
      
      for (let i = 0; i < velocities.length; i++) {
        const v = velocities[i];
        const path = roadPaths[v.pathIndex];
        
        // Move along path
        v.progress += v.speed * v.direction;
        
        // Loop back when reaching end
        if (v.progress > 1) {
          v.progress = 0;
          v.pathIndex = Math.floor(Math.random() * roadPaths.length);
        } else if (v.progress < 0) {
          v.progress = 1;
          v.pathIndex = Math.floor(Math.random() * roadPaths.length);
        }
        
        const newPath = roadPaths[v.pathIndex];
        positions[i * 3] = newPath.start.x + (newPath.end.x - newPath.start.x) * v.progress;
        positions[i * 3 + 1] = 0.3 + Math.sin(dt * 0.8 + i) * 0.05; // Very gentle, slow bobbing
        positions[i * 3 + 2] = newPath.start.z + (newPath.end.z - newPath.start.z) * v.progress;
      }
      
      city.trafficLights.geometry.attributes.position.needsUpdate = true;
      
      // Brighter at night
      city.trafficLights.material.opacity = 0.6 + city.nightIntensity * 0.4;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: ELEVATORS (visible in tall buildings)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function addElevatorToBuilding(building) {
      if (building.height < 25) return; // Only the tallest buildings
      
      const elevatorCount = Math.floor(building.height / 40) + 1; // Fewer elevators
      const baseHeight = 2; // Above the base/lobby section
      
      for (let e = 0; e < elevatorCount; e++) {
        const elevatorGeo = new THREE.BoxGeometry(0.15, 0.4, 0.15);
        const elevatorMat = new THREE.MeshBasicMaterial({
          color: 0xffffcc,
          transparent: true,
          opacity: 0.8
        });
        const elevator = new THREE.Mesh(elevatorGeo, elevatorMat);
        
        // Position on building edge
        const side = e % 4;
        const offset = building.width / 2 + 0.1;
        switch (side) {
          case 0: elevator.position.set(offset, baseHeight, 0); break;
          case 1: elevator.position.set(-offset, baseHeight, 0); break;
          case 2: elevator.position.set(0, baseHeight, offset); break;
          case 3: elevator.position.set(0, baseHeight, -offset); break;
        }
        
        elevator.userData = {
          isElevator: true,
          floor: Math.random(),
          targetFloor: Math.random(),
          speed: 0.002 + Math.random() * 0.004, // Slower elevators
          waitTime: 0,
          maxWait: 200 + Math.random() * 400, // Much longer waits between trips
          buildingHeight: building.height,
          baseHeight: baseHeight // Floor where elevator starts
        };
        
        building.mesh.add(elevator);
        city.elevators.push(elevator);
      }
    }
    
    function updateElevators(dt) {
      city.elevators.forEach(elevator => {
        const data = elevator.userData;
        
        if (data.waitTime > 0) {
          data.waitTime--;
          // Subtle glow while waiting (no aggressive blinking)
          elevator.material.opacity = 0.6 + Math.sin(dt * 1.5) * 0.15;
          return;
        }
        
        elevator.material.opacity = 0.5 + city.nightIntensity * 0.2;
        
        // Move toward target - slower
        const diff = data.targetFloor - data.floor;
        if (Math.abs(diff) < 0.01) {
          // Arrived - wait longer then pick new target
          data.waitTime = data.maxWait * 2; // Double the wait time
          data.targetFloor = Math.random();
        } else {
          data.floor += Math.sign(diff) * data.speed * 0.5; // Move slower
        }
        
        // Position elevator - now goes from baseHeight to buildingHeight
        const baseHeight = data.baseHeight || 2;
        const travelHeight = data.buildingHeight - baseHeight;
        const yPos = baseHeight + data.floor * travelHeight;
        elevator.position.y = yPos;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: FIREFLIES (night) & DUST MOTES (day)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createFirefliesAndDust() {
      const count = isMobile ? 80 : 200;
      
      // Fireflies (visible at night)
      const fireflyGeometry = new THREE.BufferGeometry();
      const fireflyPositions = new Float32Array(count * 3);
      const fireflyPhases = new Float32Array(count); // For twinkling
      
      for (let i = 0; i < count; i++) {
        fireflyPositions[i * 3] = (Math.random() - 0.5) * 120;
        fireflyPositions[i * 3 + 1] = 2 + Math.random() * 30;
        fireflyPositions[i * 3 + 2] = (Math.random() - 0.5) * 120;
        fireflyPhases[i] = Math.random() * Math.PI * 2;
      }
      
      fireflyGeometry.setAttribute('position', new THREE.BufferAttribute(fireflyPositions, 3));
      fireflyGeometry.setAttribute('phase', new THREE.BufferAttribute(fireflyPhases, 1));
      
      const fireflyMaterial = new THREE.PointsMaterial({
        color: 0xccff66,
        size: 0.4,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
      });
      
      city.fireflies = new THREE.Points(fireflyGeometry, fireflyMaterial);
      city.fireflies.userData = { phases: fireflyPhases, velocities: [] };
      
      // Initialize velocities for wandering
      for (let i = 0; i < count; i++) {
        city.fireflies.userData.velocities.push({
          x: (Math.random() - 0.5) * 0.02,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.02
        });
      }
      
      scene.add(city.fireflies);
      
      // Dust motes (visible during day, especially in light shafts)
      const dustGeometry = new THREE.BufferGeometry();
      const dustPositions = new Float32Array(count * 3);
      
      for (let i = 0; i < count; i++) {
        dustPositions[i * 3] = (Math.random() - 0.5) * 80;
        dustPositions[i * 3 + 1] = 5 + Math.random() * 40;
        dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
      }
      
      dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
      
      const dustMaterial = new THREE.PointsMaterial({
        color: 0xffffee,
        size: 0.15,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
      });
      
      city.dustMotes = new THREE.Points(dustGeometry, dustMaterial);
      scene.add(city.dustMotes);
    }
    
    function updateFirefliesAndDust(dt) {
      // Fireflies - only visible at night, twinkle randomly
      if (city.fireflies) {
        const positions = city.fireflies.geometry.attributes.position.array;
        const phases = city.fireflies.userData.phases;
        const velocities = city.fireflies.userData.velocities;
        
        city.fireflies.material.opacity = city.nightIntensity * 0.8;
        
        // Only update positions if visible
        if (city.nightIntensity > 0.2) {
          for (let i = 0; i < phases.length; i++) {
            // Gentle wandering motion
            const v = velocities[i];
            positions[i * 3] += v.x + Math.sin(dt + phases[i]) * 0.01;
            positions[i * 3 + 1] += v.y + Math.cos(dt * 0.7 + phases[i]) * 0.005;
            positions[i * 3 + 2] += v.z + Math.sin(dt * 0.8 + phases[i]) * 0.01;
            
            // Boundary check - keep in city area
            if (Math.abs(positions[i * 3]) > 60) v.x *= -1;
            if (positions[i * 3 + 1] < 2 || positions[i * 3 + 1] > 35) v.y *= -1;
            if (Math.abs(positions[i * 3 + 2]) > 60) v.z *= -1;
            
            // Occasionally change direction
            if (Math.random() < 0.002) {
              v.x = (Math.random() - 0.5) * 0.02;
              v.y = (Math.random() - 0.5) * 0.01;
              v.z = (Math.random() - 0.5) * 0.02;
            }
          }
          city.fireflies.geometry.attributes.position.needsUpdate = true;
        }
        
        // Twinkle effect - vary size
        city.fireflies.material.size = 0.3 + Math.sin(dt * 3) * 0.15;
      }
      
      // Dust motes - visible during day, drift slowly
      if (city.dustMotes) {
        const dayIntensity = 1 - city.nightIntensity;
        // More visible during golden hour (dramatic light shafts)
        const goldenBoost = lighting.goldenHourIntensity * 0.5;
        city.dustMotes.material.opacity = dayIntensity * 0.25 + goldenBoost;
        
        // Warm color during golden hour
        if (lighting.goldenHourIntensity > 0) {
          city.dustMotes.material.color.setHex(0xffddaa);
        } else {
          city.dustMotes.material.color.setHex(0xffffee);
        }
        
        // Gentle drift
        const positions = city.dustMotes.geometry.attributes.position.array;
        for (let i = 0; i < positions.length / 3; i++) {
          positions[i * 3] += Math.sin(dt * 0.2 + i * 0.5) * 0.005;
          positions[i * 3 + 1] += 0.002 + Math.sin(dt * 0.3 + i) * 0.002;
          positions[i * 3 + 2] += Math.cos(dt * 0.15 + i * 0.3) * 0.005;
          
          // Reset when too high
          if (positions[i * 3 + 1] > 50) {
            positions[i * 3 + 1] = 5;
            positions[i * 3] = (Math.random() - 0.5) * 80;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 80;
          }
        }
        city.dustMotes.geometry.attributes.position.needsUpdate = true;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: DATA STREAMS (flowing between connected buildings)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDataStream(connection) {
      const particleCount = isMobile ? 8 : 15;
      const streamGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const progresses = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount; i++) {
        progresses[i] = i / particleCount;
        // Initial positions will be updated in animation
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;
      }
      
      streamGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const streamMaterial = new THREE.PointsMaterial({
        color: connection.line.material.color,
        size: 0.25,
        transparent: true,
        opacity: 0.7,
        sizeAttenuation: true,
      });
      
      const stream = new THREE.Points(streamGeometry, streamMaterial);
      stream.userData = {
        connection,
        progresses,
        speed: 0.004 + Math.random() * 0.006, // Much slower, calmer flow
        active: Math.random() > 0.7 // Most connections dormant in idle (only 30% active)
      };
      
      scene.add(stream);
      city.dataStreams.push(stream);
    }
    
    function updateDataStreams(dt) {
      city.dataStreams.forEach(stream => {
        if (!stream.userData.active) {
          // Very rarely activate in idle - data flows when there's work
          if (Math.random() < 0.0002) stream.userData.active = true;
          stream.material.opacity = 0;
          return;
        }
        
        const { connection, progresses, speed } = stream.userData;
        const from = connection.from;
        const to = connection.to;
        const positions = stream.geometry.attributes.position.array;
        
        // Bezier curve midpoint (same as connection)
        const midX = (from.x + to.x) / 2;
        const midY = 2 + Math.random() * 2;
        const midZ = (from.z + to.z) / 2;
        
        for (let i = 0; i < progresses.length; i++) {
          progresses[i] += speed;
          if (progresses[i] > 1) progresses[i] -= 1;
          
          // Quadratic bezier interpolation
          const t = progresses[i];
          const mt = 1 - t;
          
          positions[i * 3] = mt * mt * from.x + 2 * mt * t * midX + t * t * to.x;
          positions[i * 3 + 1] = mt * mt * 0.5 + 2 * mt * t * midY + t * t * 0.5 + Math.sin(t * Math.PI) * 1.5;
          positions[i * 3 + 2] = mt * mt * from.z + 2 * mt * t * midZ + t * t * to.z;
        }
        
        stream.geometry.attributes.position.needsUpdate = true;
        stream.material.opacity = 0.3 + city.nightIntensity * 0.3; // Slightly dimmer
        
        // More frequently deactivate to keep city calm
        if (Math.random() < 0.002) stream.userData.active = false;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: AIRCRAFT & SATELLITES (distant sky movement)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createAircraft() {
      const aircraftCount = isMobile ? 3 : 6;
      
      for (let i = 0; i < aircraftCount; i++) {
        const aircraftGroup = new THREE.Group();
        
        // Main light
        const lightGeo = new THREE.SphereGeometry(0.3, 6, 6);
        const lightMat = new THREE.MeshBasicMaterial({
          color: i < aircraftCount / 2 ? 0xffffff : 0xff3333, // White for planes, red for others
          transparent: true,
          opacity: 0.9
        });
        const mainLight = new THREE.Mesh(lightGeo, lightMat);
        aircraftGroup.add(mainLight);
        
        // Blinking nav light
        const navGeo = new THREE.SphereGeometry(0.15, 4, 4);
        const navMat = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.8
        });
        const navLight = new THREE.Mesh(navGeo, navMat);
        navLight.position.x = 0.5;
        navLight.userData.blink = true;
        aircraftGroup.add(navLight);
        
        // Trail (for satellites)
        if (i >= aircraftCount / 2) {
          const trailGeo = new THREE.CylinderGeometry(0.05, 0.15, 2, 4);
          const trailMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2
          });
          const trail = new THREE.Mesh(trailGeo, trailMat);
          trail.rotation.z = Math.PI / 2;
          trail.position.x = -1.2;
          aircraftGroup.add(trail);
        }
        
        // Random path across sky
        const isHighAltitude = i >= aircraftCount / 2; // Satellites higher
        aircraftGroup.userData = {
          startAngle: Math.random() * Math.PI * 2,
          speed: isHighAltitude ? 0.0003 : 0.0008,
          altitude: isHighAltitude ? 200 + Math.random() * 100 : 80 + Math.random() * 40,
          radius: 250 + Math.random() * 100,
          progress: Math.random(),
          isPlane: !isHighAltitude
        };
        
        scene.add(aircraftGroup);
        city.aircraft.push(aircraftGroup);
      }
    }
    
    function updateAircraft(dt) {
      city.aircraft.forEach(aircraft => {
        const data = aircraft.userData;
        
        // Move along arc
        data.progress += data.speed;
        if (data.progress > 1) {
          data.progress = 0;
          data.startAngle = Math.random() * Math.PI * 2;
        }
        
        const angle = data.startAngle + data.progress * Math.PI;
        aircraft.position.x = Math.cos(angle) * data.radius;
        aircraft.position.y = data.altitude + Math.sin(data.progress * Math.PI) * 20;
        aircraft.position.z = Math.sin(angle) * data.radius * 0.6;
        
        // Face direction of movement
        aircraft.lookAt(
          aircraft.position.x + Math.cos(angle + 0.1) * 10,
          aircraft.position.y,
          aircraft.position.z + Math.sin(angle + 0.1) * 10
        );
        
        // Blinking nav lights
        aircraft.children.forEach(child => {
          if (child.userData.blink) {
            child.material.opacity = Math.sin(dt * 5) > 0.5 ? 0.9 : 0;
          }
        });
        
        // Less visible during bright day, more at night
        const visibility = 0.3 + city.nightIntensity * 0.7;
        aircraft.children[0].material.opacity = visibility;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: SHOOTING STARS (occasional at night)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createShootingStar() {
      if (city.nightIntensity < 0.5) return; // Only at night
      if (city.shootingStars.length > 2) return; // Limit concurrent
      
      const starGroup = new THREE.Group();
      
      // Star head
      const headGeo = new THREE.SphereGeometry(0.5, 6, 6);
      const headMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1
      });
      const head = new THREE.Mesh(headGeo, headMat);
      starGroup.add(head);
      
      // Trail
      const trailLength = 8 + Math.random() * 12;
      const trailGeo = new THREE.ConeGeometry(0.4, trailLength, 6);
      const trailMat = new THREE.MeshBasicMaterial({
        color: 0xaaddff,
        transparent: true,
        opacity: 0.6
      });
      const trail = new THREE.Mesh(trailGeo, trailMat);
      trail.rotation.x = Math.PI / 2;
      trail.position.z = trailLength / 2;
      starGroup.add(trail);
      
      // Random start position (high in sky)
      const startAngle = Math.random() * Math.PI * 2;
      starGroup.position.set(
        Math.cos(startAngle) * 300,
        150 + Math.random() * 100,
        Math.sin(startAngle) * 200
      );
      
      // Direction (generally downward and inward)
      const endAngle = startAngle + (Math.random() - 0.5) * 1;
      starGroup.userData = {
        velocity: new THREE.Vector3(
          (Math.cos(endAngle) * 100 - starGroup.position.x) * 0.02,
          -2 - Math.random() * 2,
          (Math.sin(endAngle) * 100 - starGroup.position.z) * 0.02
        ),
        life: 1.0,
        decay: 0.015 + Math.random() * 0.01
      };
      
      // Face direction of travel
      starGroup.lookAt(
        starGroup.position.x + starGroup.userData.velocity.x * 10,
        starGroup.position.y + starGroup.userData.velocity.y * 10,
        starGroup.position.z + starGroup.userData.velocity.z * 10
      );
      
      scene.add(starGroup);
      city.shootingStars.push(starGroup);
    }
    
    function updateShootingStars() {
      // Occasionally spawn new ones at night
      if (city.nightIntensity > 0.5 && Math.random() < 0.002) {
        createShootingStar();
      }
      
      for (let i = city.shootingStars.length - 1; i >= 0; i--) {
        const star = city.shootingStars[i];
        const data = star.userData;
        
        // Move
        star.position.add(data.velocity);
        
        // Fade
        data.life -= data.decay;
        star.children.forEach(child => {
          child.material.opacity = data.life;
        });
        
        // Remove when faded
        if (data.life <= 0) {
          scene.remove(star);
          city.shootingStars.splice(i, 1);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: WINDOW ACTIVITY SYSTEM (turning on/off, TV flicker)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function initializeWindowStates(building) {
      const windowStates = [];
      
      // Recursively find all window-like elements in the building
      function findWindows(obj) {
        if (!obj) return;
        
        // Check if this is a window-like element (plane with basic material, not a frame line)
        if (obj.geometry && obj.material && 
            (obj.geometry.type === 'PlaneGeometry' || 
             obj.geometry.type === 'BoxGeometry' || 
             obj.geometry.type === 'TorusGeometry') &&
            obj.material.type === 'MeshBasicMaterial' &&
            obj.material.transparent === true &&
            !obj.userData.hologram) { // Exclude holograms
          
          const state = {
            isOn: Math.random() > 0.08,  // 92% windows stay lit - stable city
            isTV: Math.random() < 0.03,  // Only 3% are TVs - much rarer
            baseOpacity: obj.material.opacity,
            targetOpacity: obj.material.opacity,
            transitionSpeed: 0.003 + Math.random() * 0.005, // Very slow transitions
            nextToggle: 300 + Math.random() * 600,
            tvFlickerPhase: Math.random() * Math.PI * 2,
            originalColor: obj.material.color.clone()
          };
          windowStates.push({ child: obj, state });
        }
        
        // Recurse into children
        if (obj.children) {
          obj.children.forEach(child => findWindows(child));
        }
      }
      
      findWindows(building.mesh);
      city.windowStates.set(building, windowStates);
    }
    
    function updateWindowActivity(dt) {
      city.windowStates.forEach((windows, building) => {
        const districtRhythm = DISTRICT_RHYTHMS[building.district] || DISTRICT_RHYTHMS.core;
        
        windows.forEach(({ child, state }) => {
          // Count down to next toggle
          state.nextToggle--;
          
          // Very rarely toggle window state - city is peaceful at rest
          if (state.nextToggle <= 0) {
            // Windows almost always stay on (95%+), especially at night
            const onChance = 0.92 + city.nightIntensity * 0.06;
            state.isOn = Math.random() < onChance;
            state.targetOpacity = state.isOn ? 
              (state.baseOpacity * 0.8 + Math.random() * state.baseOpacity * 0.4) : 
              0.08;
            // Very long intervals: 8-20 seconds before next possible change
            state.nextToggle = 500 + Math.random() * 700;
          }
          
          // TV effect - VERY subtle, no rapid flicker
          if (state.isTV && state.isOn && city.nightIntensity > 0.3) {
            // Slow, gentle color shift instead of frantic flicker
            const slowPulse = Math.sin(dt * 0.5 + state.tvFlickerPhase) * 0.05;
            child.material.opacity = state.targetOpacity + slowPulse;
            // Subtle blue TV glow, no rapid color changes
            child.material.color.setHex(0x9999cc);
          } else {
            // Very smooth transition to target
            const current = child.material.opacity;
            const diff = state.targetOpacity - current;
            child.material.opacity = current + diff * state.transitionSpeed;
            
            // Restore original district color with night warmth adjustment
            if (!state.isTV && state.originalColor) {
              const warmth = city.nightIntensity * 0.15;
              child.material.color.copy(state.originalColor);
              child.material.color.r = Math.min(1, state.originalColor.r + warmth * 0.3);
              child.material.color.g = Math.min(1, state.originalColor.g + warmth * 0.1);
            }
          }
        });
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: DISTRICT-SPECIFIC BUILDING PULSE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateDistrictPulses(dt) {
      city.buildings.forEach(building => {
        const rhythm = DISTRICT_RHYTHMS[building.district] || DISTRICT_RHYTHMS.core;
        
        // Very gentle, slow pulse - like breathing at rest
        const pulse = Math.sin(dt * rhythm.pulseFrequency) * 0.5 + 0.5;
        
        // Activity burst - almost never in idle state
        const burst = Math.random() < rhythm.burstChance ? 0.15 : 0;
        
        // Base glow is stable, minimal variation
        const baseIntensity = 0.25 + city.nightIntensity * 0.2;
        const rhythmIntensity = pulse * rhythm.activityLevel * 0.08;
        const targetEmissive = baseIntensity + rhythmIntensity + burst;
        
        // Recursively update emissive materials and pulsing elements
        function updateMesh(obj) {
          if (!obj) return;
          
          // Update emissive intensity on materials
          if (obj.material && obj.material.emissiveIntensity !== undefined) {
            obj.material.emissiveIntensity = targetEmissive;
          }
          
          // Update pulsing beacons/lights
          if (obj.userData && obj.userData.pulse) {
            const beaconPulse = Math.sin(dt * rhythm.pulseFrequency * 0.5 + obj.userData.pulsePhase);
            const scale = 1 + beaconPulse * 0.1 * rhythm.activityLevel;
            obj.scale.set(scale, scale, scale);
          }
          
          // Recurse into children
          if (obj.children) {
            obj.children.forEach(child => updateMesh(child));
          }
        }
        
        updateMesh(building.mesh);
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SOUND MANAGER â€” Ambient Soundscape
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    class SoundManager {
      constructor() {
        this.enabled = false;
        this.muted = false;
        this.context = null;
        this.masterGain = null;
        this.initialized = false;
        
        // Sound layers
        this.layers = {
          cityHum: null,      // Constant low drone
          wind: null,         // Altitude-based wind
          electrical: null,   // Building hum
          morning: null,      // Bird-like chirps
          night: null,        // Cricket/owl sounds
          thinking: null,     // Processing sounds
          responding: null,   // Response chime
        };
        
        // Current state
        this.currentPhase = 'day';
        this.cognitiveState = 'idle';
        this.cameraDistance = 50;
        
        // UI elements
        this.soundToggleBtn = document.getElementById('soundToggle');
        this.muteToggleBtn = document.getElementById('muteToggle');
        
        this.setupUI();
        this.setupKeyboard();
      }
      
      setupUI() {
        if (this.soundToggleBtn) {
          this.soundToggleBtn.addEventListener('click', () => this.toggle());
        }
        if (this.muteToggleBtn) {
          this.muteToggleBtn.addEventListener('click', () => this.toggleMute());
        }
      }
      
      setupKeyboard() {
        window.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 's' && !e.ctrlKey && !e.metaKey) {
            this.toggle();
          }
          if (e.key.toLowerCase() === 'm' && !e.ctrlKey && !e.metaKey) {
            this.toggleMute();
          }
        });
      }
      
      async init() {
        if (this.initialized) return;
        
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          
          // Master gain for overall volume
          this.masterGain = this.context.createGain();
          this.masterGain.gain.value = 0.3; // Start quiet
          this.masterGain.connect(this.context.destination);
          
          // Create all sound layers
          this.createCityHum();
          this.createWind();
          this.createElectrical();
          this.createMorningSounds();
          this.createNightSounds();
          this.createThinkingSound();
          this.createRespondingSound();
          
          this.initialized = true;
          console.log('[Sound] Initialized');
        } catch (err) {
          console.error('[Sound] Init failed:', err);
        }
      }
      
      // === SOUND GENERATORS (Oscillator-based, no external files) ===
      
      createCityHum() {
        // Low frequency drone - the heartbeat of the city
        const osc1 = this.context.createOscillator();
        const osc2 = this.context.createOscillator();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc1.type = 'sine';
        osc1.frequency.value = 55; // Low A
        osc2.type = 'sine';
        osc2.frequency.value = 82.5; // Harmonic
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        gain.gain.value = 0;
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc1.start();
        osc2.start();
        
        this.layers.cityHum = { oscillators: [osc1, osc2], gain, filter };
      }
      
      createWind() {
        // White noise with bandpass for wind effect
        const bufferSize = 2 * this.context.sampleRate;
        const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.context.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.loop = true;
        
        const filter = this.context.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 0.5;
        
        const gain = this.context.createGain();
        gain.gain.value = 0;
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start();
        
        this.layers.wind = { source: noise, gain, filter };
      }
      
      createElectrical() {
        // High-frequency hum with slight modulation
        const osc = this.context.createOscillator();
        const modulator = this.context.createOscillator();
        const modulatorGain = this.context.createGain();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = 120; // Electrical hum frequency
        
        modulator.type = 'sine';
        modulator.frequency.value = 0.5; // Slow wobble
        modulatorGain.gain.value = 5;
        
        modulator.connect(modulatorGain);
        modulatorGain.connect(osc.frequency);
        
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        
        gain.gain.value = 0;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        modulator.start();
        
        this.layers.electrical = { oscillators: [osc, modulator], gain, filter };
      }
      
      createMorningSounds() {
        // Bird-like chirps using FM synthesis
        const gain = this.context.createGain();
        gain.gain.value = 0;
        gain.connect(this.masterGain);
        
        this.layers.morning = { 
          gain,
          lastChirp: 0,
          active: false
        };
      }
      
      playChirp() {
        if (!this.enabled || this.muted || !this.layers.morning?.active) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const modulator = this.context.createOscillator();
        const modGain = this.context.createGain();
        const env = this.context.createGain();
        
        // Random bird-like frequency
        const baseFreq = 1200 + Math.random() * 800;
        osc.type = 'sine';
        osc.frequency.value = baseFreq;
        
        modulator.type = 'sine';
        modulator.frequency.value = 20 + Math.random() * 30;
        modGain.gain.value = baseFreq * 0.3;
        
        modulator.connect(modGain);
        modGain.connect(osc.frequency);
        
        // Quick attack, medium decay
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.15, now + 0.02);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        osc.connect(env);
        env.connect(this.layers.morning.gain);
        
        osc.start(now);
        modulator.start(now);
        osc.stop(now + 0.2);
        modulator.stop(now + 0.2);
      }
      
      createNightSounds() {
        // Cricket-like chirps and occasional owl hoot
        const gain = this.context.createGain();
        gain.gain.value = 0;
        gain.connect(this.masterGain);
        
        this.layers.night = {
          gain,
          lastCricket: 0,
          active: false
        };
      }
      
      playCricket() {
        if (!this.enabled || this.muted || !this.layers.night?.active) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const env = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = 4000 + Math.random() * 1000;
        
        // Rapid on-off pattern
        const duration = 0.3 + Math.random() * 0.2;
        const pulses = 3 + Math.floor(Math.random() * 4);
        const pulseLength = duration / (pulses * 2);
        
        env.gain.setValueAtTime(0, now);
        for (let i = 0; i < pulses; i++) {
          const t = now + i * pulseLength * 2;
          env.gain.setValueAtTime(0.08, t);
          env.gain.setValueAtTime(0, t + pulseLength * 0.8);
        }
        
        osc.connect(env);
        env.connect(this.layers.night.gain);
        
        osc.start(now);
        osc.stop(now + duration);
      }
      
      createThinkingSound() {
        // Electronic processing hum - pulsing, digital feel
        const osc1 = this.context.createOscillator();
        const osc2 = this.context.createOscillator();
        const lfo = this.context.createOscillator();
        const lfoGain = this.context.createGain();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc1.type = 'triangle';
        osc1.frequency.value = 220;
        
        osc2.type = 'sine';
        osc2.frequency.value = 330;
        
        lfo.type = 'sine';
        lfo.frequency.value = 4; // Pulsing rhythm
        lfoGain.gain.value = 0.3;
        
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);
        
        filter.type = 'bandpass';
        filter.frequency.value = 600;
        filter.Q.value = 2;
        
        gain.gain.value = 0;
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc1.start();
        osc2.start();
        lfo.start();
        
        this.layers.thinking = { oscillators: [osc1, osc2, lfo], gain, filter };
      }
      
      createRespondingSound() {
        // Soft chime/pulse when responding
        const gain = this.context.createGain();
        gain.gain.value = 0;
        gain.connect(this.masterGain);
        
        this.layers.responding = { gain, active: false };
      }
      
      playResponseChime() {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        const frequencies = [523, 659, 784]; // C, E, G chord
        
        frequencies.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const env = this.context.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          const delay = i * 0.05;
          env.gain.setValueAtTime(0, now + delay);
          env.gain.linearRampToValueAtTime(0.12, now + delay + 0.05);
          env.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.8);
          
          osc.connect(env);
          env.connect(this.layers.responding.gain);
          
          osc.start(now + delay);
          osc.stop(now + delay + 1);
        });
      }
      
      // === STATE CONTROL ===
      
      async toggle() {
        if (!this.enabled) {
          await this.init();
          this.enable();
        } else {
          this.disable();
        }
      }
      
      enable() {
        if (!this.initialized) return;
        
        this.enabled = true;
        
        // Resume context if suspended (required for mobile)
        if (this.context.state === 'suspended') {
          this.context.resume();
        }
        
        // Fade in base layers
        this.fadeLayer('cityHum', 0.12, 2);
        
        this.updateUI();
        console.log('[Sound] Enabled');
      }
      
      disable() {
        this.enabled = false;
        
        // Fade out all layers
        Object.keys(this.layers).forEach(key => {
          this.fadeLayer(key, 0, 0.5);
        });
        
        this.updateUI();
        console.log('[Sound] Disabled');
      }
      
      toggleMute() {
        if (!this.enabled) return;
        
        this.muted = !this.muted;
        
        if (this.muted) {
          this.masterGain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);
        } else {
          this.masterGain.gain.linearRampToValueAtTime(0.3, this.context.currentTime + 0.1);
        }
        
        this.updateUI();
        console.log('[Sound] Muted:', this.muted);
      }
      
      updateUI() {
        if (this.soundToggleBtn) {
          this.soundToggleBtn.textContent = this.enabled ? 'ğŸ”Š On' : 'ğŸ”‡ Off';
          this.soundToggleBtn.classList.toggle('active', this.enabled);
        }
        if (this.muteToggleBtn) {
          this.muteToggleBtn.style.display = this.enabled ? 'block' : 'none';
          this.muteToggleBtn.textContent = this.muted ? 'ğŸ”‡' : 'ğŸ”Š';
          this.muteToggleBtn.classList.toggle('muted', this.muted);
        }
      }
      
      fadeLayer(layerName, targetVolume, duration = 1) {
        const layer = this.layers[layerName];
        if (!layer || !layer.gain) return;
        
        const now = this.context.currentTime;
        layer.gain.gain.linearRampToValueAtTime(targetVolume, now + duration);
      }
      
      // === REACTIVE UPDATES ===
      
      updateTimePhase(hours, nightIntensity) {
        if (!this.enabled || !this.initialized) return;
        
        let newPhase = 'day';
        if (hours >= 5 && hours < 8) newPhase = 'morning';
        else if (hours >= 8 && hours < 18) newPhase = 'day';
        else if (hours >= 18 && hours < 21) newPhase = 'evening';
        else newPhase = 'night';
        
        if (newPhase !== this.currentPhase) {
          this.currentPhase = newPhase;
          this.transitionToPhase(newPhase, nightIntensity);
        }
        
        // Continuous adjustments
        this.updateContinuousLayers(nightIntensity);
        
        // Trigger occasional sounds
        this.triggerPhaseSounds(newPhase);
      }
      
      transitionToPhase(phase, nightIntensity) {
        const fadeTime = 3;
        
        // Base city hum - always present, louder during day
        const humVolume = phase === 'night' ? 0.06 : 0.12;
        this.fadeLayer('cityHum', humVolume, fadeTime);
        
        // Morning sounds (birds)
        if (this.layers.morning) {
          this.layers.morning.active = (phase === 'morning');
          this.fadeLayer('morning', phase === 'morning' ? 0.4 : 0, fadeTime);
        }
        
        // Night sounds (crickets)
        if (this.layers.night) {
          this.layers.night.active = (phase === 'night');
          this.fadeLayer('night', phase === 'night' ? 0.3 : 0, fadeTime);
        }
        
        // Electrical hum - more noticeable at night
        const elecVolume = phase === 'night' ? 0.08 : 0.03;
        this.fadeLayer('electrical', elecVolume, fadeTime);
        
        console.log('[Sound] Phase:', phase);
      }
      
      updateContinuousLayers(nightIntensity) {
        if (!this.layers.cityHum) return;
        
        // Modulate city hum pitch slightly based on time
        const basePitch = 55 + nightIntensity * 10;
        if (this.layers.cityHum.oscillators) {
          this.layers.cityHum.oscillators[0].frequency.value = basePitch;
          this.layers.cityHum.oscillators[1].frequency.value = basePitch * 1.5;
        }
      }
      
      triggerPhaseSounds(phase) {
        const now = Date.now();
        
        // Morning bird chirps
        if (phase === 'morning' && this.layers.morning?.active) {
          if (now - this.layers.morning.lastChirp > 2000 + Math.random() * 5000) {
            this.playChirp();
            // Sometimes double chirp
            if (Math.random() > 0.6) {
              setTimeout(() => this.playChirp(), 100 + Math.random() * 200);
            }
            this.layers.morning.lastChirp = now;
          }
        }
        
        // Night crickets
        if (phase === 'night' && this.layers.night?.active) {
          if (now - this.layers.night.lastCricket > 1500 + Math.random() * 3000) {
            this.playCricket();
            this.layers.night.lastCricket = now;
          }
        }
      }
      
      updateCameraDistance(distance) {
        if (!this.enabled || !this.initialized) return;
        
        this.cameraDistance = distance;
        
        // Wind increases with altitude/distance
        const windVolume = Math.min(0.15, (distance - 20) / 200);
        this.fadeLayer('wind', Math.max(0, windVolume), 0.5);
        
        // City hum decreases with distance
        const humVolume = Math.max(0.03, 0.12 - (distance - 30) / 300);
        if (this.currentPhase === 'night') {
          this.fadeLayer('cityHum', humVolume * 0.5, 0.5);
        } else {
          this.fadeLayer('cityHum', humVolume, 0.5);
        }
      }
      
      updateCognitiveState(state, message = '') {
        if (!this.enabled || !this.initialized) return;
        
        const prevState = this.cognitiveState;
        this.cognitiveState = state;
        
        if (state === 'thinking' && prevState !== 'thinking') {
          // Start thinking sound
          this.fadeLayer('thinking', 0.08, 0.5);
        } else if (state !== 'thinking' && prevState === 'thinking') {
          // Stop thinking sound
          this.fadeLayer('thinking', 0, 0.5);
        }
        
        if (state === 'responding' && prevState !== 'responding') {
          this.playResponseChime();
        }
      }
      
      // Interactive sounds
      playZoomSound(zoomingIn) {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const env = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(zoomingIn ? 300 : 500, now);
        osc.frequency.exponentialRampToValueAtTime(zoomingIn ? 500 : 300, now + 0.15);
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.05, now + 0.02);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.connect(env);
        env.connect(this.masterGain);
        
        osc.start(now);
        osc.stop(now + 0.25);
      }
      
      playDistrictActivation(districtName) {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        
        // Whoosh + tonal element
        const noise = this.context.createBufferSource();
        const noiseBuffer = this.context.createBuffer(1, this.context.sampleRate * 0.5, this.context.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        const noiseFilter = this.context.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.setValueAtTime(200, now);
        noiseFilter.frequency.exponentialRampToValueAtTime(2000, now + 0.15);
        noiseFilter.frequency.exponentialRampToValueAtTime(500, now + 0.4);
        noiseFilter.Q.value = 1;
        
        const noiseEnv = this.context.createGain();
        noiseEnv.gain.setValueAtTime(0, now);
        noiseEnv.gain.linearRampToValueAtTime(0.08, now + 0.05);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseEnv);
        noiseEnv.connect(this.masterGain);
        
        noise.start(now);
        
        console.log('[Sound] District activation:', districtName);
      }
      
      playInfoPing() {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const env = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = 880;
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.1, now + 0.01);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.connect(env);
        env.connect(this.masterGain);
        
        osc.start(now);
        osc.stop(now + 0.35);
      }
    }
    
    // Initialize sound manager (sounds OFF by default)
    const soundManager = new SoundManager();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SKY DOME WITH DYNAMIC GRADIENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createSkyDome() {
      // Sky dome shader for beautiful time-based gradients
      const skyVertexShader = `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      
      const skyFragmentShader = `
        uniform vec3 topColor;
        uniform vec3 middleColor;
        uniform vec3 horizonColor;
        uniform vec3 horizonGlow;
        uniform float horizonSharpness;
        uniform float glowIntensity;
        uniform float sunY;
        varying vec3 vWorldPosition;
        
        void main() {
          float height = normalize(vWorldPosition).y;
          float heightClamped = max(0.0, height);
          
          // Three-zone gradient: horizon -> middle -> top
          vec3 color;
          if (heightClamped < 0.3) {
            // Horizon to middle
            float t = heightClamped / 0.3;
            t = smoothstep(0.0, 1.0, t);
            color = mix(horizonColor, middleColor, t);
            // Add horizon glow (concentrated at very bottom)
            float glowFactor = (1.0 - t) * (1.0 - t) * glowIntensity;
            color = mix(color, horizonGlow, glowFactor);
          } else {
            // Middle to top
            float t = (heightClamped - 0.3) / 0.7;
            t = smoothstep(0.0, 1.0, t);
            color = mix(middleColor, topColor, t);
          }
          
          // Add subtle atmospheric scattering near horizon
          float scatter = exp(-heightClamped * horizonSharpness) * 0.15;
          color += horizonGlow * scatter;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      
      const skyUniforms = {
        topColor: { value: new THREE.Color(0x0a0a20) },
        middleColor: { value: new THREE.Color(0x1a1a40) },
        horizonColor: { value: new THREE.Color(0x2a2a50) },
        horizonGlow: { value: new THREE.Color(0x4a3060) },
        horizonSharpness: { value: 3.0 },
        glowIntensity: { value: 0.3 },
        sunY: { value: 0.0 }
      };
      
      const skyGeo = new THREE.SphereGeometry(450, 32, 24);
      const skyMat = new THREE.ShaderMaterial({
        vertexShader: skyVertexShader,
        fragmentShader: skyFragmentShader,
        uniforms: skyUniforms,
        side: THREE.BackSide,
        depthWrite: false
      });
      
      city.skyDome = new THREE.Mesh(skyGeo, skyMat);
      city.skyUniforms = skyUniforms;
      scene.add(city.skyDome);
      
      // Disable default background
      scene.background = null;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SUN & MOON CELESTIAL BODIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createCelestialBodies() {
      // === SUN ===
      const sunGroup = new THREE.Group();
      
      // Sun core (bright center)
      const sunCoreGeo = new THREE.SphereGeometry(8, 24, 24);
      const sunCoreMat = new THREE.MeshBasicMaterial({
        color: 0xffffcc,
        transparent: true,
        opacity: 1.0
      });
      const sunCore = new THREE.Mesh(sunCoreGeo, sunCoreMat);
      sunGroup.add(sunCore);
      
      // Sun glow layer 1 (inner glow)
      const sunGlow1Geo = new THREE.SphereGeometry(12, 24, 24);
      const sunGlow1Mat = new THREE.MeshBasicMaterial({
        color: 0xffdd88,
        transparent: true,
        opacity: 0.4
      });
      const sunGlow1 = new THREE.Mesh(sunGlow1Geo, sunGlow1Mat);
      sunGroup.add(sunGlow1);
      
      // Sun glow layer 2 (outer glow)
      const sunGlow2Geo = new THREE.SphereGeometry(18, 24, 24);
      const sunGlow2Mat = new THREE.MeshBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.2
      });
      const sunGlow2 = new THREE.Mesh(sunGlow2Geo, sunGlow2Mat);
      sunGroup.add(sunGlow2);
      
      // Sun corona (large faint glow)
      const coronaGeo = new THREE.SphereGeometry(30, 16, 16);
      const coronaMat = new THREE.MeshBasicMaterial({
        color: 0xff8844,
        transparent: true,
        opacity: 0.1
      });
      const corona = new THREE.Mesh(coronaGeo, coronaMat);
      sunGroup.add(corona);
      
      city.sun = sunGroup;
      city.sunCore = sunCore;
      city.sunGlows = [sunGlow1, sunGlow2, corona];
      scene.add(sunGroup);
      
      // === MOON ===
      const moonGroup = new THREE.Group();
      
      // Moon surface
      const moonGeo = new THREE.SphereGeometry(5, 24, 24);
      const moonMat = new THREE.MeshBasicMaterial({
        color: 0xddeeff,
        transparent: true,
        opacity: 0.95
      });
      const moon = new THREE.Mesh(moonGeo, moonMat);
      moonGroup.add(moon);
      
      // Moon glow
      const moonGlowGeo = new THREE.SphereGeometry(8, 16, 16);
      const moonGlowMat = new THREE.MeshBasicMaterial({
        color: 0x8899bb,
        transparent: true,
        opacity: 0.25
      });
      const moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
      moonGroup.add(moonGlow);
      
      // Outer moon halo
      const moonHaloGeo = new THREE.SphereGeometry(12, 16, 16);
      const moonHaloMat = new THREE.MeshBasicMaterial({
        color: 0x6677aa,
        transparent: true,
        opacity: 0.1
      });
      const moonHalo = new THREE.Mesh(moonHaloGeo, moonHaloMat);
      moonGroup.add(moonHalo);
      
      city.moon = moonGroup;
      city.moonCore = moon;
      city.moonGlows = [moonGlow, moonHalo];
      scene.add(moonGroup);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STARFIELD SKYBOX
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createStarfield() {
      const starCount = isMobile ? 1000 : 3000;
      const starGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        // Distribute on a large sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 380 + Math.random() * 40;
        
        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = Math.abs(radius * Math.cos(phi)); // Only upper hemisphere
        positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        
        // Slight color variation (warm to cool white)
        const temp = 0.8 + Math.random() * 0.4;
        colors[i * 3] = temp;
        colors[i * 3 + 1] = temp * 0.95;
        colors[i * 3 + 2] = temp * (0.8 + Math.random() * 0.2);
        
        sizes[i] = 0.5 + Math.random() * 1.5;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      const starMaterial = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0,
        sizeAttenuation: false,
      });
      
      city.stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(city.stars);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HEX GRID GROUND WITH GLOWING ROADS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createGround() {
      // Dark base plane
      const groundGeo = new THREE.PlaneGeometry(250, 250);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x050510,
        roughness: 0.95,
        metalness: 0.1,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Hex grid
      createHexGrid();
      
      // Glowing road network
      createRoadNetwork();
    }
    
    function createHexGrid() {
      const hexRadius = 3;
      const hexHeight = hexRadius * Math.sqrt(3);
      const gridSize = 15;
      
      const hexShape = new THREE.Shape();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
        const x = Math.cos(angle) * hexRadius * 0.95;
        const y = Math.sin(angle) * hexRadius * 0.95;
        if (i === 0) hexShape.moveTo(x, y);
        else hexShape.lineTo(x, y);
      }
      hexShape.closePath();
      
      const hexLineGeo = new THREE.EdgesGeometry(new THREE.ShapeGeometry(hexShape));
      const hexLineMat = new THREE.LineBasicMaterial({
        color: 0x1a2a3a,
        transparent: true,
        opacity: 0.4,
      });
      
      // Instanced hex outlines
      for (let q = -gridSize; q <= gridSize; q++) {
        for (let r = -gridSize; r <= gridSize; r++) {
          if (Math.abs(q + r) > gridSize) continue;
          
          const x = hexRadius * 1.5 * q;
          const z = hexHeight * (r + q / 2);
          
          // Skip center area for core
          if (Math.abs(x) < 8 && Math.abs(z) < 8) continue;
          
          const hexLine = new THREE.LineSegments(hexLineGeo, hexLineMat);
          hexLine.rotation.x = -Math.PI / 2;
          hexLine.position.set(x, 0.05, z);
          scene.add(hexLine);
        }
      }
    }
    
    function createRoadNetwork() {
      const roadMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.15,
      });
      
      const roadGlowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.6,
      });
      
      // Main roads connecting districts
      const districtPositions = Object.values(DISTRICTS).map(d => d.position);
      
      districtPositions.forEach((pos, i) => {
        // Road to center
        createRoadSegment(pos.x, pos.z, 0, 0, roadMaterial, roadGlowMaterial);
        
        // Connect to next district
        const next = districtPositions[(i + 1) % districtPositions.length];
        createRoadSegment(pos.x, pos.z, next.x, next.z, roadMaterial, roadGlowMaterial);
      });
    }
    
    function createRoadSegment(x1, z1, x2, z2, baseMat, glowMat) {
      const length = Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);
      const angle = Math.atan2(z2 - z1, x2 - x1);
      
      // Base road
      const roadGeo = new THREE.PlaneGeometry(length, 1.5);
      const road = new THREE.Mesh(roadGeo, baseMat);
      road.rotation.x = -Math.PI / 2;
      road.rotation.z = -angle;
      road.position.set((x1 + x2) / 2, 0.06, (z1 + z2) / 2);
      scene.add(road);
      
      // Center glow line
      const lineGeo = new THREE.PlaneGeometry(length, 0.15);
      const line = new THREE.Mesh(lineGeo, glowMat);
      line.rotation.x = -Math.PI / 2;
      line.rotation.z = -angle;
      line.position.set((x1 + x2) / 2, 0.08, (z1 + z2) / 2);
      scene.add(line);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENVIRONMENT â€” Island, Clouds, Horizon
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createEnvironment() {
      // Floating island platform with glowing edge
      const islandRadius = 140;
      const islandGeo = new THREE.CylinderGeometry(islandRadius, islandRadius * 0.85, 8, 64);
      const islandMat = new THREE.MeshStandardMaterial({
        color: 0x0a0a15,
        roughness: 0.9,
        metalness: 0.2,
      });
      const island = new THREE.Mesh(islandGeo, islandMat);
      island.position.y = -4;
      island.receiveShadow = true;
      scene.add(island);
      
      // Glowing edge ring
      const edgeGeo = new THREE.TorusGeometry(islandRadius * 0.92, 0.5, 8, 128);
      const edgeMat = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.4,
      });
      const edge = new THREE.Mesh(edgeGeo, edgeMat);
      edge.rotation.x = Math.PI / 2;
      edge.position.y = -0.5;
      scene.add(edge);
      city.islandEdge = edge;
      
      // Second inner edge
      const edge2Geo = new THREE.TorusGeometry(islandRadius * 0.7, 0.3, 8, 96);
      const edge2 = new THREE.Mesh(edge2Geo, edgeMat.clone());
      edge2.material.opacity = 0.2;
      edge2.rotation.x = Math.PI / 2;
      edge2.position.y = -0.3;
      scene.add(edge2);
      
      // Cloud layer below
      createCloudLayer();
      
      // Horizon glow ring
      createHorizonGlow();
      
      // Distant floating rocks
      createFloatingRocks();
    }
    
    function createCloudLayer() {
      const cloudCount = isMobile ? 30 : 60;
      city.clouds = [];
      
      for (let i = 0; i < cloudCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 80 + Math.random() * 200;
        const size = 15 + Math.random() * 40;
        
        const cloudGeo = new THREE.SphereGeometry(size, 8, 6);
        const cloudMat = new THREE.MeshBasicMaterial({
          color: 0x334455,
          transparent: true,
          opacity: 0.15 + Math.random() * 0.15,
        });
        
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        cloud.position.set(
          Math.cos(angle) * radius,
          -20 - Math.random() * 60,
          Math.sin(angle) * radius
        );
        cloud.scale.set(1, 0.3, 1); // Flatten
        cloud.userData.angle = angle;
        cloud.userData.radius = radius;
        cloud.userData.speed = 0.0001 + Math.random() * 0.0002;
        cloud.userData.baseY = cloud.position.y;
        
        scene.add(cloud);
        city.clouds.push(cloud);
      }
    }
    
    function createHorizonGlow() {
      // Large glowing ring at horizon
      const horizonGeo = new THREE.TorusGeometry(300, 2, 8, 128);
      const horizonMat = new THREE.MeshBasicMaterial({
        color: 0x003355,
        transparent: true,
        opacity: 0.3,
      });
      const horizon = new THREE.Mesh(horizonGeo, horizonMat);
      horizon.rotation.x = Math.PI / 2;
      horizon.position.y = -10;
      scene.add(horizon);
      city.horizonRing = horizon;
      
      // Fog plane at horizon
      const fogGeo = new THREE.RingGeometry(150, 400, 64);
      const fogMat = new THREE.MeshBasicMaterial({
        color: 0x0a1525,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
      });
      const fog = new THREE.Mesh(fogGeo, fogMat);
      fog.rotation.x = -Math.PI / 2;
      fog.position.y = -15;
      scene.add(fog);
    }
    
    function createFloatingRocks() {
      const rockCount = isMobile ? 8 : 15;
      city.floatingRocks = [];
      
      for (let i = 0; i < rockCount; i++) {
        const angle = (i / rockCount) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 180 + Math.random() * 100;
        const size = 3 + Math.random() * 8;
        
        const rockGeo = new THREE.DodecahedronGeometry(size, 0);
        const rockMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a2a,
          roughness: 0.9,
          metalness: 0.1,
          emissive: 0x001122,
          emissiveIntensity: 0.3,
        });
        
        const rock = new THREE.Mesh(rockGeo, rockMat);
        rock.position.set(
          Math.cos(angle) * radius,
          -5 + Math.random() * 30,
          Math.sin(angle) * radius
        );
        rock.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        rock.userData.baseY = rock.position.y;
        rock.userData.floatSpeed = 0.5 + Math.random() * 0.5;
        rock.userData.floatPhase = Math.random() * Math.PI * 2;
        
        scene.add(rock);
        city.floatingRocks.push(rock);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CINEMATIC LIGHTING SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let sunLight, moonLight, ambientLight, hemiLight;
    
    // Lighting state for smooth transitions
    const lighting = {
      targetSunColor: new THREE.Color(),
      targetAmbientColor: new THREE.Color(),
      targetFogColor: new THREE.Color(),
      currentSunColor: new THREE.Color(0xffeedd),
      currentAmbientColor: new THREE.Color(0x111122),
      currentFogColor: new THREE.Color(0x0a0a15),
      goldenHourIntensity: 0,
      rimLightIntensity: 0,
      windowLightProgress: 0, // 0 = day, 1 = fully lit windows
    };
    
    // Color presets for different times of day
    const LIGHT_PRESETS = {
      dawn: {
        sun: new THREE.Color(0xff6633), // Deep orange-red
        ambient: new THREE.Color(0x332244), // Purple-blue
        fog: new THREE.Color(0x1a1525),
        skyHue: 0.05, skySat: 0.7, skyLight: 0.08,
      },
      sunrise: {
        sun: new THREE.Color(0xffaa55), // Warm orange
        ambient: new THREE.Color(0x443322), // Warm brown
        fog: new THREE.Color(0x2a1a15),
        skyHue: 0.08, skySat: 0.6, skyLight: 0.15,
      },
      morning: {
        sun: new THREE.Color(0xffeebb), // Warm white
        ambient: new THREE.Color(0x556677), // Brighter ambient
        fog: new THREE.Color(0x354050),
        skyHue: 0.58, skySat: 0.5, skyLight: 0.45,
      },
      noon: {
        sun: new THREE.Color(0xffffff), // Neutral white
        ambient: new THREE.Color(0x667788), // Bright blue ambient
        fog: new THREE.Color(0x405060),
        skyHue: 0.58, skySat: 0.5, skyLight: 0.55,
      },
      afternoon: {
        sun: new THREE.Color(0xfff5e0), // Slightly warm
        ambient: new THREE.Color(0x556677), // Neutral bright
        fog: new THREE.Color(0x354555),
        skyHue: 0.56, skySat: 0.5, skyLight: 0.4,
      },
      goldenHour: {
        sun: new THREE.Color(0xffcc66), // Golden
        ambient: new THREE.Color(0x553322), // Warm
        fog: new THREE.Color(0x251a10),
        skyHue: 0.07, skySat: 0.65, skyLight: 0.12,
      },
      sunset: {
        sun: new THREE.Color(0xff7744), // Deep orange
        ambient: new THREE.Color(0x442233), // Purple warm
        fog: new THREE.Color(0x201515),
        skyHue: 0.02, skySat: 0.7, skyLight: 0.08,
      },
      dusk: {
        sun: new THREE.Color(0x663355), // Purple
        ambient: new THREE.Color(0x221133), // Deep purple
        fog: new THREE.Color(0x0f0a15),
        skyHue: 0.75, skySat: 0.6, skyLight: 0.04,
      },
      night: {
        sun: new THREE.Color(0x000000), // Off
        ambient: new THREE.Color(0x0a1525), // Cool blue
        fog: new THREE.Color(0x050810),
        skyHue: 0.65, skySat: 0.7, skyLight: 0.01,
      },
    };
    
    function createLighting() {
      // Main sun light with shadows
      sunLight = new THREE.DirectionalLight(0xffeedd, 1);
      if (!isMobile) {
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -60;
        sunLight.shadow.camera.right = 60;
        sunLight.shadow.camera.top = 60;
        sunLight.shadow.camera.bottom = -60;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.normalBias = 0.02;
      }
      scene.add(sunLight);
      
      // Moon light - cooler, softer
      moonLight = new THREE.DirectionalLight(0x3355aa, 0.3);
      moonLight.position.set(30, 50, -40);
      scene.add(moonLight);
      
      // Ambient light - fills shadows
      ambientLight = new THREE.AmbientLight(0x111122, 0.5);
      scene.add(ambientLight);
      
      // Hemisphere light - sky/ground color influence
      hemiLight = new THREE.HemisphereLight(0x2244aa, 0x221100, 0.2);
      scene.add(hemiLight);
    }
    
    // Smooth interpolation helper
    function smoothstep(x) {
      return x * x * (3 - 2 * x);
    }
    
    // Get lighting preset blend based on hour
    function getLightingBlend(hours) {
      // Define time ranges for each phase
      const phases = [
        { start: 0, end: 5, preset: 'night' },
        { start: 5, end: 6, preset: 'dawn', nextPreset: 'sunrise' },
        { start: 6, end: 7.5, preset: 'sunrise', nextPreset: 'morning' },
        { start: 7.5, end: 11, preset: 'morning', nextPreset: 'noon' },
        { start: 11, end: 14, preset: 'noon' },
        { start: 14, end: 17, preset: 'afternoon', nextPreset: 'goldenHour' },
        { start: 17, end: 18.5, preset: 'goldenHour', nextPreset: 'sunset' },
        { start: 18.5, end: 20, preset: 'sunset', nextPreset: 'dusk' },
        { start: 20, end: 21.5, preset: 'dusk', nextPreset: 'night' },
        { start: 21.5, end: 24, preset: 'night' },
      ];
      
      for (const phase of phases) {
        if (hours >= phase.start && hours < phase.end) {
          if (phase.nextPreset) {
            const t = (hours - phase.start) / (phase.end - phase.start);
            return { from: phase.preset, to: phase.nextPreset, blend: smoothstep(t) };
          }
          return { from: phase.preset, to: phase.preset, blend: 0 };
        }
      }
      return { from: 'night', to: 'night', blend: 0 };
    }
    
    // Blend two colors
    function blendColors(color1, color2, t) {
      const result = new THREE.Color();
      result.r = color1.r + (color2.r - color1.r) * t;
      result.g = color1.g + (color2.g - color1.g) * t;
      result.b = color1.b + (color2.b - color1.b) * t;
      return result;
    }
    
    function updateLighting() {
      const now = new Date();
      const hours = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
      
      timeDisplayEl.textContent = now.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
      
      // Calculate sun position (rises at 6, sets at 18)
      const sunAngle = ((hours - 6) / 24) * Math.PI * 2;
      const sunHeight = Math.sin(sunAngle);
      const sunAzimuth = Math.cos(sunAngle);
      
      // Sun position in world space
      const sunDistance = 80;
      const sunX = sunAzimuth * sunDistance * 0.8;
      const sunY = Math.max(sunHeight * sunDistance, -30);
      const sunZ = 40;
      sunLight.position.set(sunX, sunY, sunZ);
      
      // Moon opposite to sun, slightly offset
      moonLight.position.set(-sunX * 0.8, -sunY + 60, -sunZ * 0.7);
      
      // Get current lighting preset blend
      const { from, to, blend } = getLightingBlend(hours);
      const fromPreset = LIGHT_PRESETS[from];
      const toPreset = LIGHT_PRESETS[to];
      
      // Blend target colors
      lighting.targetSunColor = blendColors(fromPreset.sun, toPreset.sun, blend);
      lighting.targetAmbientColor = blendColors(fromPreset.ambient, toPreset.ambient, blend);
      lighting.targetFogColor = blendColors(fromPreset.fog, toPreset.fog, blend);
      
      // Smooth transition (lerp current toward target)
      const colorLerpSpeed = 0.02;
      lighting.currentSunColor.lerp(lighting.targetSunColor, colorLerpSpeed);
      lighting.currentAmbientColor.lerp(lighting.targetAmbientColor, colorLerpSpeed);
      lighting.currentFogColor.lerp(lighting.targetFogColor, colorLerpSpeed);
      
      // Apply colors to lights
      sunLight.color.copy(lighting.currentSunColor);
      ambientLight.color.copy(lighting.currentAmbientColor);
      
      // Calculate intensities
      const dayProgress = Math.max(0, sunHeight); // 0 at horizon, 1 at noon
      const horizonFactor = Math.abs(sunHeight); // Low at horizon
      
      // Sun intensity: parabolic curve, brightest at noon
      const sunIntensityBase = Math.pow(dayProgress, 0.6); // Softer falloff
      sunLight.intensity = sunIntensityBase * 2.0;
      
      // Night intensity for other systems
      city.nightIntensity = Math.max(0, -sunHeight);
      const twilightIntensity = (1 - Math.abs(sunHeight)) * (sunHeight < 0.3 ? 1 : 0);
      
      // Moon intensity - stronger when sun is down
      moonLight.intensity = city.nightIntensity * 0.5;
      moonLight.color.setHSL(0.6, 0.5, 0.5 + city.nightIntensity * 0.2);
      
      // Ambient intensity - never fully dark
      ambientLight.intensity = 0.4 + dayProgress * 0.5 + city.nightIntensity * 0.1;
      
      // Hemisphere light adapts to time
      const skyBlend = blend;
      const skyHue = fromPreset.skyHue + (toPreset.skyHue - fromPreset.skyHue) * skyBlend;
      const skySat = fromPreset.skySat + (toPreset.skySat - fromPreset.skySat) * skyBlend;
      const skyLight_l = fromPreset.skyLight + (toPreset.skyLight - fromPreset.skyLight) * skyBlend;
      
      hemiLight.color.setHSL(skyHue, skySat, skyLight_l + 0.1);
      hemiLight.groundColor.setHSL(0.08, 0.4, 0.02 + dayProgress * 0.03);
      hemiLight.intensity = 0.15 + dayProgress * 0.15;
      
      // Shadow softness varies with sun angle (lower sun = softer shadows)
      if (!isMobile && sunLight.shadow) {
        const shadowRadius = 1 + (1 - horizonFactor) * 3; // 1-4 range
        sunLight.shadow.radius = shadowRadius;
      }
      
      // Sky color
      scene.background = new THREE.Color().setHSL(skyHue, skySat, skyLight_l);
      
      // Fog color and density
      scene.fog.color.copy(lighting.currentFogColor);
      // Denser fog at night (mystery), lighter during day
      scene.fog.density = 0.004 + city.nightIntensity * 0.003 + twilightIntensity * 0.001;
      
      // Stars visibility - fade in during dusk, full at night
      if (city.stars) {
        const starVisibility = Math.max(0, city.nightIntensity * 1.2 - 0.1);
        city.stars.material.opacity = Math.min(0.9, starVisibility);
      }
      
      // Golden hour detection (1 hour before/after sunset/sunrise)
      const isGoldenHour = (hours >= 6 && hours <= 7.5) || (hours >= 17 && hours <= 19);
      lighting.goldenHourIntensity = isGoldenHour ? 
        (1 - Math.abs((hours > 12 ? hours - 18 : hours - 6.75)) / 1.5) : 0;
      lighting.goldenHourIntensity = Math.max(0, Math.min(1, lighting.goldenHourIntensity));
      
      // Rim lighting intensity (strong at sunrise/sunset when sun is low)
      lighting.rimLightIntensity = (sunHeight > -0.1 && sunHeight < 0.3) ? 
        (1 - Math.abs(sunHeight - 0.1) / 0.4) : 0;
      
      // Window light progress - gradual transition
      const targetWindowLight = city.nightIntensity > 0.1 ? 
        Math.min(1, (city.nightIntensity - 0.1) / 0.5) : 0;
      lighting.windowLightProgress += (targetWindowLight - lighting.windowLightProgress) * 0.01;
      
      // Bloom: stronger at night for neon pop, softer during day
      const baseBloom = isMobile ? 0.5 : 0.7;
      const nightBloom = city.nightIntensity * (isMobile ? 0.8 : 1.2);
      const goldenBloom = lighting.goldenHourIntensity * 0.3;
      bloomPass.strength = baseBloom + nightBloom + goldenBloom;
      bloomPass.threshold = 0.9 - city.nightIntensity * 0.2; // Lower threshold at night
      
      // Tone mapping exposure - brighter during day
      renderer.toneMappingExposure = 0.8 + dayProgress * 0.4 - city.nightIntensity * 0.2;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SKY DOME UPDATE - Dynamic gradient based on time of day
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.skyUniforms) {
        // Calculate sky colors based on time
        let topColor, middleColor, horizonColor, horizonGlow, glowIntensity;
        
        if (hours >= 5 && hours < 7) {
          // SUNRISE - purple â†’ orange â†’ pink
          const t = (hours - 5) / 2;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x0a0520), new THREE.Color(0x2244aa), t
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2a1050), new THREE.Color(0x5588cc), t
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x883355), new THREE.Color(0xffaa77), t
          );
          horizonGlow = new THREE.Color().lerpColors(
            new THREE.Color(0xcc6655), new THREE.Color(0xffcc99), t
          );
          glowIntensity = 0.7 - t * 0.3;
        } else if (hours >= 7 && hours < 17) {
          // DAYTIME - deep blue â†’ lighter blue
          const morningT = Math.min(1, (hours - 7) / 3);
          topColor = new THREE.Color(0x1155bb);
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x4488dd), new THREE.Color(0x3377cc), morningT
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x99ccff), new THREE.Color(0x88bbee), morningT
          );
          horizonGlow = new THREE.Color(0xaaddff);
          glowIntensity = 0.2;
        } else if (hours >= 17 && hours < 20) {
          // SUNSET - blue â†’ orange â†’ red â†’ purple
          const t = (hours - 17) / 3;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2244aa), new THREE.Color(0x1a1040), t
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x6677aa), new THREE.Color(0x552255), t
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0xffaa66), new THREE.Color(0xff5533), t
          );
          horizonGlow = new THREE.Color().lerpColors(
            new THREE.Color(0xffcc88), new THREE.Color(0xff7744), t
          );
          glowIntensity = 0.5 + t * 0.3;
        } else {
          // NIGHT - dark blue/purple
          const nightT = hours >= 20 ? Math.min(1, (hours - 20) / 2) : 1;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x0a0820), new THREE.Color(0x050510), nightT
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x151230), new THREE.Color(0x080815), nightT
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2a2040), new THREE.Color(0x101020), nightT
          );
          horizonGlow = new THREE.Color(0x1a1530);
          glowIntensity = 0.15;
        }
        
        // Apply to sky dome shader
        city.skyUniforms.topColor.value.copy(topColor);
        city.skyUniforms.middleColor.value.copy(middleColor);
        city.skyUniforms.horizonColor.value.copy(horizonColor);
        city.skyUniforms.horizonGlow.value.copy(horizonGlow);
        city.skyUniforms.glowIntensity.value = glowIntensity;
        city.skyUniforms.horizonSharpness.value = isGoldenHour ? 2.0 : 4.0;
        city.skyUniforms.sunY.value = sunHeight;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SUN MESH UPDATE - Position and visibility
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.sun) {
        const celestialRadius = 350;
        const sunMeshX = sunAzimuth * celestialRadius * 0.7;
        const sunMeshY = Math.max(sunHeight * celestialRadius * 0.8, -100);
        const sunMeshZ = 100;
        
        city.sun.position.set(sunMeshX, sunMeshY, sunMeshZ);
        
        // Larger sun at horizon (atmospheric lensing effect)
        const horizonScale = 1 + (1 - Math.abs(sunHeight)) * 0.4;
        const visibility = Math.max(0, sunHeight + 0.15);
        city.sun.scale.setScalar(horizonScale * Math.max(0.01, visibility));
        
        // Update sun colors based on time
        if (city.sunCore) {
          let sunCoreColor;
          if (hours >= 5 && hours < 7) {
            sunCoreColor = new THREE.Color(0xffaa55); // Orange sunrise
          } else if (hours >= 7 && hours < 17) {
            sunCoreColor = new THREE.Color(0xffffee); // Bright white day
          } else if (hours >= 17 && hours < 20) {
            const t = (hours - 17) / 3;
            sunCoreColor = new THREE.Color().lerpColors(
              new THREE.Color(0xffdd77), new THREE.Color(0xff5522), t
            );
          } else {
            sunCoreColor = new THREE.Color(0x000000);
          }
          city.sunCore.material.color.copy(sunCoreColor);
          city.sunCore.material.opacity = visibility;
          
          // Update glow colors too
          city.sunGlows.forEach((glow, i) => {
            glow.material.color.copy(sunCoreColor);
            glow.material.opacity = [0.4, 0.2, 0.1][i] * visibility;
          });
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MOON MESH UPDATE - Position and visibility  
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.moon) {
        const moonAngle = sunAngle + Math.PI;
        const moonHeight = Math.sin(moonAngle);
        const moonAzimuth = Math.cos(moonAngle);
        const celestialRadius = 320;
        
        const moonMeshX = moonAzimuth * celestialRadius * 0.7;
        const moonMeshY = Math.max(moonHeight * celestialRadius * 0.6, -80);
        const moonMeshZ = -80;
        
        city.moon.position.set(moonMeshX, moonMeshY, moonMeshZ);
        
        const moonVisibility = Math.max(0, moonHeight + 0.1);
        city.moon.scale.setScalar(Math.max(0.01, moonVisibility));
        
        if (city.moonCore) {
          city.moonCore.material.opacity = moonVisibility * 0.95;
          city.moonGlows.forEach((glow, i) => {
            glow.material.opacity = [0.25, 0.1][i] * moonVisibility;
          });
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CLOUD COLOR UPDATE - Based on time of day
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.clouds) {
        let cloudColor;
        if (hours >= 5 && hours < 7) {
          // Sunrise - pink/orange clouds
          const t = (hours - 5) / 2;
          cloudColor = new THREE.Color().lerpColors(
            new THREE.Color(0x332233), new THREE.Color(0xff8866), t
          );
        } else if (hours >= 7 && hours < 17) {
          // Day - white/light gray
          cloudColor = new THREE.Color(0xccddee);
        } else if (hours >= 17 && hours < 20) {
          // Sunset - dramatic oranges/pinks
          const t = (hours - 17) / 3;
          cloudColor = new THREE.Color().lerpColors(
            new THREE.Color(0xffaa77), new THREE.Color(0xff6644), t
          );
        } else {
          // Night - dark
          cloudColor = new THREE.Color(0x1a1a25);
        }
        
        city.clouds.forEach(cloud => {
          cloud.material.color.copy(cloudColor);
          // Vary opacity
          const baseOpacity = 0.12;
          const goldenBoost = isGoldenHour ? 0.15 : 0;
          cloud.material.opacity = baseOpacity + goldenBoost - city.nightIntensity * 0.04;
        });
      }
      
      // Disable scene.background since we have sky dome
      scene.background = null;
      
      // Cycle phase display
      let phase = 'night';
      if (hours >= 5 && hours < 6) phase = 'dawn';
      else if (hours >= 6 && hours < 7.5) phase = 'sunrise';
      else if (hours >= 7.5 && hours < 11) phase = 'morning';
      else if (hours >= 11 && hours < 14) phase = 'noon';
      else if (hours >= 14 && hours < 17) phase = 'afternoon';
      else if (hours >= 17 && hours < 18.5) phase = 'golden hour';
      else if (hours >= 18.5 && hours < 20) phase = 'sunset';
      else if (hours >= 20 && hours < 21.5) phase = 'dusk';
      cyclePhaseEl.textContent = phase;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ARCHITECTURAL BUILDING STYLES - Defines building appearance by function
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const BUILDING_STYLES = {
      office: {
        windowDensity: 0.85,        // Many windows
        windowSize: 0.7,            // Larger windows (glass curtain wall)
        windowSpacing: 1.2,         // Tight grid
        glassReflectivity: 0.7,     // Reflective glass
        colorTint: 0x4488cc,        // Blue tint
        hasSetbacks: true,          // Tall ones step back
        crownStyle: 'flat',         // Flat or antenna tops
        baseStyle: 'lobby',         // Glass lobby entrance
      },
      residential: {
        windowDensity: 0.6,
        windowSize: 0.4,            // Smaller windows
        windowSpacing: 1.8,         // More spacing
        glassReflectivity: 0.3,
        colorTint: 0xddaa77,        // Warm brown/beige
        hasSetbacks: false,
        crownStyle: 'cornice',      // Decorative top edge
        baseStyle: 'brick',
      },
      industrial: {
        windowDensity: 0.25,        // Few windows
        windowSize: 0.5,
        windowSpacing: 3.0,         // Sparse
        glassReflectivity: 0.2,
        colorTint: 0x556677,        // Gray/metallic
        hasSetbacks: false,
        crownStyle: 'utilitarian',  // Pipes, vents
        baseStyle: 'loading',       // Loading dock
      },
      landmark: {
        windowDensity: 0.5,
        windowSize: 0.6,
        windowSpacing: 1.5,
        glassReflectivity: 0.5,
        colorTint: 0xaaccff,        // Light blue/white
        hasSetbacks: true,
        crownStyle: 'spire',        // Decorative spire/crown
        baseStyle: 'grand',         // Grand entrance
      },
      mixed: {
        windowDensity: 0.7,
        windowSize: 0.5,
        windowSpacing: 1.5,
        glassReflectivity: 0.4,
        colorTint: 0x888888,
        hasSetbacks: false,
        crownStyle: 'flat',
        baseStyle: 'retail',        // Ground floor retail
      }
    };
    
    // Building shape types
    const BUILDING_SHAPES = {
      tower: 'box',
      cylinder: 'cylinder',
      tapered: 'tapered',
      hexPrism: 'hex',
      octagon: 'octagon',
      lShape: 'lShape',
      uShape: 'uShape',
    };
    
    // Get building style based on district
    function getBuildingStyle(district, height) {
      const styleWeights = {
        core: { landmark: 3, office: 4, mixed: 2 },
        trading: { office: 5, landmark: 2, mixed: 2 },
        infrastructure: { industrial: 4, office: 2, mixed: 1 },
        projects: { office: 3, mixed: 3, landmark: 2 },
        memory: { residential: 3, mixed: 2, landmark: 1 },
      };
      
      const weights = styleWeights[district] || { mixed: 1 };
      const styles = Object.keys(weights);
      const total = Object.values(weights).reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      
      for (const style of styles) {
        r -= weights[style];
        if (r <= 0) return style;
      }
      return 'mixed';
    }
    
    function getRandomBuildingShape() {
      const shapes = ['tower', 'tower', 'tower', 'cylinder', 'tapered', 'hexPrism', 'octagon', 'lShape'];
      return shapes[Math.floor(Math.random() * shapes.length)];
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ARCHITECTURAL DETAIL GENERATORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Create window grid on a face
    function createWindowGrid(faceWidth, faceHeight, style, districtColor, isMainFace = true) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      
      // Calculate window grid
      const windowSize = styleData.windowSize;
      const spacing = styleData.windowSpacing;
      const cols = Math.max(1, Math.floor(faceWidth / spacing));
      const rows = Math.max(1, Math.floor(faceHeight / spacing));
      
      // Skip on mobile if too many windows
      const maxWindows = isMobile ? 30 : 100;
      if (cols * rows > maxWindows) {
        // Use merged geometry for performance
        return createMergedWindowGrid(faceWidth, faceHeight, style, districtColor, cols, rows);
      }
      
      const windowGeo = new THREE.PlaneGeometry(windowSize * 0.8, windowSize * 1.2);
      
      for (let col = 0; col < cols; col++) {
        for (let row = 0; row < rows; row++) {
          // Skip some windows randomly for variety
          if (Math.random() > styleData.windowDensity) continue;
          
          const isLit = Math.random() > 0.4;
          const windowMat = new THREE.MeshBasicMaterial({
            color: isLit ? 
              new THREE.Color(styleData.colorTint).lerp(districtColor, 0.3) : 
              new THREE.Color(0x111122),
            transparent: true,
            opacity: isLit ? (0.4 + Math.random() * 0.4) : 0.15,
            side: THREE.DoubleSide,
          });
          
          const window = new THREE.Mesh(windowGeo, windowMat);
          
          // Position in grid
          const xPos = (col - (cols - 1) / 2) * spacing;
          const yPos = (row - (rows - 1) / 2) * spacing;
          window.position.set(xPos, yPos, 0.02);
          
          // Add subtle frame
          if (!isMobile && Math.random() > 0.5) {
            const frameGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(windowSize * 0.85, windowSize * 1.25));
            const frameMat = new THREE.LineBasicMaterial({ 
              color: 0x334455, 
              transparent: true, 
              opacity: 0.5 
            });
            const frame = new THREE.LineSegments(frameGeo, frameMat);
            frame.position.copy(window.position);
            frame.position.z += 0.01;
            group.add(frame);
          }
          
          group.add(window);
        }
      }
      
      return group;
    }
    
    // Merged window grid for performance
    function createMergedWindowGrid(faceWidth, faceHeight, style, districtColor, cols, rows) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const spacing = styleData.windowSpacing;
      
      // Create horizontal floor lines
      const floorCount = Math.min(rows, 15);
      const floorSpacing = faceHeight / floorCount;
      
      for (let i = 1; i < floorCount; i++) {
        const lineGeo = new THREE.PlaneGeometry(faceWidth * 0.9, 0.05);
        const lineMat = new THREE.MeshBasicMaterial({
          color: districtColor,
          transparent: true,
          opacity: 0.3,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.y = -faceHeight / 2 + i * floorSpacing;
        line.position.z = 0.02;
        group.add(line);
      }
      
      // Add vertical column lines
      const colCount = Math.min(cols, 8);
      const colSpacing = faceWidth / colCount;
      
      for (let i = 1; i < colCount; i++) {
        const lineGeo = new THREE.PlaneGeometry(0.08, faceHeight * 0.95);
        const lineMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(styleData.colorTint).multiplyScalar(0.5),
          transparent: true,
          opacity: 0.4,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.x = -faceWidth / 2 + i * colSpacing;
        line.position.z = 0.02;
        group.add(line);
      }
      
      // Add glow overlay
      const glowGeo = new THREE.PlaneGeometry(faceWidth * 0.95, faceHeight * 0.95);
      const glowMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.15,
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.z = 0.01;
      group.add(glow);
      
      return group;
    }
    
    // Create building base/foundation section
    function createBuildingBase(width, depth, style, districtColor) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const baseHeight = 1.5 + Math.random() * 1;
      const baseExpand = 0.15; // How much wider the base is
      
      // Main base block
      const baseGeo = new THREE.BoxGeometry(
        width * (1 + baseExpand), 
        baseHeight, 
        depth * (1 + baseExpand)
      );
      const baseMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(styleData.colorTint).multiplyScalar(0.15),
        roughness: 0.8,
        metalness: 0.2,
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = baseHeight / 2;
      base.castShadow = !isMobile;
      group.add(base);
      
      // Entrance glow (lobby/door)
      if (styleData.baseStyle === 'lobby' || styleData.baseStyle === 'grand') {
        const entranceWidth = width * 0.4;
        const entranceHeight = baseHeight * 0.8;
        const entranceGeo = new THREE.PlaneGeometry(entranceWidth, entranceHeight);
        const entranceMat = new THREE.MeshBasicMaterial({
          color: districtColor,
          transparent: true,
          opacity: 0.6,
        });
        const entrance = new THREE.Mesh(entranceGeo, entranceMat);
        entrance.position.set(0, entranceHeight / 2 + 0.1, depth * (1 + baseExpand) / 2 + 0.02);
        group.add(entrance);
      }
      
      // Decorative ledge line
      const ledgeGeo = new THREE.BoxGeometry(width * (1 + baseExpand) + 0.1, 0.15, depth * (1 + baseExpand) + 0.1);
      const ledgeMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.4,
      });
      const ledge = new THREE.Mesh(ledgeGeo, ledgeMat);
      ledge.position.y = baseHeight;
      group.add(ledge);
      
      group.userData.baseHeight = baseHeight;
      return group;
    }
    
    // Create building crown/top section
    function createBuildingCrown(width, depth, height, style, districtColor) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const crownStyle = styleData.crownStyle;
      
      if (crownStyle === 'spire' && height > 15) {
        // Decorative spire
        const spireHeight = 3 + Math.random() * 4;
        const spireGeo = new THREE.ConeGeometry(width * 0.2, spireHeight, 6);
        const spireMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(styleData.colorTint).multiplyScalar(0.3),
          emissive: districtColor,
          emissiveIntensity: 0.5,
          metalness: 0.7,
          roughness: 0.3,
        });
        const spire = new THREE.Mesh(spireGeo, spireMat);
        spire.position.y = spireHeight / 2;
        group.add(spire);
        
        // Spire tip light
        const tipGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const tipMat = new THREE.MeshBasicMaterial({ color: districtColor });
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.position.y = spireHeight + 0.2;
        tip.userData.pulse = true;
        tip.userData.pulsePhase = Math.random() * Math.PI * 2;
        group.add(tip);
        
      } else if (crownStyle === 'cornice') {
        // Decorative cornice edge
        const corniceGeo = new THREE.BoxGeometry(width + 0.3, 0.4, depth + 0.3);
        const corniceMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(styleData.colorTint).multiplyScalar(0.4),
          roughness: 0.6,
          metalness: 0.3,
        });
        const cornice = new THREE.Mesh(corniceGeo, corniceMat);
        cornice.position.y = 0.2;
        group.add(cornice);
        
        // Small decorative elements
        for (let i = 0; i < 4; i++) {
          const ornGeo = new THREE.BoxGeometry(0.3, 0.6, 0.3);
          const ornMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(styleData.colorTint).multiplyScalar(0.35),
            emissive: districtColor,
            emissiveIntensity: 0.2,
          });
          const orn = new THREE.Mesh(ornGeo, ornMat);
          const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
          orn.position.set(
            Math.cos(angle) * (width / 2),
            0.5,
            Math.sin(angle) * (depth / 2)
          );
          group.add(orn);
        }
        
      } else if (crownStyle === 'utilitarian') {
        // Industrial: pipes, vents
        const ventCount = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < ventCount; i++) {
          const ventGeo = new THREE.CylinderGeometry(0.3, 0.3, 1 + Math.random(), 6);
          const ventMat = new THREE.MeshStandardMaterial({
            color: 0x445566,
            roughness: 0.9,
            metalness: 0.4,
          });
          const vent = new THREE.Mesh(ventGeo, ventMat);
          vent.position.set(
            (Math.random() - 0.5) * width * 0.7,
            0.5 + Math.random() * 0.3,
            (Math.random() - 0.5) * depth * 0.7
          );
          group.add(vent);
        }
      }
      
      return group;
    }
    
    // Create setback (narrower upper section for tall buildings)
    function createSetback(width, depth, setbackHeight, style, districtColor) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const reduction = 0.7 + Math.random() * 0.15; // 70-85% of original size
      
      const setbackWidth = width * reduction;
      const setbackDepth = depth * reduction;
      
      // Main setback body
      const bodyGeo = new THREE.BoxGeometry(setbackWidth, setbackHeight, setbackDepth);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(styleData.colorTint).multiplyScalar(0.2),
        emissive: new THREE.Color(styleData.colorTint).multiplyScalar(0.05),
        emissiveIntensity: 0.3,
        roughness: 0.5,
        metalness: 0.5,
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = !isMobile;
      body.receiveShadow = !isMobile;
      group.add(body);
      
      // Windows on setback
      if (!isMobile) {
        const faces = [
          { rot: 0, pos: [0, 0, setbackDepth / 2 + 0.01], w: setbackWidth, h: setbackHeight },
          { rot: Math.PI, pos: [0, 0, -setbackDepth / 2 - 0.01], w: setbackWidth, h: setbackHeight },
          { rot: Math.PI / 2, pos: [setbackWidth / 2 + 0.01, 0, 0], w: setbackDepth, h: setbackHeight },
          { rot: -Math.PI / 2, pos: [-setbackWidth / 2 - 0.01, 0, 0], w: setbackDepth, h: setbackHeight },
        ];
        
        faces.forEach(face => {
          const windows = createWindowGrid(face.w * 0.9, face.h * 0.9, style, districtColor, false);
          windows.rotation.y = face.rot;
          windows.position.set(...face.pos);
          group.add(windows);
        });
      }
      
      // Ledge at setback base
      const ledgeGeo = new THREE.BoxGeometry(width + 0.1, 0.2, depth + 0.1);
      const ledgeMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.35,
      });
      const ledge = new THREE.Mesh(ledgeGeo, ledgeMat);
      ledge.position.y = -setbackHeight / 2;
      group.add(ledge);
      
      group.userData.setbackWidth = setbackWidth;
      group.userData.setbackDepth = setbackDepth;
      
      return group;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROOFTOP FEATURES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function addACUnits(group, width, depth) {
      const unitCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < unitCount; i++) {
        const unitGeo = new THREE.BoxGeometry(0.8, 0.5, 0.6);
        const unitMat = new THREE.MeshStandardMaterial({
          color: 0x556666,
          roughness: 0.8,
          metalness: 0.3,
        });
        const unit = new THREE.Mesh(unitGeo, unitMat);
        unit.position.set(
          (Math.random() - 0.5) * width * 0.6,
          0.25,
          (Math.random() - 0.5) * depth * 0.6
        );
        group.add(unit);
        
        // Fan on top
        const fanGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 8);
        const fanMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
        const fan = new THREE.Mesh(fanGeo, fanMat);
        fan.position.y = 0.3;
        unit.add(fan);
      }
    }
    
    function addWaterTower(group, width, depth, districtColor) {
      const towerGroup = new THREE.Group();
      
      // Tank
      const tankGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 12);
      const tankMat = new THREE.MeshStandardMaterial({
        color: 0x445566,
        roughness: 0.7,
        metalness: 0.4,
      });
      const tank = new THREE.Mesh(tankGeo, tankMat);
      tank.position.y = 1.5;
      towerGroup.add(tank);
      
      // Cone top
      const topGeo = new THREE.ConeGeometry(0.9, 0.6, 12);
      const topMat = new THREE.MeshStandardMaterial({ color: 0x334455 });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = 2.55;
      towerGroup.add(top);
      
      // Legs
      for (let i = 0; i < 4; i++) {
        const legGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 4);
        const legMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
        const leg = new THREE.Mesh(legGeo, legMat);
        const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
        leg.position.set(
          Math.cos(angle) * 0.5,
          0.4,
          Math.sin(angle) * 0.5
        );
        towerGroup.add(leg);
      }
      
      towerGroup.position.set(
        (Math.random() - 0.5) * width * 0.5,
        0,
        (Math.random() - 0.5) * depth * 0.5
      );
      group.add(towerGroup);
    }
    
    function addHelipad(group, width, depth, districtColor) {
      // Pad surface
      const padSize = Math.min(width, depth) * 0.8;
      const padGeo = new THREE.CylinderGeometry(padSize / 2, padSize / 2, 0.1, 16);
      const padMat = new THREE.MeshStandardMaterial({
        color: 0x222233,
        roughness: 0.9,
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.y = 0.05;
      group.add(pad);
      
      // H marking
      const hMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.8,
      });
      
      // Vertical bars of H
      const barGeo = new THREE.PlaneGeometry(0.3, padSize * 0.5);
      const bar1 = new THREE.Mesh(barGeo, hMat);
      bar1.rotation.x = -Math.PI / 2;
      bar1.position.set(-padSize * 0.15, 0.12, 0);
      group.add(bar1);
      
      const bar2 = new THREE.Mesh(barGeo, hMat);
      bar2.rotation.x = -Math.PI / 2;
      bar2.position.set(padSize * 0.15, 0.12, 0);
      group.add(bar2);
      
      // Horizontal bar of H
      const hBarGeo = new THREE.PlaneGeometry(padSize * 0.3, 0.25);
      const hBar = new THREE.Mesh(hBarGeo, hMat);
      hBar.rotation.x = -Math.PI / 2;
      hBar.position.y = 0.12;
      group.add(hBar);
      
      // Edge lights
      const lightCount = 8;
      for (let i = 0; i < lightCount; i++) {
        const angle = (i / lightCount) * Math.PI * 2;
        const lightGeo = new THREE.SphereGeometry(0.1, 4, 4);
        const lightMat = new THREE.MeshBasicMaterial({
          color: districtColor,
          transparent: true,
          opacity: 0.9,
        });
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.set(
          Math.cos(angle) * (padSize / 2 - 0.15),
          0.15,
          Math.sin(angle) * (padSize / 2 - 0.15)
        );
        light.userData.pulse = true;
        light.userData.pulsePhase = i * Math.PI / 4;
        group.add(light);
      }
    }
    
    function addRooftopGarden(group, width, depth) {
      const gardenGeo = new THREE.BoxGeometry(width * 0.6, 0.3, depth * 0.6);
      const gardenMat = new THREE.MeshBasicMaterial({
        color: 0x2d5a2d,
        transparent: true,
        opacity: 0.9,
      });
      const garden = new THREE.Mesh(gardenGeo, gardenMat);
      garden.position.set(
        (Math.random() - 0.5) * width * 0.3,
        0.15,
        (Math.random() - 0.5) * depth * 0.3
      );
      group.add(garden);
      
      // Foliage particles
      const particleCount = isMobile ? 8 : 15;
      const particleGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = garden.position.x + (Math.random() - 0.5) * width * 0.5;
        positions[i * 3 + 1] = 0.4 + Math.random() * 0.4;
        positions[i * 3 + 2] = garden.position.z + (Math.random() - 0.5) * depth * 0.5;
      }
      
      particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const particleMat = new THREE.PointsMaterial({
        color: 0x6bff9d,
        size: 0.25,
        transparent: true,
        opacity: 0.7,
      });
      const particles = new THREE.Points(particleGeo, particleMat);
      group.add(particles);
    }
    
    function addAntennaArray(group, districtColor) {
      const antennaCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < antennaCount; i++) {
        const antennaHeight = 1.5 + Math.random() * 2.5;
        const antennaGeo = new THREE.CylinderGeometry(0.04, 0.06, antennaHeight, 4);
        const antennaMat = new THREE.MeshStandardMaterial({ 
          color: 0x333344,
          metalness: 0.6,
          roughness: 0.4,
        });
        const antenna = new THREE.Mesh(antennaGeo, antennaMat);
        antenna.position.set(
          (Math.random() - 0.5) * 1.5,
          antennaHeight / 2,
          (Math.random() - 0.5) * 1.5
        );
        group.add(antenna);
        
        // Blinking light
        const lightGeo = new THREE.SphereGeometry(0.08, 4, 4);
        const lightMat = new THREE.MeshBasicMaterial({ color: districtColor });
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.y = antennaHeight / 2 + 0.1;
        light.userData.blink = true;
        light.userData.blinkPhase = Math.random() * Math.PI * 2;
        antenna.add(light);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HOLOGRAPHIC ADVERTISEMENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function addHolographicAd(mesh, width, height, districtColor) {
      const adHeight = 1.5 + Math.random() * 1.5;
      const adWidth = width * 0.7;
      
      const holoGeo = new THREE.PlaneGeometry(adWidth, adHeight);
      const holoMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
      });
      const holo = new THREE.Mesh(holoGeo, holoMat);
      
      const side = Math.floor(Math.random() * 4);
      const offset = width / 2 + 0.1;
      const yPos = height * 0.3 + Math.random() * height * 0.3;
      
      switch(side) {
        case 0: holo.position.set(offset, yPos, 0); holo.rotation.y = Math.PI / 2; break;
        case 1: holo.position.set(-offset, yPos, 0); holo.rotation.y = -Math.PI / 2; break;
        case 2: holo.position.set(0, yPos, offset); break;
        case 3: holo.position.set(0, yPos, -offset); holo.rotation.y = Math.PI; break;
      }
      
      holo.userData.hologram = true;
      holo.userData.flickerPhase = Math.random() * Math.PI * 2;
      mesh.add(holo);
      
      // Scanlines
      for (let i = 0; i < 3; i++) {
        const lineGeo = new THREE.PlaneGeometry(adWidth, 0.04);
        const lineMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.25,
          side: THREE.DoubleSide,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.y = -adHeight/2 + (i + 1) * (adHeight / 4);
        line.position.z = 0.01;
        holo.add(line);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN BUILDING GENERATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createBuilding(config) {
      const {
        x = 0, z = 0,
        width = 2 + Math.random() * 3,
        depth = 2 + Math.random() * 3,
        height = 5 + Math.random() * 20,
        district = 'core',
        label = '',
        type = getRandomBuildingShape(),
      } = config;
      
      const districtData = DISTRICTS[district] || DISTRICTS.core;
      const style = getBuildingStyle(district, height);
      const styleData = BUILDING_STYLES[style];
      
      // Create main building group
      const buildingGroup = new THREE.Group();
      buildingGroup.position.set(x, 0, z);
      
      // === BASE SECTION ===
      const base = createBuildingBase(width, depth, style, districtData.color);
      buildingGroup.add(base);
      const baseHeight = base.userData.baseHeight;
      
      // === MAIN BODY ===
      // Calculate if we need setbacks (for tall buildings)
      const needsSetback = styleData.hasSetbacks && height > 20;
      const setbackHeight = needsSetback ? height * 0.3 : 0;
      const mainBodyHeight = height - baseHeight - setbackHeight;
      
      // Main body material
      const bodyMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(styleData.colorTint).multiplyScalar(0.18),
        emissive: districtData.emissive,
        emissiveIntensity: 0.4,
        roughness: 0.55 - styleData.glassReflectivity * 0.3,
        metalness: 0.3 + styleData.glassReflectivity * 0.4,
      });
      
      let mainBody;
      if (type === 'cylinder' || type === 'octagon' || type === 'hex') {
        const segments = type === 'hex' ? 6 : (type === 'octagon' ? 8 : 12);
        const bodyGeo = new THREE.CylinderGeometry(width/2, width/2, mainBodyHeight, segments);
        mainBody = new THREE.Mesh(bodyGeo, bodyMat);
      } else if (type === 'tapered') {
        const bodyGeo = new THREE.CylinderGeometry(width * 0.4, width/2, mainBodyHeight, 8);
        mainBody = new THREE.Mesh(bodyGeo, bodyMat);
      } else if (type === 'lShape') {
        // L-shaped building using merged boxes
        const group = new THREE.Group();
        const box1Geo = new THREE.BoxGeometry(width, mainBodyHeight, depth * 0.6);
        const box1 = new THREE.Mesh(box1Geo, bodyMat);
        box1.position.z = depth * 0.2;
        group.add(box1);
        
        const box2Geo = new THREE.BoxGeometry(width * 0.6, mainBodyHeight, depth);
        const box2 = new THREE.Mesh(box2Geo, bodyMat.clone());
        box2.position.x = -width * 0.2;
        group.add(box2);
        
        mainBody = group;
      } else {
        // Default box tower
        const bodyGeo = new THREE.BoxGeometry(width, mainBodyHeight, depth);
        mainBody = new THREE.Mesh(bodyGeo, bodyMat);
      }
      
      mainBody.position.y = baseHeight + mainBodyHeight / 2;
      if (mainBody.castShadow !== undefined) {
        mainBody.castShadow = !isMobile;
        mainBody.receiveShadow = !isMobile;
      }
      buildingGroup.add(mainBody);
      
      // === WINDOWS ON MAIN BODY ===
      if (type === 'tower' || type === 'lShape') {
        // Add window grids to box faces
        const faces = [
          { rot: 0, pos: [0, baseHeight + mainBodyHeight/2, depth/2 + 0.02], w: width, h: mainBodyHeight },
          { rot: Math.PI, pos: [0, baseHeight + mainBodyHeight/2, -depth/2 - 0.02], w: width, h: mainBodyHeight },
          { rot: Math.PI/2, pos: [width/2 + 0.02, baseHeight + mainBodyHeight/2, 0], w: depth, h: mainBodyHeight },
          { rot: -Math.PI/2, pos: [-width/2 - 0.02, baseHeight + mainBodyHeight/2, 0], w: depth, h: mainBodyHeight },
        ];
        
        faces.forEach((face, idx) => {
          const windows = createWindowGrid(face.w * 0.92, face.h * 0.92, style, districtData.color, idx < 2);
          windows.rotation.y = face.rot;
          windows.position.set(...face.pos);
          buildingGroup.add(windows);
        });
      } else if (type !== 'dome' && type !== 'spire') {
        // Cylindrical buildings: add ring windows
        const floorCount = Math.floor(mainBodyHeight / styleData.windowSpacing);
        for (let i = 1; i < floorCount; i++) {
          if (Math.random() > styleData.windowDensity) continue;
          
          const ringRadius = type === 'tapered' ? 
            width/2 * (0.4 + 0.6 * (1 - i/floorCount)) + 0.03 :
            width/2 + 0.03;
          const segments = type === 'hex' ? 6 : (type === 'octagon' ? 8 : 16);
          const ringGeo = new THREE.TorusGeometry(ringRadius, 0.06, 4, segments);
          const ringMat = new THREE.MeshBasicMaterial({
            color: districtData.color,
            transparent: true,
            opacity: 0.4 + Math.random() * 0.3,
          });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = Math.PI / 2;
          ring.position.y = baseHeight + i * styleData.windowSpacing;
          buildingGroup.add(ring);
        }
      }
      
      // === FLOOR LEDGES (horizontal lines) ===
      if (!isMobile && height > 10) {
        const ledgeCount = Math.floor(mainBodyHeight / 5);
        for (let i = 1; i < ledgeCount; i++) {
          const ledgeY = baseHeight + i * 5;
          if (type === 'tower' || type === 'lShape') {
            const ledgeGeo = new THREE.BoxGeometry(width + 0.08, 0.1, depth + 0.08);
            const ledgeMat = new THREE.MeshBasicMaterial({
              color: new THREE.Color(styleData.colorTint).multiplyScalar(0.3),
              transparent: true,
              opacity: 0.5,
            });
            const ledge = new THREE.Mesh(ledgeGeo, ledgeMat);
            ledge.position.y = ledgeY;
            buildingGroup.add(ledge);
          }
        }
      }
      
      // === SETBACK SECTION (for tall buildings) ===
      let topY = baseHeight + mainBodyHeight;
      let topWidth = width;
      let topDepth = depth;
      
      if (needsSetback) {
        const setback = createSetback(width, depth, setbackHeight, style, districtData.color);
        setback.position.y = topY + setbackHeight / 2;
        buildingGroup.add(setback);
        
        topY += setbackHeight;
        topWidth = setback.userData.setbackWidth;
        topDepth = setback.userData.setbackDepth;
      }
      
      // === CROWN/TOP SECTION ===
      const crown = createBuildingCrown(topWidth, topDepth, height, style, districtData.color);
      crown.position.y = topY;
      buildingGroup.add(crown);
      
      // === ROOFTOP FEATURES ===
      const rooftopGroup = new THREE.Group();
      rooftopGroup.position.y = topY;
      
      const rooftopRoll = Math.random();
      if (height > 25 && rooftopRoll < 0.15) {
        // Helipad for very tall buildings
        addHelipad(rooftopGroup, topWidth, topDepth, districtData.color);
      } else if (height > 15 && rooftopRoll < 0.35) {
        // Water tower
        addWaterTower(rooftopGroup, topWidth, topDepth, districtData.color);
      } else if (height > 10 && rooftopRoll < 0.55) {
        // AC units
        addACUnits(rooftopGroup, topWidth, topDepth);
      } else if (height > 8 && rooftopRoll < 0.7) {
        // Rooftop garden
        addRooftopGarden(rooftopGroup, topWidth, topDepth);
      } else if (height > 12) {
        // Antennas
        addAntennaArray(rooftopGroup, districtData.color);
      }
      
      buildingGroup.add(rooftopGroup);
      
      // === TOP BEACON ===
      if (height > 18 && styleData.crownStyle !== 'spire') {
        const beaconGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const beaconMat = new THREE.MeshBasicMaterial({ color: districtData.color });
        const beacon = new THREE.Mesh(beaconGeo, beaconMat);
        beacon.position.y = topY + 1;
        beacon.userData.pulse = true;
        beacon.userData.pulsePhase = Math.random() * Math.PI * 2;
        buildingGroup.add(beacon);
      }
      
      // === HOLOGRAPHIC AD (occasional) ===
      if (height > 10 && Math.random() < 0.25) {
        addHolographicAd(buildingGroup, width, height, districtData.color);
      }
      
      scene.add(buildingGroup);
      
      const building = {
        mesh: buildingGroup,
        district,
        label,
        type,
        style,
        x, z,
        width, depth, height,
        createdAt: Date.now(),
      };
      
      city.buildings.push(building);
      
      if (!city.districts.has(district)) {
        city.districts.set(district, []);
      }
      city.districts.get(district).push(building);
      
      // Initialize ambient life for this building
      addElevatorToBuilding(building);
      initializeWindowStates(building);
      
      updateStats();
      return building;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION LINES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createConnection(building1, building2) {
      const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(building1.x, 0.5, building1.z),
        new THREE.Vector3(
          (building1.x + building2.x) / 2,
          2 + Math.random() * 2,
          (building1.z + building2.z) / 2
        ),
        new THREE.Vector3(building2.x, 0.5, building2.z)
      );
      
      const points = curve.getPoints(20);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.25,
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      
      const connection = { line, from: building1, to: building2 };
      city.connections.push(connection);
      
      // Create data stream particles for this connection
      createDataStream(connection);
      
      updateStats();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HOLOGRAPHIC DISTRICT LABELS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDistrictLabels() {
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;
        
        // Transparent background
        ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Glowing text
        ctx.font = 'bold 48px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Glow effect
        ctx.shadowColor = '#' + district.color.getHexString();
        ctx.shadowBlur = 20;
        ctx.fillStyle = '#' + district.color.getHexString();
        ctx.fillText(district.name, canvas.width / 2, canvas.height / 2);
        
        // Brighter center
        ctx.shadowBlur = 5;
        ctx.fillStyle = '#ffffff';
        ctx.fillText(district.name, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const labelMat = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.8,
        });
        
        const label = new THREE.Sprite(labelMat);
        label.position.set(
          district.position.x,
          25 + Math.random() * 5,
          district.position.z
        );
        label.scale.set(15, 4, 1);
        
        label.userData.baseY = label.position.y;
        label.userData.floatPhase = Math.random() * Math.PI * 2;
        
        scene.add(label);
        city.districtLabels.push(label);
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FLYING DRONES/VEHICLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDrones() {
      const droneCount = isMobile ? 8 : 15;
      
      for (let i = 0; i < droneCount; i++) {
        const droneGroup = new THREE.Group();
        
        // Main body
        const bodyGeo = new THREE.SphereGeometry(0.3, 6, 4);
        const bodyMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.8,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        droneGroup.add(body);
        
        // Light trail
        const trailGeo = new THREE.ConeGeometry(0.15, 1.5, 4);
        const trailMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.rotation.x = Math.PI / 2;
        trail.position.z = 0.8;
        droneGroup.add(trail);
        
        // Random patrol path
        const pathRadius = 15 + Math.random() * 40;
        const pathHeight = 10 + Math.random() * 25;
        const pathSpeed = 0.2 + Math.random() * 0.3;
        const pathOffset = Math.random() * Math.PI * 2;
        const pathTilt = (Math.random() - 0.5) * 0.5;
        
        droneGroup.userData = {
          pathRadius,
          pathHeight,
          pathSpeed,
          pathOffset,
          pathTilt,
        };
        
        scene.add(droneGroup);
        city.drones.push(droneGroup);
      }
    }
    
    function updateDrones(time) {
      city.drones.forEach((drone, i) => {
        const { pathRadius, pathHeight, pathSpeed, pathOffset, pathTilt } = drone.userData;
        
        const t = time * pathSpeed + pathOffset;
        const x = Math.cos(t) * pathRadius;
        const z = Math.sin(t) * pathRadius + Math.sin(t * 2) * pathRadius * 0.2;
        const y = pathHeight + Math.sin(t * 1.5) * 5;
        
        drone.position.set(x, y, z);
        
        // Face movement direction
        const nextT = t + 0.1;
        const nextX = Math.cos(nextT) * pathRadius;
        const nextZ = Math.sin(nextT) * pathRadius + Math.sin(nextT * 2) * pathRadius * 0.2;
        drone.lookAt(nextX, y, nextZ);
        
        // Update drone lighting based on time of day
        drone.children.forEach(child => {
          if (child.material) {
            // Brighter at night, dimmer during bright day
            const baseOpacity = 0.5 + city.nightIntensity * 0.4;
            child.material.opacity = baseOpacity;
            
            // Color shift: warmer during golden hour, cooler at night
            if (lighting.goldenHourIntensity > 0) {
              child.material.color.setHex(0x44ffcc);
            } else if (city.nightIntensity > 0.5) {
              child.material.color.setHex(0x4488ff);
            } else {
              child.material.color.setHex(0x00ffff);
            }
          }
        });
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT PARTICLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createParticles() {
      const particleCount = isMobile ? 200 : 500;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        velocities[i * 3] = (Math.random() - 0.5) * 0.02;
        velocities[i * 3 + 1] = Math.random() * 0.02 + 0.01;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.userData = { velocities };
      
      const material = new THREE.PointsMaterial({
        color: 0x66ddff,
        size: 0.15,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
      });
      
      city.particles = new THREE.Points(geometry, material);
      scene.add(city.particles);
    }
    
    function updateParticles() {
      if (!city.particles) return;
      
      const positions = city.particles.geometry.attributes.position.array;
      const velocities = city.particles.geometry.userData.velocities;
      
      for (let i = 0; i < positions.length / 3; i++) {
        positions[i * 3] += velocities[i * 3];
        positions[i * 3 + 1] += velocities[i * 3 + 1];
        positions[i * 3 + 2] += velocities[i * 3 + 2];
        
        // Reset particles that go too high
        if (positions[i * 3 + 1] > 60) {
          positions[i * 3] = (Math.random() - 0.5) * 100;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        }
      }
      
      city.particles.geometry.attributes.position.needsUpdate = true;
      
      // Particle color and visibility responds to time
      // Brighter and more visible at night, almost invisible during bright day
      const dayVisibility = 0.3;
      const nightVisibility = 0.8;
      city.particles.material.opacity = dayVisibility + (nightVisibility - dayVisibility) * city.nightIntensity;
      
      // Color shift with atmosphere
      if (lighting.goldenHourIntensity > 0) {
        city.particles.material.color.setHex(0xffdd88); // Warm golden
      } else if (city.nightIntensity > 0.5) {
        city.particles.material.color.setHex(0x88ccff); // Cool blue
      } else {
        city.particles.material.color.setHex(0x66ddff); // Neutral cyan
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CORE SPIRE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createCoreSpire() {
      // Main crystalline spire
      const spireGeo = new THREE.CylinderGeometry(0.3, 2.5, 40, 8);
      const spireMat = new THREE.MeshStandardMaterial({
        color: 0x001a1a,
        emissive: 0x00ffff,
        emissiveIntensity: 1.0,
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9,
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.set(0, 20, 0);
      spire.castShadow = !isMobile;
      scene.add(spire);
      
      // Inner glow core
      const coreGeo = new THREE.SphereGeometry(1.5, 16, 16);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.8,
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      core.position.set(0, 8, 0);
      core.userData.pulse = true;
      scene.add(core);
      city.coreGlow = core;
      
      // Rotating energy rings
      for (let i = 0; i < 4; i++) {
        const ringGeo = new THREE.TorusGeometry(3 + i * 2, 0.08, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.6 - i * 0.1,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(0, 8 + i * 7, 0);
        ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
        ring.userData.rotationSpeed = 0.4 + i * 0.15;
        ring.userData.rotationAxis = i % 2 === 0 ? 'z' : 'y';
        ring.userData.wobble = Math.random() * 0.02;
        scene.add(ring);
        city.coreRings.push(ring);
      }
      
      // Energy beams shooting up
      for (let i = 0; i < 3; i++) {
        const beamGeo = new THREE.CylinderGeometry(0.05, 0.15, 50, 4);
        const beamMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        const angle = (i / 3) * Math.PI * 2;
        beam.position.set(Math.cos(angle) * 2, 25, Math.sin(angle) * 2);
        beam.userData.beamPhase = i * 0.7;
        scene.add(beam);
        city.coreRings.push(beam);
      }
      
      // Base platform with glow
      const baseGeo = new THREE.CylinderGeometry(6, 7, 1.5, 8);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x0a1a1a,
        emissive: 0x004444,
        emissiveIntensity: 0.8,
        roughness: 0.4,
        metalness: 0.6,
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, 0.75, 0);
      base.receiveShadow = true;
      scene.add(base);
      
      // Pulsing floor rings
      for (let i = 0; i < 3; i++) {
        const floorRingGeo = new THREE.TorusGeometry(8 + i * 3, 0.15, 4, 32);
        const floorRingMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3 - i * 0.08,
        });
        const floorRing = new THREE.Mesh(floorRingGeo, floorRingMat);
        floorRing.rotation.x = -Math.PI / 2;
        floorRing.position.y = 0.1;
        floorRing.userData.pulseRing = true;
        floorRing.userData.pulsePhase = i * 0.5;
        scene.add(floorRing);
        city.coreRings.push(floorRing);
      }
      
      city.buildings.push({
        mesh: spire,
        district: 'core',
        label: 'Nexus Core',
        x: 0, z: 0,
        height: 40,
        createdAt: Date.now(),
      });
    }
    // NOTE: seedCity() removed - was dead code, replaced by seedCityFallback()
    // which is called from the init section after createCoreSpire()
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENVIRONMENT ANIMATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateEnvironment(dt) {
      // Animate clouds - color responds to fog/sky
      if (city.clouds) {
        city.clouds.forEach(cloud => {
          cloud.userData.angle += cloud.userData.speed;
          cloud.position.x = Math.cos(cloud.userData.angle) * cloud.userData.radius;
          cloud.position.z = Math.sin(cloud.userData.angle) * cloud.userData.radius;
          cloud.position.y = cloud.userData.baseY + Math.sin(dt * 0.2 + cloud.userData.angle) * 3;
          
          // Cloud color matches fog with slight warmth during golden hour
          if (cloud.material.color) {
            cloud.material.color.copy(lighting.currentFogColor).multiplyScalar(2.5);
            if (lighting.goldenHourIntensity > 0) {
              cloud.material.color.r += lighting.goldenHourIntensity * 0.15;
              cloud.material.color.g += lighting.goldenHourIntensity * 0.05;
            }
          }
          // Clouds more opaque at night (denser atmosphere feel)
          cloud.material.opacity = 0.12 + city.nightIntensity * 0.1;
        });
      }
      
      // Animate floating rocks - subtle glow at night
      if (city.floatingRocks) {
        city.floatingRocks.forEach(rock => {
          rock.position.y = rock.userData.baseY + 
            Math.sin(dt * rock.userData.floatSpeed + rock.userData.floatPhase) * 2;
          rock.rotation.y += 0.001;
          
          // Emissive glow intensifies at night
          if (rock.material.emissiveIntensity !== undefined) {
            rock.material.emissiveIntensity = 0.2 + city.nightIntensity * 0.5;
            // Moonlight tint
            if (city.nightIntensity > 0.3) {
              rock.material.emissive.setHex(0x112244);
            } else {
              rock.material.emissive.setHex(0x001122);
            }
          }
        });
      }
      
      // Pulse island edge - color shifts with time
      if (city.islandEdge) {
        const basePulse = Math.sin(dt * 0.5) * 0.1;
        city.islandEdge.material.opacity = 0.25 + basePulse + city.nightIntensity * 0.15;
        // Warmer during golden hour, cooler at night
        if (lighting.goldenHourIntensity > 0) {
          city.islandEdge.material.color.setHex(0xffaa44);
        } else if (city.nightIntensity > 0.3) {
          city.islandEdge.material.color.setHex(0x3366ff);
        } else {
          city.islandEdge.material.color.setHex(0x00aaff);
        }
      }
      
      // Pulse horizon ring - atmospheric glow
      if (city.horizonRing) {
        const scale = 1 + Math.sin(dt * 0.3) * 0.02;
        city.horizonRing.scale.set(scale, scale, 1);
        city.horizonRing.material.opacity = 0.2 + Math.sin(dt * 0.4) * 0.1 + city.nightIntensity * 0.2;
        
        // Horizon color matches atmosphere
        if (lighting.goldenHourIntensity > 0) {
          city.horizonRing.material.color.setHex(0xff7744);
        } else if (city.nightIntensity > 0.5) {
          city.horizonRing.material.color.setHex(0x1a3366);
        } else {
          city.horizonRing.material.color.setHex(0x003355);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEATHER SYSTEM - Rain, Fog, Aurora
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const WEATHER_CONFIG = {
      rain: {
        particleCount: isMobile ? 800 : 2000,
        speed: 0.8,
        spread: 120,
        height: 80,
      },
      fog: {
        layers: isMobile ? 3 : 6,
        baseOpacity: 0.15,
        nightMultiplier: 1.5,
      },
      aurora: {
        ribbonCount: isMobile ? 3 : 5,
        waveSpeed: 0.3,
        colors: [0x00ff88, 0x00ffaa, 0x88ffaa, 0xaa88ff, 0x6644ff],
      }
    };
    
    /**
     * Create rain particle system
     */
    function createRainSystem() {
      if (city.rainSystem) return;
      
      const config = WEATHER_CONFIG.rain;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(config.particleCount * 3);
      const velocities = new Float32Array(config.particleCount);
      
      for (let i = 0; i < config.particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * config.spread;
        positions[i * 3 + 1] = Math.random() * config.height;
        positions[i * 3 + 2] = (Math.random() - 0.5) * config.spread;
        velocities[i] = 0.5 + Math.random() * 0.5; // Individual speed variation
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.userData = { velocities };
      
      // Rain drop material - elongated points
      const material = new THREE.PointsMaterial({
        color: 0x8899aa,
        size: isMobile ? 0.08 : 0.12,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
      });
      
      city.rainSystem = new THREE.Points(geometry, material);
      scene.add(city.rainSystem);
      
      // Create puddles on ground
      createPuddles();
    }
    
    /**
     * Create puddle reflections on ground
     */
    function createPuddles() {
      const puddleCount = isMobile ? 8 : 15;
      
      for (let i = 0; i < puddleCount; i++) {
        const size = 2 + Math.random() * 4;
        const geometry = new THREE.CircleGeometry(size, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0x2a3a4a,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
        });
        
        const puddle = new THREE.Mesh(geometry, material);
        puddle.rotation.x = -Math.PI / 2;
        puddle.position.set(
          (Math.random() - 0.5) * 80,
          0.02,
          (Math.random() - 0.5) * 80
        );
        puddle.userData.baseOpacity = 0.2 + Math.random() * 0.2;
        puddle.userData.ripplePhase = Math.random() * Math.PI * 2;
        
        scene.add(puddle);
        city.puddles.push(puddle);
      }
    }
    
    /**
     * Update rain system
     */
    function updateRain(dt, intensity) {
      if (!city.rainSystem) return;
      
      const config = WEATHER_CONFIG.rain;
      const positions = city.rainSystem.geometry.attributes.position.array;
      const velocities = city.rainSystem.geometry.userData.velocities;
      
      // Update rain drop positions
      for (let i = 0; i < positions.length / 3; i++) {
        positions[i * 3 + 1] -= config.speed * velocities[i] * intensity;
        
        // Add slight horizontal drift
        positions[i * 3] += Math.sin(dt + i) * 0.01;
        
        // Reset drops that hit ground
        if (positions[i * 3 + 1] < 0) {
          positions[i * 3] = (Math.random() - 0.5) * config.spread;
          positions[i * 3 + 1] = config.height;
          positions[i * 3 + 2] = (Math.random() - 0.5) * config.spread;
        }
      }
      
      city.rainSystem.geometry.attributes.position.needsUpdate = true;
      city.rainSystem.material.opacity = intensity * 0.6;
      
      // Update puddles with ripple effect
      city.puddles.forEach(puddle => {
        const ripple = Math.sin(dt * 3 + puddle.userData.ripplePhase) * 0.05;
        puddle.material.opacity = puddle.userData.baseOpacity * intensity + ripple * intensity;
        
        // Slight color variation based on sky reflection
        if (city.nightIntensity > 0.5) {
          puddle.material.color.setHex(0x1a2a3a);
        } else {
          puddle.material.color.setHex(0x3a4a5a);
        }
      });
    }
    
    /**
     * Create fog/mist layers
     */
    function createFogSystem() {
      if (city.fogPlanes.length > 0) return;
      
      const config = WEATHER_CONFIG.fog;
      
      for (let i = 0; i < config.layers; i++) {
        const size = 200 + i * 50;
        const geometry = new THREE.PlaneGeometry(size, size);
        const material = new THREE.MeshBasicMaterial({
          color: 0x445566,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          depthWrite: false,
        });
        
        const fogPlane = new THREE.Mesh(geometry, material);
        fogPlane.rotation.x = -Math.PI / 2;
        fogPlane.position.y = 0.5 + i * 3;
        fogPlane.userData.baseY = fogPlane.position.y;
        fogPlane.userData.driftPhase = Math.random() * Math.PI * 2;
        fogPlane.userData.layerIndex = i;
        
        scene.add(fogPlane);
        city.fogPlanes.push(fogPlane);
      }
    }
    
    /**
     * Update fog system
     */
    function updateFog(dt, intensity) {
      const config = WEATHER_CONFIG.fog;
      const nightBoost = 1 + city.nightIntensity * (config.nightMultiplier - 1);
      
      city.fogPlanes.forEach((fogPlane, i) => {
        // Gentle vertical drift
        fogPlane.position.y = fogPlane.userData.baseY + 
          Math.sin(dt * 0.2 + fogPlane.userData.driftPhase) * 1;
        
        // Horizontal drift
        fogPlane.position.x = Math.sin(dt * 0.1 + i) * 5;
        fogPlane.position.z = Math.cos(dt * 0.15 + i) * 5;
        
        // Opacity based on layer (lower = denser)
        const layerFactor = 1 - (fogPlane.userData.layerIndex / config.layers) * 0.5;
        fogPlane.material.opacity = config.baseOpacity * layerFactor * intensity * nightBoost;
        
        // Fog color shifts with time of day
        if (city.nightIntensity > 0.5) {
          fogPlane.material.color.setHex(0x1a2233); // Darker, bluer at night
        } else if (lighting.goldenHourIntensity > 0) {
          fogPlane.material.color.setHex(0x665544); // Warm during golden hour
        } else {
          fogPlane.material.color.setHex(0x445566); // Neutral gray-blue
        }
      });
      
      // Increase scene fog density when fog weather is active
      if (intensity > 0) {
        scene.fog.density = 0.004 + intensity * 0.008;
      }
    }
    
    /**
     * Create aurora borealis system
     */
    function createAuroraSystem() {
      if (city.aurora) return;
      
      const config = WEATHER_CONFIG.aurora;
      const auroraGroup = new THREE.Group();
      auroraGroup.ribbons = [];
      
      for (let i = 0; i < config.ribbonCount; i++) {
        // Create flowing ribbon geometry
        const width = 80 + Math.random() * 40;
        const segments = 32;
        const geometry = new THREE.PlaneGeometry(width, 30, segments, 1);
        
        const material = new THREE.MeshBasicMaterial({
          color: config.colors[i % config.colors.length],
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        
        const ribbon = new THREE.Mesh(geometry, material);
        ribbon.position.set(
          (Math.random() - 0.5) * 100,
          150 + Math.random() * 50,
          -100 - Math.random() * 100
        );
        ribbon.rotation.x = Math.PI / 6 + Math.random() * 0.2;
        ribbon.userData.phaseOffset = Math.random() * Math.PI * 2;
        ribbon.userData.waveScale = 0.5 + Math.random() * 0.5;
        ribbon.userData.colorIndex = i % config.colors.length;
        
        auroraGroup.add(ribbon);
        auroraGroup.ribbons.push(ribbon);
      }
      
      city.aurora = auroraGroup;
      scene.add(auroraGroup);
    }
    
    /**
     * Update aurora effect
     */
    function updateAurora(dt, intensity) {
      if (!city.aurora) return;
      
      const config = WEATHER_CONFIG.aurora;
      
      // Aurora only visible at night
      const nightFactor = Math.max(0, city.nightIntensity - 0.3) / 0.7;
      const effectiveIntensity = intensity * nightFactor;
      
      city.aurora.ribbons.forEach((ribbon, i) => {
        // Animate vertex positions for flowing effect
        const positions = ribbon.geometry.attributes.position.array;
        const segmentCount = 33; // segments + 1
        
        for (let j = 0; j < segmentCount; j++) {
          const waveOffset = dt * config.waveSpeed + j * 0.3 + ribbon.userData.phaseOffset;
          const wave = Math.sin(waveOffset) * 8 * ribbon.userData.waveScale;
          
          // Top and bottom vertices
          positions[j * 6 + 1] = 15 + wave; // Top y
          positions[j * 6 + 4] = -15 + wave * 0.5; // Bottom y
        }
        
        ribbon.geometry.attributes.position.needsUpdate = true;
        
        // Pulsing opacity
        const pulse = Math.sin(dt * 0.5 + i) * 0.1 + 0.9;
        ribbon.material.opacity = effectiveIntensity * 0.35 * pulse;
        
        // Gentle color cycling
        const colorPhase = (dt * 0.1 + i * 0.5) % config.colors.length;
        const colorIndex = Math.floor(colorPhase);
        const nextIndex = (colorIndex + 1) % config.colors.length;
        const colorBlend = colorPhase - colorIndex;
        
        const color1 = new THREE.Color(config.colors[colorIndex]);
        const color2 = new THREE.Color(config.colors[nextIndex]);
        ribbon.material.color.lerpColors(color1, color2, colorBlend);
        
        // Slow drift movement
        ribbon.position.x += Math.sin(dt * 0.1 + i) * 0.02;
      });
      
      // Subtle aurora reflection on buildings at night
      if (effectiveIntensity > 0.1) {
        city.buildings.forEach(b => {
          if (b.mesh.material && b.mesh.material.emissive) {
            const auroraGlow = new THREE.Color(0x004422).multiplyScalar(effectiveIntensity * 0.1);
            b.mesh.material.emissive.add(auroraGlow);
          }
        });
      }
    }
    
    /**
     * Set weather state with smooth transition
     */
    function setWeather(weather) {
      if (weather === city.weather && weather === city.targetWeather) return;
      
      city.targetWeather = weather;
      console.log(`[Weather] Transitioning to: ${weather}`);
      
      // Initialize systems if needed
      if (weather === 'rain' && !city.rainSystem) createRainSystem();
      if (weather === 'fog' && city.fogPlanes.length === 0) createFogSystem();
      if (weather === 'aurora' && !city.aurora) createAuroraSystem();
      
      // Update UI
      if (weatherStateEl) {
        weatherStateEl.textContent = weather;
        weatherStateEl.style.color = {
          clear: 'rgba(100, 200, 255, 0.8)',
          rain: 'rgba(100, 150, 200, 0.9)',
          fog: 'rgba(150, 150, 170, 0.9)',
          aurora: 'rgba(100, 255, 150, 0.9)',
        }[weather] || 'rgba(100, 200, 255, 0.8)';
      }
    }
    
    /**
     * Update weather system with transitions
     */
    function updateWeather(dt) {
      // Smooth transition to target weather
      const transitionSpeed = 0.01;
      
      if (city.weather !== city.targetWeather) {
        // Fade out current weather
        city.weatherIntensity -= transitionSpeed;
        if (city.weatherIntensity <= 0) {
          city.weatherIntensity = 0;
          city.weather = city.targetWeather;
        }
      } else if (city.weatherIntensity < 1 && city.weather !== 'clear') {
        // Fade in new weather
        city.weatherIntensity += transitionSpeed;
        if (city.weatherIntensity > 1) city.weatherIntensity = 1;
      } else if (city.weather === 'clear') {
        city.weatherIntensity = Math.max(0, city.weatherIntensity - transitionSpeed);
      }
      
      // Update active weather effects
      const intensity = city.weatherIntensity;
      
      // Rain
      if (city.rainSystem) {
        const rainActive = city.weather === 'rain' || (city.targetWeather === 'rain' && intensity > 0);
        updateRain(dt, rainActive ? intensity : Math.max(0, intensity - 0.5) * 2);
      }
      
      // Fog
      if (city.fogPlanes.length > 0) {
        const fogActive = city.weather === 'fog' || (city.targetWeather === 'fog' && intensity > 0);
        updateFog(dt, fogActive ? intensity : 0);
      }
      
      // Aurora
      if (city.aurora) {
        const auroraActive = city.weather === 'aurora' || (city.targetWeather === 'aurora' && intensity > 0);
        updateAurora(dt, auroraActive ? intensity : 0);
      }
      
      // Wet building effect during rain
      if (city.weather === 'rain' && intensity > 0.3) {
        city.buildings.forEach(b => {
          if (b.mesh.material) {
            // Increase specularity/metalness for wet look
            if (b.mesh.material.metalness !== undefined) {
              b.mesh.material.metalness = 0.4 + intensity * 0.3;
            }
            if (b.mesh.material.roughness !== undefined) {
              b.mesh.material.roughness = 0.6 - intensity * 0.2;
            }
          }
        });
      } else {
        // Reset to normal
        city.buildings.forEach(b => {
          if (b.mesh.material) {
            if (b.mesh.material.metalness !== undefined) {
              b.mesh.material.metalness = 0.4;
            }
            if (b.mesh.material.roughness !== undefined) {
              b.mesh.material.roughness = 0.6;
            }
          }
        });
      }
    }
    
    // Weather keyboard controls are handled in the main keyboard handler below
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GROWTH SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let lastGrowth = Date.now();
    const GROWTH_INTERVAL = 30000;
    
    function growCity() {
      const now = Date.now();
      if (now - lastGrowth < GROWTH_INTERVAL) return;
      lastGrowth = now;
      
      const districtKeys = Object.keys(DISTRICTS);
      const district = districtKeys[Math.floor(Math.random() * districtKeys.length)];
      const districtData = DISTRICTS[district];
      
      const existing = city.districts.get(district) || [];
      let x, z;
      
      if (existing.length > 0) {
        const parent = existing[Math.floor(Math.random() * existing.length)];
        const angle = Math.random() * Math.PI * 2;
        const radius = 5 + Math.random() * 8;
        x = parent.x + Math.cos(angle) * radius;
        z = parent.z + Math.sin(angle) * radius;
      } else {
        x = districtData.position.x + (Math.random() - 0.5) * 10;
        z = districtData.position.z + (Math.random() - 0.5) * 10;
      }
      
      const newBuilding = createBuilding({
        x, z,
        district,
        height: 5 + Math.random() * 15,
      });
      
      if (existing.length > 0) {
        const nearest = existing.reduce((best, b) => {
          const d1 = Math.hypot(b.x - x, b.z - z);
          const d2 = Math.hypot(best.x - x, best.z - z);
          return d1 < d2 ? b : best;
        });
        createConnection(newBuilding, nearest);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateStats() {
      buildingCountEl.textContent = city.buildings.length;
      districtCountEl.textContent = city.districts.size;
      connectionCountEl.textContent = city.connections.length;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INTERACTION SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const interaction = {
      raycaster: new THREE.Raycaster(),
      mouse: new THREE.Vector2(),
      hoveredBuilding: null,
      selectedBuilding: null,
      focusedDistrict: null,
      isPaused: false,
      originalCameraPosition: null,
      originalControlsTarget: null,
      isAnimatingCamera: false,
      // Touch state
      touchStartTime: 0,
      touchStartPos: { x: 0, y: 0 },
      lastTapTime: 0,
      longPressTimer: null,
    };
    
    // UI Elements
    const tooltipEl = document.getElementById('tooltip');
    const infoPanelEl = document.getElementById('infoPanel');
    const infoPanelTitleEl = document.getElementById('infoPanelTitle');
    const infoPanelCloseEl = document.getElementById('infoPanelClose');
    const infoPanelDistrictEl = document.getElementById('infoPanelDistrict');
    const infoPanelTypeEl = document.getElementById('infoPanelType');
    const infoPanelDimensionsEl = document.getElementById('infoPanelDimensions');
    const infoPanelSourcesEl = document.getElementById('infoPanelSources');
    const focusIndicatorEl = document.getElementById('focusIndicator');
    const focusDistrictNameEl = document.getElementById('focusDistrictName');
    const pauseIndicatorEl = document.getElementById('pauseIndicator');
    const controlsHintEl = document.querySelector('.controls-hint');
    
    // District keys mapping for keyboard shortcuts
    const DISTRICT_KEYS = ['core', 'trading', 'infrastructure', 'projects', 'memory'];
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // RAYCASTING & SELECTION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function updateMousePosition(event) {
      const rect = canvas.getBoundingClientRect();
      interaction.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      interaction.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }
    
    function getBuildingMeshes() {
      return city.buildings.map(b => b.mesh).filter(m => m);
    }
    
    function getDistrictLabelSprites() {
      return city.districtLabels.filter(l => l);
    }
    
    function raycastBuildings() {
      interaction.raycaster.setFromCamera(interaction.mouse, camera);
      const meshes = getBuildingMeshes();
      if (meshes.length === 0) return null;
      
      // Use recursive=true to find children of compound buildings
      const intersects = interaction.raycaster.intersectObjects(meshes, true);
      
      if (intersects.length > 0 && intersects[0].object) {
        let mesh = intersects[0].object;
        
        // Traverse up to find the building group (parent might be the actual building)
        while (mesh && mesh.parent) {
          // Check if this mesh or its parent is a building
          const building = city.buildings.find(b => b.mesh === mesh);
          if (building) return building;
          mesh = mesh.parent;
        }
        
        // Fallback: direct match
        return city.buildings.find(b => b.mesh === intersects[0].object) || null;
      }
      return null;
    }
    
    function raycastDistrictLabels() {
      interaction.raycaster.setFromCamera(interaction.mouse, camera);
      const sprites = getDistrictLabelSprites();
      const intersects = interaction.raycaster.intersectObjects(sprites, false);
      
      if (intersects.length > 0) {
        const sprite = intersects[0].object;
        const index = city.districtLabels.indexOf(sprite);
        if (index >= 0) {
          return DISTRICT_KEYS[index];
        }
      }
      return null;
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // HOVER EFFECTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function setHoveredBuilding(building) {
      // Unhover previous
      if (interaction.hoveredBuilding && interaction.hoveredBuilding !== building) {
        unhighlightBuilding(interaction.hoveredBuilding);
      }
      
      interaction.hoveredBuilding = building;
      
      if (building) {
        highlightBuilding(building, 'hover');
        canvas.classList.add('interactive-hover');
      } else {
        canvas.classList.remove('interactive-hover');
        hideTooltip();
      }
    }
    
    function highlightBuilding(building, mode = 'hover') {
      if (!building || !building.mesh || !building.mesh.material) return;
      
      const material = building.mesh.material;
      if (material.emissiveIntensity === undefined) return; // Not all materials have emissive
      
      // Store original values if not already stored
      if (building.originalEmissiveIntensity === undefined) {
        building.originalEmissiveIntensity = material.emissiveIntensity;
      }
      
      // Apply highlight
      if (mode === 'hover') {
        material.emissiveIntensity = (building.originalEmissiveIntensity || 0.5) + 0.4;
      } else if (mode === 'selected') {
        material.emissiveIntensity = (building.originalEmissiveIntensity || 0.5) + 0.7;
      }
    }
    
    function unhighlightBuilding(building) {
      if (!building || !building.mesh || !building.mesh.material) return;
      
      const material = building.mesh.material;
      
      // Restore original intensity
      if (building.originalEmissiveIntensity !== undefined) {
        material.emissiveIntensity = building.originalEmissiveIntensity;
      }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TOOLTIP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function showTooltip(building, x, y) {
      if (!building) return;
      
      const districtData = DISTRICTS[building.district] || DISTRICTS.core;
      const name = building.label || `${districtData.name} Structure`;
      
      tooltipEl.querySelector('.tooltip-name').textContent = name;
      tooltipEl.querySelector('.district-tag').textContent = districtData.name;
      
      // Position tooltip
      const padding = 15;
      let posX = x + padding;
      let posY = y + padding;
      
      // Keep within viewport
      const tooltipRect = tooltipEl.getBoundingClientRect();
      if (posX + 200 > window.innerWidth) {
        posX = x - 200 - padding;
      }
      if (posY + 60 > window.innerHeight) {
        posY = y - 60 - padding;
      }
      
      tooltipEl.style.left = posX + 'px';
      tooltipEl.style.top = posY + 'px';
      tooltipEl.classList.add('visible');
    }
    
    function hideTooltip() {
      tooltipEl.classList.remove('visible');
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INFO PANEL
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function selectBuilding(building) {
      // Deselect previous
      if (interaction.selectedBuilding && interaction.selectedBuilding !== building) {
        unhighlightBuilding(interaction.selectedBuilding);
      }
      
      interaction.selectedBuilding = building;
      
      if (building) {
        highlightBuilding(building, 'selected');
        showInfoPanel(building);
      } else {
        hideInfoPanel();
      }
    }
    
    function showInfoPanel(building) {
      if (!building) return;
      
      const districtData = DISTRICTS[building.district] || DISTRICTS.core;
      const name = building.label || `${districtData.name} Structure`;
      const type = building.type ? building.type.charAt(0).toUpperCase() + building.type.slice(1) : 'Building';
      
      infoPanelTitleEl.textContent = name;
      infoPanelDistrictEl.textContent = districtData.name;
      infoPanelDistrictEl.style.backgroundColor = `rgba(${Math.round(districtData.color.r * 255)}, ${Math.round(districtData.color.g * 255)}, ${Math.round(districtData.color.b * 255)}, 0.2)`;
      infoPanelDistrictEl.style.color = '#' + districtData.color.getHexString();
      infoPanelDistrictEl.style.borderColor = `rgba(${Math.round(districtData.color.r * 255)}, ${Math.round(districtData.color.g * 255)}, ${Math.round(districtData.color.b * 255)}, 0.4)`;
      
      infoPanelTypeEl.textContent = type;
      
      // Importance based on mentions (if available)
      const mentions = building.mentions || 0;
      const maxHeight = 60; // Max building height
      const importance = Math.min(100, Math.round((building.height / maxHeight) * 100));
      const importanceLabel = importance >= 80 ? 'â­ Landmark' : 
                              importance >= 50 ? 'ğŸ¢ Major' :
                              importance >= 25 ? 'ğŸ  Standard' : 'ğŸšï¸ Minor';
      infoPanelDimensionsEl.textContent = `${importanceLabel} (${importance}% importance)`;
      
      // Actual memory sources from building data
      const sources = building.sources || [];
      if (sources.length > 0) {
        infoPanelSourcesEl.innerHTML = sources.slice(0, 5).map(s => 
          `<span class="info-panel-source">${s}</span>`
        ).join('') + (sources.length > 5 ? `<span class="info-panel-source">+${sources.length - 5} more</span>` : '');
      } else {
        infoPanelSourcesEl.innerHTML = '<span class="info-panel-source">No sources</span>';
      }
      
      infoPanelEl.classList.add('visible');
    }
    
    function hideInfoPanel() {
      infoPanelEl.classList.remove('visible');
      if (interaction.selectedBuilding) {
        unhighlightBuilding(interaction.selectedBuilding);
        interaction.selectedBuilding = null;
      }
    }
    
    // Close button handler (click + touch for better mobile support)
    infoPanelCloseEl.addEventListener('click', hideInfoPanel);
    infoPanelCloseEl.addEventListener('touchend', (e) => {
      e.preventDefault();
      hideInfoPanel();
    });
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DISTRICT FOCUS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function focusDistrict(districtKey) {
      if (interaction.isAnimatingCamera) return;
      
      const districtData = DISTRICTS[districtKey];
      if (!districtData) return;
      
      // Store original camera state if not already stored
      if (!interaction.originalCameraPosition) {
        interaction.originalCameraPosition = camera.position.clone();
        interaction.originalControlsTarget = controls.target.clone();
      }
      
      interaction.focusedDistrict = districtKey;
      
      // Calculate target camera position
      const targetPos = districtData.position.clone();
      const cameraOffset = new THREE.Vector3(15, 20, 15);
      const targetCameraPos = targetPos.clone().add(cameraOffset);
      const targetLookAt = targetPos.clone().add(new THREE.Vector3(0, 8, 0));
      
      // Animate camera
      animateCamera(targetCameraPos, targetLookAt);
      
      // Fade other districts
      fadeOtherDistricts(districtKey, 0.3);
      
      // Show focus indicator
      focusDistrictNameEl.textContent = districtData.name;
      focusIndicatorEl.classList.add('visible');
      
      // Update controls hint
      if (controlsHintEl) {
        controlsHintEl.style.opacity = '0';
      }
    }
    
    function resetView() {
      if (interaction.isAnimatingCamera) return;
      if (!interaction.originalCameraPosition) return;
      
      interaction.focusedDistrict = null;
      
      // Animate back to original position
      animateCamera(
        interaction.originalCameraPosition.clone(),
        interaction.originalControlsTarget.clone()
      );
      
      // Restore all district visibility
      fadeOtherDistricts(null, 1);
      
      // Hide focus indicator
      focusIndicatorEl.classList.remove('visible');
      
      // Restore controls hint
      if (controlsHintEl) {
        controlsHintEl.style.opacity = '1';
      }
      
      // Clear stored positions
      interaction.originalCameraPosition = null;
      interaction.originalControlsTarget = null;
    }
    
    function animateCamera(targetPosition, targetLookAt) {
      interaction.isAnimatingCamera = true;
      
      const startPosition = camera.position.clone();
      const startTarget = controls.target.clone();
      const duration = 1000; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease out cubic
        const eased = 1 - Math.pow(1 - progress, 3);
        
        camera.position.lerpVectors(startPosition, targetPosition, eased);
        controls.target.lerpVectors(startTarget, targetLookAt, eased);
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          interaction.isAnimatingCamera = false;
        }
      }
      
      animate();
    }
    
    function fadeOtherDistricts(focusedKey, targetOpacity) {
      city.buildings.forEach(building => {
        if (!building.mesh || !building.mesh.material) return;
        
        const material = building.mesh.material;
        
        if (focusedKey && building.district !== focusedKey) {
          // Fade out non-focused buildings
          if (material.transparent === undefined || material.transparent === false) {
            material.transparent = true;
          }
          material.opacity = targetOpacity;
        } else {
          // Restore focused or all buildings
          material.opacity = 1;
        }
      });
      
      // Fade district labels
      city.districtLabels.forEach((label, index) => {
        const key = DISTRICT_KEYS[index];
        if (focusedKey && key !== focusedKey) {
          label.material.opacity = targetOpacity;
        } else {
          label.material.opacity = 0.8;
        }
      });
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // PAUSE/RESUME
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function togglePause() {
      interaction.isPaused = !interaction.isPaused;
      pauseIndicatorEl.classList.toggle('visible', interaction.isPaused);
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MOUSE EVENTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    let mouseDownTime = 0;
    let mouseDownPos = { x: 0, y: 0 };
    
    canvas.addEventListener('mousemove', (event) => {
      updateMousePosition(event);
      
      // Raycast for hover
      const hoveredBuilding = raycastBuildings();
      const hoveredDistrict = raycastDistrictLabels();
      
      if (hoveredBuilding) {
        setHoveredBuilding(hoveredBuilding);
        showTooltip(hoveredBuilding, event.clientX, event.clientY);
      } else if (hoveredDistrict) {
        canvas.classList.add('interactive-hover');
        hideTooltip();
        setHoveredBuilding(null);
      } else {
        setHoveredBuilding(null);
      }
    });
    
    canvas.addEventListener('mousedown', (event) => {
      mouseDownTime = Date.now();
      mouseDownPos = { x: event.clientX, y: event.clientY };
    });
    
    canvas.addEventListener('mouseup', (event) => {
      const elapsed = Date.now() - mouseDownTime;
      const distance = Math.hypot(event.clientX - mouseDownPos.x, event.clientY - mouseDownPos.y);
      
      // Only count as click if short duration and minimal movement
      if (elapsed < 300 && distance < 10) {
        handleClick(event);
      }
    });
    
    canvas.addEventListener('dblclick', (event) => {
      updateMousePosition(event);
      
      const hoveredDistrict = raycastDistrictLabels();
      if (hoveredDistrict) {
        focusDistrict(hoveredDistrict);
      } else if (interaction.focusedDistrict) {
        resetView();
      }
    });
    
    function handleClick(event) {
      updateMousePosition(event);
      
      const clickedBuilding = raycastBuildings();
      const clickedDistrict = raycastDistrictLabels();
      
      if (clickedBuilding) {
        selectBuilding(clickedBuilding);
      } else if (clickedDistrict) {
        focusDistrict(clickedDistrict);
      } else {
        // Clicked on empty space - close info panel if open
        if (interaction.selectedBuilding) {
          hideInfoPanel();
        }
      }
    }
    
    // Hide tooltip when leaving canvas
    canvas.addEventListener('mouseleave', () => {
      hideTooltip();
      setHoveredBuilding(null);
    });
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TOUCH EVENTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    canvas.addEventListener('touchstart', (event) => {
      if (event.touches.length !== 1) return;
      
      const touch = event.touches[0];
      interaction.touchStartTime = Date.now();
      interaction.touchStartPos = { x: touch.clientX, y: touch.clientY };
      
      // Setup long press detection
      interaction.longPressTimer = setTimeout(() => {
        // Long press - show info panel
        updateMousePosition(touch);
        const building = raycastBuildings();
        if (building) {
          selectBuilding(building);
        }
      }, 500);
    });
    
    canvas.addEventListener('touchmove', (event) => {
      // Cancel long press if finger moves
      if (interaction.longPressTimer) {
        const touch = event.touches[0];
        const distance = Math.hypot(
          touch.clientX - interaction.touchStartPos.x,
          touch.clientY - interaction.touchStartPos.y
        );
        if (distance > 10) {
          clearTimeout(interaction.longPressTimer);
          interaction.longPressTimer = null;
        }
      }
    });
    
    canvas.addEventListener('touchend', (event) => {
      clearTimeout(interaction.longPressTimer);
      interaction.longPressTimer = null;
      
      const elapsed = Date.now() - interaction.touchStartTime;
      const touch = event.changedTouches[0];
      const distance = Math.hypot(
        touch.clientX - interaction.touchStartPos.x,
        touch.clientY - interaction.touchStartPos.y
      );
      
      // Tap detection
      if (elapsed < 300 && distance < 15) {
        const now = Date.now();
        
        // Double tap detection
        if (now - interaction.lastTapTime < 300) {
          // Double tap - zoom to district or reset view
          updateMousePosition(touch);
          const district = raycastDistrictLabels();
          if (district) {
            focusDistrict(district);
          } else if (interaction.focusedDistrict) {
            resetView();
          }
        } else {
          // Single tap
          updateMousePosition(touch);
          const building = raycastBuildings();
          if (building) {
            selectBuilding(building);
          } else {
            hideInfoPanel();
          }
        }
        
        interaction.lastTapTime = now;
      }
    });
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // KEYBOARD CONTROLS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    document.addEventListener('keydown', (event) => {
      // Ignore if typing in an input
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
      
      const key = event.key.toLowerCase();
      
      // Number keys 1-5 for district focus
      if (key >= '1' && key <= '5') {
        const index = parseInt(key) - 1;
        if (DISTRICT_KEYS[index]) {
          focusDistrict(DISTRICT_KEYS[index]);
        }
        return;
      }
      
      // 0 or Escape to reset view
      if (key === '0' || key === 'escape') {
        if (interaction.focusedDistrict) {
          resetView();
        } else if (interaction.selectedBuilding) {
          hideInfoPanel();
        }
        return;
      }
      
      // Space to pause/resume animations
      if (key === ' ') {
        event.preventDefault();
        togglePause();
        return;
      }
      
      // Weather controls (consolidated from separate handler)
      if (key === 'r') {
        setWeather('rain');
        return;
      }
      if (key === 'f') {
        setWeather('fog');
        return;
      }
      // 'a' for aurora (but not if it conflicts with other shortcuts)
      if (key === 'a' && !event.ctrlKey && !event.metaKey) {
        setWeather('aurora');
        return;
      }
      if (key === 'c' && !event.ctrlKey && !event.metaKey) {
        setWeather('clear');
        return;
      }
      
      // Arrow keys for slow camera rotation
      const rotationSpeed = 0.02;
      if (key === 'arrowleft') {
        controls.autoRotate = false;
        const angle = rotationSpeed;
        const x = camera.position.x - controls.target.x;
        const z = camera.position.z - controls.target.z;
        camera.position.x = controls.target.x + x * Math.cos(angle) - z * Math.sin(angle);
        camera.position.z = controls.target.z + x * Math.sin(angle) + z * Math.cos(angle);
        return;
      }
      if (key === 'arrowright') {
        controls.autoRotate = false;
        const angle = -rotationSpeed;
        const x = camera.position.x - controls.target.x;
        const z = camera.position.z - controls.target.z;
        camera.position.x = controls.target.x + x * Math.cos(angle) - z * Math.sin(angle);
        camera.position.z = controls.target.z + x * Math.sin(angle) + z * Math.cos(angle);
        return;
      }
      if (key === 'arrowup') {
        const distance = camera.position.distanceTo(controls.target);
        if (distance > controls.minDistance + 5) {
          camera.position.lerp(controls.target, 0.05);
        }
        return;
      }
      if (key === 'arrowdown') {
        const distance = camera.position.distanceTo(controls.target);
        if (distance < controls.maxDistance - 5) {
          const direction = camera.position.clone().sub(controls.target).normalize();
          camera.position.add(direction.multiplyScalar(2));
        }
        return;
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANIMATION LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let frameCount = 0;
    let lastFpsTime = 0;
    let pausedTime = 0;
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      // Handle pause - freeze animation time but keep rendering
      let dt;
      if (interaction.isPaused) {
        if (pausedTime === 0) pausedTime = time;
        dt = pausedTime * 0.001;
      } else {
        if (pausedTime > 0) pausedTime = 0;
        dt = time * 0.001;
      }
      
      // FPS
      frameCount++;
      if (time - lastFpsTime > 1000) {
        fpsEl.textContent = `${frameCount} fps${interaction.isPaused ? ' (paused)' : ''}`;
        frameCount = 0;
        lastFpsTime = time;
      }
      
      controls.update();
      updateLighting();
      updateWeather(dt);
      
      // Sound system updates
      if (soundManager.enabled) {
        const now = new Date();
        const hours = now.getHours() + now.getMinutes() / 60;
        soundManager.updateTimePhase(hours, city.nightIntensity);
        soundManager.updateCameraDistance(camera.position.distanceTo(controls.target));
      }
      
      // Core animations - more vibrant at night
      if (city.coreRings) {
        const coreNightBoost = 1 + city.nightIntensity * 0.5;
        city.coreRings.forEach(ring => {
          if (ring.userData.rotationAxis === 'z') {
            ring.rotation.z += ring.userData.rotationSpeed * 0.01;
            ring.rotation.x = Math.PI / 2 + Math.sin(dt + ring.userData.wobble) * 0.1;
            ring.material.opacity = (0.5 + city.nightIntensity * 0.3) * coreNightBoost;
          } else if (ring.userData.rotationAxis === 'y') {
            ring.rotation.y += ring.userData.rotationSpeed * 0.01;
            ring.material.opacity = (0.4 + city.nightIntensity * 0.4) * coreNightBoost;
          } else if (ring.userData.beamPhase !== undefined) {
            const beamPulse = Math.sin(dt * 2 + ring.userData.beamPhase) * 0.15;
            ring.material.opacity = (0.15 + beamPulse + city.nightIntensity * 0.2) * coreNightBoost;
          } else if (ring.userData.pulseRing) {
            const scale = 1 + Math.sin(dt * 1.5 + ring.userData.pulsePhase) * 0.1;
            ring.scale.set(scale, scale, 1);
            ring.material.opacity = (0.25 + city.nightIntensity * 0.2) * coreNightBoost;
          }
        });
      }
      
      // Core glow pulse - heart of the city
      if (city.coreGlow) {
        const nightIntensity = 1 + city.nightIntensity * 0.4;
        const pulse = 1 + Math.sin(dt * 2) * 0.2 * nightIntensity;
        city.coreGlow.scale.set(pulse, pulse, pulse);
        city.coreGlow.material.opacity = (0.5 + Math.sin(dt * 3) * 0.2) * nightIntensity;
        
        // Color shifts slightly with time
        if (lighting.goldenHourIntensity > 0) {
          city.coreGlow.material.color.setHex(0x44ffcc); // Warm cyan
        } else if (city.nightIntensity > 0.5) {
          city.coreGlow.material.color.setHex(0x00ddff); // Cool cyan
        } else {
          city.coreGlow.material.color.setHex(0x00ffff); // Neutral cyan
        }
      }
      
      // Building effects with cinematic lighting response
      if (Math.floor(time) % 100 < 16) {
        // Golden hour surface glow factor
        const goldenGlow = lighting.goldenHourIntensity;
        const rimFactor = lighting.rimLightIntensity;
        const windowProgress = lighting.windowLightProgress;
        
        city.buildings.forEach((b, buildingIndex) => {
          if (b.mesh.material && b.mesh.material.emissive) {
            // Base emissive from district
            const districtData = DISTRICTS[b.district] || DISTRICTS.core;
            
            // Night boost for emissives
            const nightBoost = 0.5 + city.nightIntensity * 1.5;
            
            // Golden hour warm tint on surfaces
            if (goldenGlow > 0) {
              const warmTint = new THREE.Color(0xff9944).multiplyScalar(goldenGlow * 0.3);
              b.mesh.material.emissive.copy(districtData.emissive).add(warmTint);
            } else {
              b.mesh.material.emissive.copy(districtData.emissive);
            }
            
            b.mesh.material.emissiveIntensity = 0.4 * nightBoost;
            
            // Moonlight blue tint at night
            if (city.nightIntensity > 0.3) {
              const moonTint = new THREE.Color(0x2244aa).multiplyScalar(city.nightIntensity * 0.1);
              b.mesh.material.emissive.add(moonTint);
            }
          }
          
          // Animate child elements (windows, antennas, holograms)
          b.mesh.children.forEach((child, childIndex) => {
            // Antenna blink lights
            if (child.userData.blink) {
              const blinkSpeed = 3 + (buildingIndex % 3); // Varied speeds
              child.material.opacity = Math.sin(dt * blinkSpeed + child.userData.blinkPhase) > 0.7 ? 1 : 0.2;
            }
            
            // Beacon pulse
            if (child.userData.pulse) {
              const pulseIntensity = 0.2 + city.nightIntensity * 0.3;
              const p = 1 + Math.sin(dt * 2 + child.userData.pulsePhase) * pulseIntensity;
              child.scale.set(p, p, p);
            }
            
            // Window strips - gradual lighting response
            if (child.geometry && (child.geometry.type === 'BoxGeometry' || child.geometry.type === 'TorusGeometry')) {
              // Some windows are "always on" (odd indices), others respond to time
              const alwaysOn = childIndex % 3 === 0;
              const baseOpacity = alwaysOn ? 0.4 : 0.1;
              const nightOpacity = alwaysOn ? 0.8 : windowProgress * 0.7;
              
              // Slight flicker for realism
              const flicker = Math.random() > 0.98 ? 0.1 : 0;
              child.material.opacity = baseOpacity + nightOpacity + flicker;
              
              // Windows get warmer at night (interior glow)
              if (city.nightIntensity > 0.2 && child.material.color) {
                const warmth = city.nightIntensity * 0.2;
                child.material.color.setRGB(
                  1, 
                  0.9 - warmth * 0.1, 
                  0.7 - warmth * 0.3
                );
              }
            }
            
            // Holographic ads - much brighter at night
            if (child.userData.hologram) {
              const nightMultiplier = 1 + city.nightIntensity * 1.5;
              const baseFlicker = Math.sin(dt * 5 + child.userData.flickerPhase) * 0.15;
              const glitchChance = Math.random() > 0.97 ? -0.3 : 0;
              child.material.opacity = (0.25 + baseFlicker + glitchChance) * nightMultiplier;
              
              // Scanline children also brighten
              child.children.forEach(scanline => {
                if (scanline.material) {
                  scanline.material.opacity = 0.2 + city.nightIntensity * 0.4;
                }
              });
            }
          });
        });
      }
      
      // Connection pulse - brighter energy flow at night
      city.connections.forEach((conn, i) => {
        const baseSpeed = 2 + (i % 3) * 0.3; // Varied speeds
        const pulse = Math.sin(dt * baseSpeed + i * 0.5) * 0.12 + 0.2;
        const nightBoost = 1 + city.nightIntensity * 1.2;
        conn.line.material.opacity = pulse * nightBoost;
        
        // Shift connection color slightly warmer during golden hour
        if (lighting.goldenHourIntensity > 0) {
          const warmShift = lighting.goldenHourIntensity * 0.2;
          conn.line.material.color.setRGB(0 + warmShift, 1, 1 - warmShift * 0.5);
        } else {
          conn.line.material.color.setHex(0x00ffff);
        }
      });
      
      // District labels float - more visible at night, subtle during day
      city.districtLabels.forEach(label => {
        label.position.y = label.userData.baseY + Math.sin(dt * 0.5 + label.userData.floatPhase) * 1;
        // Fade based on time: subtle during bright day, prominent at night
        const dayFade = Math.max(0, 1 - city.nightIntensity * 0.5 - (1 - city.nightIntensity) * 0.4);
        label.material.opacity = 0.3 + dayFade * 0.2 + city.nightIntensity * 0.5;
      });
      
      // Drones
      updateDrones(dt);
      
      // Particles
      updateParticles();
      
      // Environment animations
      updateEnvironment(dt);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ACTIVITY VISUALIZATION UPDATES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Update district glow intensities (smooth transitions + heat map)
      updateDistrictGlows(dt);
      
      // Update core spire activity response
      updateCoreActivity(dt);
      
      // Update connection line activity (brightness + color)
      updateConnectionActivity(dt);
      
      // Update ripple effects
      updateActivityRipples();
      
      // Update data packets traveling on connections
      updateDataPackets(dt);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AMBIENT LIFE UPDATES - The city never sleeps (NYC vibes)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Traffic lights moving along roads
      updateTrafficLights(dt);
      
      // Elevators in tall buildings
      updateElevators(dt);
      
      // Fireflies (night) and dust motes (day)
      updateFirefliesAndDust(dt);
      
      // Data streams between connected buildings
      updateDataStreams(dt);
      
      // Aircraft and satellites
      updateAircraft(dt);
      
      // Shooting stars (occasional, night only)
      updateShootingStars();
      
      // Window activity (on/off, TV flicker)
      updateWindowActivity(dt);
      
      // District-specific building pulses
      updateDistrictPulses(dt);
      
      // City growth
      growCity();
      
      // Render with bloom
      composer.render();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RESIZE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEBSOCKET (Live Knowledge Connection)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const WS_URL = 'wss://itself-partners-integrate-memories.trycloudflare.com';
    let cityWebSocket = null;
    let districtGlowIntensities = {};
    let cityLoadedFromServer = false;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ACTIVITY VISUALIZATION STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const activityState = {
      mode: 'idle',                    // 'idle', 'thinking', 'responding'
      activeDistrict: null,            // Currently active district key
      activityStartTime: 0,            // When current activity started
      
      // Per-district activity tracking
      districtActivity: {},            // { district: { intensity: 0-1, lastActive: timestamp } }
      
      // Visual effect pools
      ripples: [],                     // Active ripple effects
      dataPackets: [],                 // Data packets traveling on connections
      
      // Core spire state
      corePulseRate: 1.0,              // Multiplier for core pulse speed
      coreEnergyDirection: 0,          // -1 inward, 0 neutral, 1 outward
      
      // Color themes by mode
      modeColors: {
        idle: { primary: 0x00ffff, secondary: 0x0088aa, glow: 0.3 },
        thinking: { primary: 0x00ddff, secondary: 0x0066cc, glow: 0.8 },
        responding: { primary: 0xffdd44, secondary: 0xffaa00, glow: 1.0 }
      }
    };
    
    // Initialize district activity tracking
    Object.keys(DISTRICTS).forEach(key => {
      activityState.districtActivity[key] = {
        intensity: 0.3,
        targetIntensity: 0.3,
        lastActive: 0,
        heatLevel: 0,          // Accumulates over time for "warmth map"
        pulsePhase: Math.random() * Math.PI * 2
      };
    });
    
    const API_URL = 'https://itself-partners-integrate-memories.trycloudflare.com';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ACTIVITY RIPPLE EFFECTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createActivityRipple(districtKey) {
      const district = DISTRICTS[districtKey];
      if (!district) return;
      
      // Limit maximum concurrent ripples to prevent memory issues
      if (activityState.ripples.length > 15) return;
      
      const rippleCount = 3;
      for (let i = 0; i < rippleCount; i++) {
        setTimeout(() => {
          // Create ring with fixed geometry - animate via scale
          const rippleGeo = new THREE.RingGeometry(0.8, 1, 32);
          const rippleMat = new THREE.MeshBasicMaterial({
            color: district.color.clone(),
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          });
          const ripple = new THREE.Mesh(rippleGeo, rippleMat);
          ripple.rotation.x = -Math.PI / 2;
          ripple.position.set(district.position.x, 0.2, district.position.z);
          ripple.scale.set(0.5, 0.5, 1); // Start small
          
          ripple.userData = {
            startTime: performance.now(),
            duration: 2000,
            maxScale: 25,
            districtColor: district.color.clone()
          };
          
          scene.add(ripple);
          activityState.ripples.push(ripple);
        }, i * 300);
      }
    }
    
    function updateActivityRipples() {
      const now = performance.now();
      
      for (let i = activityState.ripples.length - 1; i >= 0; i--) {
        const ripple = activityState.ripples[i];
        const elapsed = now - ripple.userData.startTime;
        const progress = elapsed / ripple.userData.duration;
        
        if (progress >= 1) {
          scene.remove(ripple);
          ripple.geometry.dispose();
          ripple.material.dispose();
          activityState.ripples.splice(i, 1);
          continue;
        }
        
        // Expand ring using scale (no geometry recreation)
        const scale = ripple.userData.maxScale * progress;
        
        // Add pulse effect
        const pulse = 1 + Math.sin(elapsed * 0.01) * 0.1;
        ripple.scale.set(scale * pulse, scale * pulse, 1);
        
        // Fade out with eased curve
        ripple.material.opacity = 0.8 * (1 - progress * progress);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA PACKETS ON CONNECTION LINES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDataPacket(fromBuilding, toBuilding, color) {
      // Limit max data packets to prevent memory issues
      if (activityState.dataPackets.length > 50) return;
      
      const packetGeo = new THREE.SphereGeometry(0.15, 6, 6);
      const packetMat = new THREE.MeshBasicMaterial({
        color: color || 0x00ffff,
        transparent: true,
        opacity: 0.9
      });
      const packet = new THREE.Mesh(packetGeo, packetMat);
      
      // Glow layer
      const glowGeo = new THREE.SphereGeometry(0.3, 6, 6);
      const glowMat = new THREE.MeshBasicMaterial({
        color: color || 0x00ffff,
        transparent: true,
        opacity: 0.4
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      packet.add(glow);
      
      packet.userData = {
        fromPos: new THREE.Vector3(fromBuilding.x, 1, fromBuilding.z),
        toPos: new THREE.Vector3(toBuilding.x, 1, toBuilding.z),
        progress: 0,
        speed: 0.5 + Math.random() * 0.3,
        startTime: performance.now()
      };
      
      // Calculate control point for curve
      const midX = (fromBuilding.x + toBuilding.x) / 2;
      const midZ = (fromBuilding.z + toBuilding.z) / 2;
      packet.userData.controlPoint = new THREE.Vector3(midX, 4 + Math.random() * 3, midZ);
      
      scene.add(packet);
      activityState.dataPackets.push(packet);
    }
    
    function spawnDataPacketsToDistrict(targetDistrict) {
      // Send packets from other districts toward the active one
      const targetPos = DISTRICTS[targetDistrict]?.position;
      if (!targetPos) return;
      
      city.connections.forEach(conn => {
        const fromDistrict = conn.from.district;
        const toDistrict = conn.to.district;
        
        // If connection involves target district, send packets toward it
        if (toDistrict === targetDistrict || fromDistrict === targetDistrict) {
          const color = DISTRICTS[targetDistrict].color.clone();
          
          // Direction toward target
          if (toDistrict === targetDistrict) {
            createDataPacket(conn.from, conn.to, color);
          } else {
            createDataPacket(conn.to, conn.from, color);
          }
        }
      });
    }
    
    function updateDataPackets(dt) {
      for (let i = activityState.dataPackets.length - 1; i >= 0; i--) {
        const packet = activityState.dataPackets[i];
        packet.userData.progress += 0.015 * packet.userData.speed;
        
        if (packet.userData.progress >= 1) {
          scene.remove(packet);
          packet.geometry.dispose();
          packet.material.dispose();
          activityState.dataPackets.splice(i, 1);
          continue;
        }
        
        // Quadratic bezier interpolation
        const t = packet.userData.progress;
        const t1 = 1 - t;
        const fromPos = packet.userData.fromPos;
        const toPos = packet.userData.toPos;
        const ctrlPos = packet.userData.controlPoint;
        
        packet.position.x = t1 * t1 * fromPos.x + 2 * t1 * t * ctrlPos.x + t * t * toPos.x;
        packet.position.y = t1 * t1 * fromPos.y + 2 * t1 * t * ctrlPos.y + t * t * toPos.y;
        packet.position.z = t1 * t1 * fromPos.z + 2 * t1 * t * ctrlPos.z + t * t * toPos.z;
        
        // Pulse effect
        const pulse = 1 + Math.sin(dt * 10 + i) * 0.2;
        packet.scale.setScalar(pulse);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT GLOW SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateDistrictGlows(dt) {
      const now = Date.now();
      
      Object.entries(activityState.districtActivity).forEach(([key, activity]) => {
        // Smooth intensity transitions
        const diff = activity.targetIntensity - activity.intensity;
        activity.intensity += diff * 0.05;
        
        // Decay heat level over time (warmth map)
        const timeSinceActive = (now - activity.lastActive) / 1000;
        if (timeSinceActive > 5) {
          activity.heatLevel = Math.max(0, activity.heatLevel - 0.001);
        }
        
        // Calculate effective glow (base + activity + heat)
        const baseGlow = 0.3;
        const activityGlow = activity.intensity * 0.7;
        const heatGlow = activity.heatLevel * 0.2;
        const effectiveGlow = baseGlow + activityGlow + heatGlow;
        
        // Update buildings in this district
        const districtBuildings = city.districts.get(key) || [];
        districtBuildings.forEach((building, idx) => {
          if (!building.mesh.material) return;
          
          const districtData = DISTRICTS[key];
          
          // Pulsing effect when active
          let pulseMultiplier = 1;
          if (activity.intensity > 0.5) {
            const pulseSpeed = 2 + activity.intensity * 2;
            pulseMultiplier = 1 + Math.sin(dt * pulseSpeed + activity.pulsePhase + idx * 0.3) * 0.15;
          }
          
          // Apply emissive intensity
          building.mesh.material.emissiveIntensity = effectiveGlow * pulseMultiplier * (1 + city.nightIntensity * 0.5);
          
          // Color saturation boost when highly active
          if (activity.intensity > 0.7) {
            const satBoost = (activity.intensity - 0.7) * 3;
            const boostedColor = districtData.emissive.clone();
            boostedColor.multiplyScalar(1 + satBoost);
            building.mesh.material.emissive.copy(boostedColor);
          }
          
          // Update window children to glow brighter
          building.mesh.children.forEach(child => {
            if (child.material && child.material.opacity !== undefined) {
              if (!child.userData.hologram && !child.userData.blink) {
                const windowBoost = activity.intensity > 0.5 ? 0.3 : 0;
                child.material.opacity = Math.min(1, child.material.opacity + windowBoost * pulseMultiplier);
              }
            }
          });
        });
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CORE SPIRE ACTIVITY RESPONSE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateCoreActivity(dt) {
      const mode = activityState.mode;
      const modeColor = activityState.modeColors[mode] || activityState.modeColors.idle;
      
      // Target states based on mode
      let targetPulseRate, targetEnergyDirection;
      
      switch (mode) {
        case 'thinking':
          targetPulseRate = 2.5;       // Faster pulse
          targetEnergyDirection = -1;  // Energy gathering inward
          break;
        case 'responding':
          targetPulseRate = 1.5;
          targetEnergyDirection = 1;   // Energy radiating outward
          break;
        default: // idle
          targetPulseRate = 1.0;
          targetEnergyDirection = 0;   // Neutral breathing
      }
      
      // Smooth transitions
      activityState.corePulseRate += (targetPulseRate - activityState.corePulseRate) * 0.02;
      activityState.coreEnergyDirection += (targetEnergyDirection - activityState.coreEnergyDirection) * 0.03;
      
      // Update core glow
      if (city.coreGlow) {
        const basePulse = 1 + Math.sin(dt * 2 * activityState.corePulseRate) * 0.3;
        const modeBoost = mode !== 'idle' ? 0.3 : 0;
        
        city.coreGlow.scale.setScalar(basePulse * (1 + modeBoost));
        city.coreGlow.material.opacity = 0.5 + modeBoost + Math.sin(dt * 3 * activityState.corePulseRate) * 0.2;
        
        // Color based on mode
        const targetColor = new THREE.Color(modeColor.primary);
        city.coreGlow.material.color.lerp(targetColor, 0.05);
      }
      
      // Update core rings
      city.coreRings.forEach((ring, i) => {
        if (ring.userData.rotationAxis) {
          // Rotation rings spin faster when active
          const speedMult = activityState.corePulseRate;
          if (ring.userData.rotationAxis === 'z') {
            ring.rotation.z += ring.userData.rotationSpeed * 0.01 * speedMult;
          } else if (ring.userData.rotationAxis === 'y') {
            ring.rotation.y += ring.userData.rotationSpeed * 0.01 * speedMult;
          }
          
          // Opacity based on activity
          const baseOpacity = 0.4 + (mode !== 'idle' ? 0.3 : 0);
          ring.material.opacity = baseOpacity + city.nightIntensity * 0.2;
          
          // Color shift
          ring.material.color.lerp(new THREE.Color(modeColor.primary), 0.03);
        }
        
        // Energy beams respond to direction
        if (ring.userData.beamPhase !== undefined) {
          const beamSpeed = 2 * activityState.corePulseRate;
          const directionOffset = activityState.coreEnergyDirection * dt * 2;
          const beamPulse = Math.sin(dt * beamSpeed + ring.userData.beamPhase + directionOffset) * 0.2;
          
          ring.material.opacity = 0.2 + beamPulse + (mode !== 'idle' ? 0.2 : 0);
          ring.material.color.lerp(new THREE.Color(modeColor.primary), 0.03);
          
          // Scale beams based on energy direction
          const scaleY = 1 + activityState.coreEnergyDirection * 0.3;
          ring.scale.y = scaleY;
        }
        
        // Floor pulse rings
        if (ring.userData.pulseRing) {
          const pulseSpeed = 1.5 * activityState.corePulseRate;
          const scale = 1 + Math.sin(dt * pulseSpeed + ring.userData.pulsePhase) * 0.15;
          
          // Expand outward when responding, contract when thinking
          const directionScale = 1 + activityState.coreEnergyDirection * 0.1 * Math.sin(dt * 2);
          ring.scale.set(scale * directionScale, scale * directionScale, 1);
          
          ring.material.opacity = 0.25 + (mode !== 'idle' ? 0.15 : 0);
          ring.material.color.lerp(new THREE.Color(modeColor.primary), 0.03);
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION LINE ACTIVITY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateConnectionActivity(dt) {
      const activeDistrict = activityState.activeDistrict;
      const mode = activityState.mode;
      
      city.connections.forEach((conn, i) => {
        const involvesActive = activeDistrict && 
          (conn.from.district === activeDistrict || conn.to.district === activeDistrict);
        
        // Base pulse
        const baseSpeed = 2 + (i % 3) * 0.3;
        let basePulse = Math.sin(dt * baseSpeed + i * 0.5) * 0.1 + 0.2;
        
        if (involvesActive && mode !== 'idle') {
          // Bright active connection
          basePulse += 0.4;
          
          // Color matches active district
          const districtColor = DISTRICTS[activeDistrict]?.color || new THREE.Color(0x00ffff);
          conn.line.material.color.lerp(districtColor, 0.1);
        } else {
          // Return to default cyan
          conn.line.material.color.lerp(new THREE.Color(0x00ffff), 0.02);
        }
        
        const nightBoost = 1 + city.nightIntensity * 0.8;
        conn.line.material.opacity = basePulse * nightBoost;
      });
    }
    
    // Try HTTP first (more reliable), then WebSocket for live updates
    async function loadCityFromAPI() {
      try {
        console.log('[API] Fetching city state from:', `${API_URL}/city-state`);
        const res = await fetch(`${API_URL}/city-state`);
        console.log('[API] Response status:', res.status);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const cityState = await res.json();
        console.log('[API] Parsed JSON, buildings:', cityState.buildings?.length);
        console.log('[API] First building:', JSON.stringify(cityState.buildings?.[0]));
        if (cityState.buildings && cityState.buildings.length > 0) {
          loadCityFromState(cityState);
          return true;
        } else {
          console.error('[API] No buildings in response');
          return false;
        }
      } catch (err) {
        console.error('[API] Failed:', err.message, err);
        return false;
      }
    }
    
    function connectKnowledge() {
      cityWebSocket = new WebSocket(WS_URL);
      
      cityWebSocket.onopen = () => {
        console.log('[WS] Connected to knowledge engine');
        // Don't request city state - we already loaded via HTTP
      };
      
      cityWebSocket.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          
          // Live updates if city changes
          if (msg.type === 'city:state' && msg.city) {
            console.log('[WS] City update:', msg.city.buildings?.length, 'buildings');
            loadCityFromState(msg.city);
          }
          
          if (msg.type === 'state') {
            handleCognitiveState(msg.mode, msg.message);
          }
          
          if (msg.type === 'graph:full') {
            console.log('[WS] Received knowledge graph:', msg.graph?.nodes?.length, 'nodes');
          }
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };
      
      cityWebSocket.onclose = () => {
        console.log('[WS] Disconnected, reconnecting...');
        setTimeout(connectKnowledge, 5000);
      };
      cityWebSocket.onerror = () => cityWebSocket.close();
    }
    
    /**
     * Load city buildings from server state
     */
    let isLoadingCity = false; // Prevent race conditions
    
    function loadCityFromState(cityState) {
      // Prevent concurrent loads (race condition fix)
      if (isLoadingCity) {
        console.log('[LoadCity] Already loading, skipping');
        return;
      }
      
      console.log('[LoadCity] Called with', cityState?.buildings?.length, 'buildings');
      if (!cityState.buildings || cityState.buildings.length === 0) {
        console.log('[City] No buildings in state');
        return;
      }
      
      isLoadingCity = true;
      cityLoadedFromServer = true;
      console.log('[LoadCity] Creating buildings...');
      
      // Clean up memory before removing buildings (memory leak fix)
      while (city.buildings.length > 1) {
        const b = city.buildings.pop();
        
        // Clean up windowStates for this building
        if (city.windowStates.has(b)) {
          city.windowStates.delete(b);
        }
        
        // Clean up elevators attached to this building
        if (b.mesh) {
          b.mesh.children.forEach(child => {
            if (child.userData && child.userData.isElevator) {
              const idx = city.elevators.indexOf(child);
              if (idx > -1) city.elevators.splice(idx, 1);
            }
          });
        }
        
        // Dispose geometry and materials
        if (b.mesh) {
          if (b.mesh.geometry) b.mesh.geometry.dispose();
          if (b.mesh.material) {
            if (Array.isArray(b.mesh.material)) {
              b.mesh.material.forEach(m => m.dispose());
            } else {
              b.mesh.material.dispose();
            }
          }
          scene.remove(b.mesh);
        }
      }
      
      // Clean up connections and their data streams
      city.connections.forEach(c => {
        scene.remove(c.line);
        if (c.line.geometry) c.line.geometry.dispose();
        if (c.line.material) c.line.material.dispose();
      });
      city.connections = [];
      
      // Clean up data streams
      city.dataStreams.forEach(stream => {
        scene.remove(stream);
        if (stream.geometry) stream.geometry.dispose();
        if (stream.material) stream.material.dispose();
      });
      city.dataStreams = [];
      
      // Reset districts, keep core
      city.districts.clear();
      if (city.buildings.length > 0) {
        city.districts.set('core', [city.buildings[0]]);
      }
      
      // Create buildings from state
      console.log('[LoadCity] Iterating', cityState.buildings.length, 'building specs');
      let created = 0;
      for (const spec of cityState.buildings) {
        try {
          createBuilding({
            x: spec.x,
            z: spec.z,
            width: spec.width || 2.5,
            depth: spec.depth || 2.5,
            height: spec.height,
            district: spec.district,
            label: spec.label
          });
          created++;
        } catch (err) {
          console.error('[LoadCity] Failed to create building:', spec.label, err);
        }
      }
      console.log('[LoadCity] Created', created, 'buildings');
      
      // Create connections from state (O(n) instead of O(nÂ²))
      if (cityState.connections) {
        // Build position-based lookup map once
        const posKey = (x, z) => `${Math.round(x * 2)},${Math.round(z * 2)}`;
        const posToBuilding = new Map();
        city.buildings.forEach(b => {
          posToBuilding.set(posKey(b.x, b.z), b);
        });
        
        const idToBuilding = new Map();
        cityState.buildings.forEach((spec) => {
          const b = posToBuilding.get(posKey(spec.x, spec.z));
          if (b) idToBuilding.set(spec.id, b);
        });
        
        for (const conn of cityState.connections) {
          const fromB = idToBuilding.get(conn.from);
          const toB = idToBuilding.get(conn.to);
          if (fromB && toB) {
            createConnection(fromB, toB);
          }
        }
      }
      
      // Set district activity
      if (cityState.districtActivity) {
        districtGlowIntensities = { ...cityState.districtActivity };
      }
      
      console.log(`[City] Loaded ${city.buildings.length} buildings from knowledge`);
      updateStats();
      isLoadingCity = false;
    }
    
    // Pre-compiled keyword regexes for performance (avoid creating in tight loop)
    const districtKeywords = {
      trading: ['stock', 'trading', 'market', 'ticker', 'price', 'portfolio', 'scan', 'asymmetry', 'options', 'calls', 'puts'],
      infrastructure: ['server', 'deploy', 'api', 'docker', 'tunnel', 'pm2', 'cloudflare', 'coolify', 'tailscale', 'ssh'],
      projects: ['project', 'build', 'app', 'visualization', 'face', 'city', 'mind', 'code', 'create', 'develop'],
      memory: ['memory', 'remember', 'decision', 'note', 'log', 'history', 'learned', 'preference'],
      core: ['self', 'absalom', 'knowledge', 'engine', 'think', 'process', 'identity', 'soul']
    };
    
    // Pre-compile regex patterns for exact word matching
    const districtKeywordRegexes = {};
    for (const [district, keywords] of Object.entries(districtKeywords)) {
      districtKeywordRegexes[district] = keywords.map(kw => ({
        keyword: kw,
        regex: new RegExp(`\\b${kw}\\b`, 'i')
      }));
    }
    
    /**
     * Handle cognitive state changes - district glow mapping with full visual feedback
     */
    function handleCognitiveState(mode, message = '') {
      const prevMode = activityState.mode;
      const prevDistrict = activityState.activeDistrict;
      
      // Update mode
      activityState.mode = mode || 'idle';
      activityState.activityStartTime = Date.now();
      
      const lower = (message || '').toLowerCase();
      let detectedDistrict = null;
      let highestScore = 0;
      
      // Score each district based on keyword matches (using pre-compiled regexes)
      for (const [district, keywordData] of Object.entries(districtKeywordRegexes)) {
        let score = 0;
        for (const { keyword, regex } of keywordData) {
          if (lower.includes(keyword)) {
            score += 1;
            // Bonus for exact word match (using pre-compiled regex)
            if (regex.test(lower)) score += 0.5;
          }
        }
        if (score > highestScore) {
          highestScore = score;
          detectedDistrict = district;
        }
      }
      
      // Default to core if thinking/responding with no clear district
      if (!detectedDistrict && (mode === 'thinking' || mode === 'responding')) {
        detectedDistrict = 'core';
      }
      
      activityState.activeDistrict = detectedDistrict;
      
      // Reset target intensities
      Object.keys(activityState.districtActivity).forEach(key => {
        activityState.districtActivity[key].targetIntensity = 0.3;
      });
      
      // Set activity levels based on mode
      if (mode === 'thinking' || mode === 'responding') {
        // Core always active when processing
        activityState.districtActivity['core'].targetIntensity = 0.8;
        activityState.districtActivity['core'].lastActive = Date.now();
        activityState.districtActivity['core'].heatLevel = Math.min(1, 
          activityState.districtActivity['core'].heatLevel + 0.1);
        
        // Primary active district gets full intensity
        if (detectedDistrict) {
          activityState.districtActivity[detectedDistrict].targetIntensity = 1.0;
          activityState.districtActivity[detectedDistrict].lastActive = Date.now();
          activityState.districtActivity[detectedDistrict].heatLevel = Math.min(1,
            activityState.districtActivity[detectedDistrict].heatLevel + 0.15);
          
          // Secondary districts get partial boost based on keyword matches
          for (const [district, keywords] of Object.entries(districtKeywords)) {
            if (district === detectedDistrict) continue;
            for (const kw of keywords) {
              if (lower.includes(kw)) {
                activityState.districtActivity[district].targetIntensity = 
                  Math.max(activityState.districtActivity[district].targetIntensity, 0.5);
                activityState.districtActivity[district].heatLevel = Math.min(1,
                  activityState.districtActivity[district].heatLevel + 0.05);
                break;
              }
            }
          }
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TRIGGER VISUAL EFFECTS ON STATE CHANGE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Ripple effect when entering active state
      if (mode !== 'idle' && (prevMode === 'idle' || detectedDistrict !== prevDistrict)) {
        if (detectedDistrict) {
          createActivityRipple(detectedDistrict);
        }
        // Always ripple from core when becoming active
        if (detectedDistrict !== 'core') {
          createActivityRipple('core');
        }
      }
      
      // Spawn data packets flowing toward active district
      if (mode !== 'idle' && detectedDistrict) {
        spawnDataPacketsToDistrict(detectedDistrict);
        
        // Periodic packet spawning during activity
        if (!activityState.packetInterval) {
          activityState.packetInterval = setInterval(() => {
            if (activityState.mode !== 'idle' && activityState.activeDistrict) {
              spawnDataPacketsToDistrict(activityState.activeDistrict);
            }
          }, 1500);
        }
      }
      
      // Clear packet interval when going idle
      if (mode === 'idle' && activityState.packetInterval) {
        clearInterval(activityState.packetInterval);
        activityState.packetInterval = null;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SOUND INTEGRATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      soundManager.updateCognitiveState(mode, message);
      
      // Play district activation sound when district changes
      if (detectedDistrict && detectedDistrict !== prevDistrict && mode !== 'idle') {
        soundManager.playDistrictActivation(detectedDistrict);
      }
      
      // Log state change for debugging
      console.log(`[Cognitive] Mode: ${mode} | District: ${detectedDistrict || 'none'} | Message preview: "${(message || '').slice(0, 50)}..."`);
      
      // Legacy compatibility - update old districtGlowIntensities
      Object.keys(DISTRICTS).forEach(key => {
        districtGlowIntensities[key] = activityState.districtActivity[key].targetIntensity;
      });
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // UPDATE HUD INDICATOR
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const indicatorEl = document.getElementById('cognitiveIndicator');
      const modeEl = document.getElementById('cognitiveMode');
      const districtEl = document.getElementById('cognitiveDistrict');
      const dotEl = document.getElementById('activityDot');
      
      if (indicatorEl && modeEl && districtEl && dotEl) {
        // Update indicator class
        indicatorEl.className = 'cognitive-indicator ' + mode;
        
        // Update mode text and styling
        modeEl.className = 'cognitive-mode ' + mode;
        modeEl.innerHTML = `<span class="activity-dot ${mode} ${mode !== 'idle' ? 'active' : ''}" id="activityDot"></span>${mode}`;
        
        // Update district display
        if (detectedDistrict && DISTRICTS[detectedDistrict]) {
          districtEl.textContent = DISTRICTS[detectedDistrict].name;
          districtEl.style.color = '#' + DISTRICTS[detectedDistrict].color.getHexString();
        } else {
          districtEl.textContent = 'â€”';
          districtEl.style.color = 'rgba(255,255,255,0.5)';
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    createSkyDome();
    createCelestialBodies();
    createStarfield();
    createGround();
    createEnvironment();
    createLighting();
    createDistrictLabels();
    createDrones();
    createParticles();
    
    // Ambient life systems
    createTrafficLights();
    createFirefliesAndDust();
    createAircraft();
    
    // Create core spire first (always present)
    createCoreSpire();
    city.districts.set('core', [city.buildings[0]]);
    
    // Load city from HTTP API first (reliable), then connect WebSocket for live updates
    loadCityFromAPI().then(success => {
      if (!success) {
        console.log('[City] API failed, using seed fallback');
        seedCityFallback();
      }
      // Connect WebSocket for live cognitive state updates
      connectKnowledge();
    });
    
    animate(0);
    
    console.log('Absalom City â€” A Mind Made Manifest (Knowledge-Powered Edition)');
    console.log(`Quality: ${qualityLevel} | Mobile: ${isMobile}`);
    
    /**
     * Fallback seeding when WebSocket unavailable
     */
    function seedCityFallback() {
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        if (key === 'core') return;
        const pos = district.position;
        
        createBuilding({
          x: pos.x,
          z: pos.z,
          height: 18 + Math.random() * 12,
          width: 4 + Math.random() * 2,
          depth: 4 + Math.random() * 2,
          district: key,
          label: `${district.name} Hub`,
          type: Math.random() > 0.5 ? 'tapered' : 'tower',
        });
        
        const buildingCount = isMobile ? 4 : 6;
        for (let i = 0; i < buildingCount; i++) {
          const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.5;
          const radius = 6 + Math.random() * 8;
          createBuilding({
            x: pos.x + Math.cos(angle) * radius,
            z: pos.z + Math.sin(angle) * radius,
            height: 5 + Math.random() * 15,
            district: key,
          });
        }
      });
      
      // Connect districts to core
      const districtKeys = Object.keys(DISTRICTS).filter(k => k !== 'core');
      districtKeys.forEach(key => {
        const districtBuildings = city.districts.get(key) || [];
        if (districtBuildings.length > 0) {
          createConnection(city.buildings[0], districtBuildings[0]);
        }
      });
      
      updateStats();
    }
  </script>
</body>
</html>
