<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
  <title>Absalom â€” City of Mind</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; height: 100%; 
      overflow: hidden; 
      background: #0a0a12;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif;
    }
    #canvas { display: block; }
    
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      pointer-events: none;
    }
    .city-stats {
      background: rgba(10, 10, 20, 0.8);
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      backdrop-filter: blur(10px);
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-bottom: 4px;
    }
    .stat-label { color: rgba(100, 200, 255, 0.6); }
    .stat-value { color: rgba(100, 200, 255, 1); font-weight: 500; }
    #fps { opacity: 0.5; font-size: 10px; margin-top: 8px; }
    
    .time-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.5);
      font-size: 11px;
      text-align: right;
    }
    
    .cognitive-indicator {
      position: fixed;
      bottom: 60px;
      left: 20px;
      z-index: 100;
      padding: 10px 14px;
      background: rgba(10, 10, 20, 0.85);
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      backdrop-filter: blur(10px);
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      transition: all 0.3s ease;
    }
    .cognitive-indicator.thinking {
      border-color: rgba(0, 200, 255, 0.6);
      box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
    }
    .cognitive-indicator.responding {
      border-color: rgba(255, 200, 0, 0.6);
      box-shadow: 0 0 20px rgba(255, 200, 0, 0.3);
    }
    .cognitive-mode {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: rgba(100, 200, 255, 0.6);
      margin-bottom: 4px;
    }
    .cognitive-mode.thinking { color: rgba(0, 200, 255, 0.9); }
    .cognitive-mode.responding { color: rgba(255, 200, 0, 0.9); }
    .cognitive-district {
      font-size: 13px;
      font-weight: 500;
      color: rgba(255,255,255,0.9);
    }
    .activity-dot {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-right: 6px;
      background: rgba(100, 200, 255, 0.5);
      animation: none;
    }
    .activity-dot.active {
      animation: pulse-dot 1s ease-in-out infinite;
    }
    .activity-dot.thinking { background: rgba(0, 200, 255, 1); }
    .activity-dot.responding { background: rgba(255, 200, 0, 1); }
    
    @keyframes pulse-dot {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.7; }
    }
    
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: rgba(255,255,255,0.3);
      font-size: 11px;
      text-align: center;
    }
    
    /* Sound controls */
    .sound-indicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      gap: 8px;
    }
    .sound-btn {
      background: rgba(10, 10, 20, 0.8);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 6px;
      color: rgba(100, 200, 255, 0.7);
      font-size: 11px;
      padding: 6px 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.2s;
      pointer-events: auto;
    }
    .sound-btn:hover {
      border-color: rgba(100, 200, 255, 0.6);
      color: rgba(100, 200, 255, 1);
    }
    .sound-btn.active {
      background: rgba(0, 255, 255, 0.15);
      border-color: rgba(0, 255, 255, 0.5);
    }
    .sound-btn.muted {
      opacity: 0.5;
    }
    
    .weather-indicator {
      position: fixed;
      top: 60px;
      right: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.5);
      font-size: 11px;
      text-align: right;
    }
    .weather-indicator .weather-state {
      color: rgba(100, 200, 255, 0.8);
      font-weight: 500;
    }
    
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       INTERACTIVE UI ELEMENTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    
    /* Tooltip for hover */
    .tooltip {
      position: fixed;
      padding: 8px 12px;
      background: rgba(10, 15, 25, 0.95);
      border: 1px solid rgba(100, 200, 255, 0.4);
      border-radius: 6px;
      color: rgba(100, 200, 255, 1);
      font-size: 12px;
      font-weight: 500;
      pointer-events: none;
      z-index: 200;
      opacity: 0;
      transform: translateY(5px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      backdrop-filter: blur(10px);
      white-space: nowrap;
      max-width: 200px;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    .tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .tooltip .district-tag {
      font-size: 10px;
      opacity: 0.6;
      margin-top: 2px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Info Panel */
    .info-panel {
      position: fixed;
      top: 50%;
      right: -320px;
      transform: translateY(-50%);
      width: 280px;
      background: rgba(10, 15, 25, 0.95);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-right: none;
      border-radius: 12px 0 0 12px;
      padding: 20px;
      z-index: 150;
      transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(15px);
      box-shadow: -5px 0 30px rgba(0, 0, 0, 0.5);
    }
    .info-panel.visible {
      right: 0;
    }
    .info-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
    }
    .info-panel-title {
      color: rgba(100, 200, 255, 1);
      font-size: 16px;
      font-weight: 600;
      line-height: 1.3;
      flex: 1;
      margin-right: 10px;
    }
    .info-panel-close {
      width: 28px;
      height: 28px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 50%;
      background: transparent;
      color: rgba(100, 200, 255, 0.7);
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }
    .info-panel-close:hover {
      background: rgba(100, 200, 255, 0.1);
      color: rgba(100, 200, 255, 1);
      border-color: rgba(100, 200, 255, 0.5);
    }
    .info-panel-district {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
    }
    .info-panel-section {
      margin-bottom: 14px;
    }
    .info-panel-label {
      color: rgba(100, 200, 255, 0.5);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }
    .info-panel-value {
      color: rgba(255, 255, 255, 0.9);
      font-size: 13px;
    }
    .info-panel-sources {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }
    .info-panel-source {
      padding: 4px 8px;
      background: rgba(100, 200, 255, 0.1);
      border: 1px solid rgba(100, 200, 255, 0.2);
      border-radius: 4px;
      font-size: 10px;
      color: rgba(100, 200, 255, 0.8);
    }
    .info-panel-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(100, 200, 255, 0.3), transparent);
      margin: 16px 0;
    }
    
    /* Focus mode indicator */
    .focus-indicator {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(10, 15, 25, 0.9);
      border: 1px solid rgba(100, 200, 255, 0.4);
      border-radius: 20px;
      color: rgba(100, 200, 255, 1);
      font-size: 12px;
      font-weight: 500;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(10px);
    }
    .focus-indicator.visible {
      opacity: 1;
    }
    .focus-indicator span {
      opacity: 0.6;
      margin-left: 8px;
    }
    
    /* Pause indicator */
    .pause-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 32px;
      background: rgba(10, 15, 25, 0.95);
      border: 2px solid rgba(100, 200, 255, 0.5);
      border-radius: 12px;
      color: rgba(100, 200, 255, 1);
      font-size: 18px;
      font-weight: 600;
      z-index: 300;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .pause-indicator.visible {
      opacity: 1;
    }
    
    /* Interactive cursor states */
    canvas.interactive-hover {
      cursor: pointer;
    }
    canvas.interactive-grabbing {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="hud">
    <div class="city-stats">
      <div class="stat-row">
        <span class="stat-label">structures</span>
        <span class="stat-value" id="buildingCount">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">districts</span>
        <span class="stat-value" id="districtCount">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">connections</span>
        <span class="stat-value" id="connectionCount">0</span>
      </div>
      <div class="stat-row" id="agentRow" style="display: none;">
        <span class="stat-label">agents</span>
        <span class="stat-value" id="agentCount">0</span>
      </div>
      <div id="fps"></div>
    </div>
  </div>
  
  <div class="time-indicator">
    <div id="timeDisplay">--:--</div>
    <div id="cyclePhase">dawn</div>
  </div>
  
  <div class="controls-hint">
    drag to orbit Â· scroll to zoom Â· click to select Â· 1-5 districts Â· 0/ESC reset Â· SPACE pause Â· arrows rotate<br>
    <span style="opacity: 0.6">weather: R rain Â· F fog Â· A aurora Â· C clear Â· W auto-cycle Â· L lightning</span>
  </div>
  
  <div class="cognitive-indicator" id="cognitiveIndicator">
    <div class="cognitive-mode" id="cognitiveMode">
      <span class="activity-dot" id="activityDot"></span>idle
    </div>
    <div class="cognitive-district" id="cognitiveDistrict">â€”</div>
  </div>
  
  <div class="weather-indicator">
    <div>weather: <span class="weather-state" id="weatherState">clear</span></div>
  </div>
  
  <div class="sound-indicator">
    <button class="sound-btn" id="soundToggle" title="Toggle Sound (S)">ğŸ”‡ Off</button>
    <button class="sound-btn" id="muteToggle" title="Mute (M)" style="display:none;">ğŸ”Š</button>
  </div>
  
  <!-- Interactive UI Elements -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-name"></div>
    <div class="district-tag"></div>
  </div>
  
  <div class="info-panel" id="infoPanel">
    <div class="info-panel-header">
      <div class="info-panel-title" id="infoPanelTitle">Building Name</div>
      <button class="info-panel-close" id="infoPanelClose">Ã—</button>
    </div>
    <div class="info-panel-district" id="infoPanelDistrict">DISTRICT</div>
    <div class="info-panel-divider"></div>
    <div class="info-panel-section">
      <div class="info-panel-label">Type</div>
      <div class="info-panel-value" id="infoPanelType">Structure</div>
    </div>
    <div class="info-panel-section">
      <div class="info-panel-label">Dimensions</div>
      <div class="info-panel-value" id="infoPanelDimensions">--</div>
    </div>
    <div class="info-panel-section">
      <div class="info-panel-label">Memory Sources</div>
      <div class="info-panel-sources" id="infoPanelSources"></div>
    </div>
  </div>
  
  <div class="focus-indicator" id="focusIndicator">
    <span id="focusDistrictName">DISTRICT</span>
    <span>(0 or ESC to exit)</span>
  </div>
  
  <div class="pause-indicator" id="pauseIndicator">â¸ PAUSED</div>

  <!-- Three.js with post-processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ABSALOM CITY â€” A Mind Made Manifest (Cyberpunk Utopia Edition)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const canvas = document.getElementById('canvas');
    const buildingCountEl = document.getElementById('buildingCount');
    const districtCountEl = document.getElementById('districtCount');
    const connectionCountEl = document.getElementById('connectionCount');
    const fpsEl = document.getElementById('fps');
    const timeDisplayEl = document.getElementById('timeDisplay');
    const cyclePhaseEl = document.getElementById('cyclePhase');
    
    // Performance detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const qualityLevel = isMobile ? 'low' : 'high';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a15, 0.006);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(50, 60, 80); // Pulled back for wider city view
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: !isMobile,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    renderer.shadowMap.enabled = !isMobile;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    
    // Post-processing: Full AAA Pipeline
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    // 1. BLOOM - Enhanced for that cyberpunk glow
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      isMobile ? 1.0 : 1.5,  // strength - INCREASED for more glow
      0.5,                    // radius - slightly wider
      0.7                     // threshold - lower = more things glow
    );
    composer.addPass(bloomPass);
    
    // 2. CHROMATIC ABERRATION - Subtle color fringing at edges (cyberpunk look)
    const ChromaticAberrationShader = {
      uniforms: {
        tDiffuse: { value: null },
        amount: { value: isMobile ? 0.0015 : 0.002 },
        angle: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;
        
        void main() {
          vec2 offset = amount * vec2(cos(angle), sin(angle));
          vec2 center = vec2(0.5);
          vec2 dir = vUv - center;
          float dist = length(dir);
          
          // Increase aberration toward edges
          vec2 aberration = offset * dist * dist;
          
          vec4 cr = texture2D(tDiffuse, vUv + aberration);
          vec4 cg = texture2D(tDiffuse, vUv);
          vec4 cb = texture2D(tDiffuse, vUv - aberration);
          
          gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
      `
    };
    const chromaPass = new THREE.ShaderPass(ChromaticAberrationShader);
    if (!isMobile) composer.addPass(chromaPass);
    
    // 3. VIGNETTE - Cinematic darkening at edges
    const VignetteShader = {
      uniforms: {
        tDiffuse: { value: null },
        darkness: { value: isMobile ? 0.4 : 0.6 },
        offset: { value: 1.2 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float darkness;
        uniform float offset;
        varying vec2 vUv;
        
        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          
          // Vignette calculation
          vec2 uv = (vUv - vec2(0.5)) * vec2(offset);
          float vignette = 1.0 - dot(uv, uv);
          vignette = clamp(pow(vignette, darkness), 0.0, 1.0);
          
          // Subtle blue tint in dark areas (night feel)
          vec3 vignetteColor = mix(vec3(0.02, 0.04, 0.08), texel.rgb, vignette);
          
          gl_FragColor = vec4(vignetteColor, texel.a);
        }
      `
    };
    const vignettePass = new THREE.ShaderPass(VignetteShader);
    composer.addPass(vignettePass);
    
    // 4. GOD RAYS (Volumetric Light Scattering) - AAA quality light beams
    const GodRaysShader = {
      uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.2 },
        decay: { value: 0.95 },
        density: { value: 0.8 },
        weight: { value: 0.4 },
        samples: { value: isMobile ? 30 : 60 },
        lightIntensity: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPosition;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform int samples;
        uniform float lightIntensity;
        varying vec2 vUv;
        
        void main() {
          vec4 texColor = texture2D(tDiffuse, vUv);
          
          if (lightIntensity < 0.01) {
            gl_FragColor = texColor;
            return;
          }
          
          vec2 deltaTextCoord = vUv - lightPosition;
          deltaTextCoord *= 1.0 / float(samples) * density;
          
          vec2 coord = vUv;
          float illuminationDecay = 1.0;
          vec4 color = vec4(0.0);
          
          for (int i = 0; i < 60; i++) {
            if (i >= samples) break;
            coord -= deltaTextCoord;
            vec4 texSample = texture2D(tDiffuse, coord);
            
            // Extract bright areas only
            float luminance = dot(texSample.rgb, vec3(0.299, 0.587, 0.114));
            texSample *= smoothstep(0.6, 1.0, luminance);
            
            texSample *= illuminationDecay * weight;
            color += texSample;
            illuminationDecay *= decay;
          }
          
          color *= exposure * lightIntensity;
          color = clamp(color, 0.0, 1.0);
          
          gl_FragColor = texColor + color;
        }
      `
    };
    const godRaysPass = new THREE.ShaderPass(GodRaysShader);
    if (!isMobile) composer.addPass(godRaysPass);
    
    // 5. FILM GRAIN - Subtle noise for cinematic quality
    const FilmGrainShader = {
      uniforms: {
        tDiffuse: { value: null },
        time: { value: 0 },
        intensity: { value: isMobile ? 0.02 : 0.035 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        varying vec2 vUv;
        
        float random(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // Animated film grain
          float grain = random(vUv + time * 0.001) * intensity;
          
          // Apply grain more in darker areas, less in highlights
          float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          grain *= (1.0 - luminance * 0.5);
          
          color.rgb += grain - intensity * 0.5;
          
          gl_FragColor = color;
        }
      `
    };
    const filmGrainPass = new THREE.ShaderPass(FilmGrainShader);
    if (!isMobile) composer.addPass(filmGrainPass);
    
    // Store passes for dynamic updates
    const postProcessing = {
      chromaPass: isMobile ? null : chromaPass,
      vignettePass,
      filmGrainPass: isMobile ? null : filmGrainPass,
      bloomPass,
      godRaysPass: isMobile ? null : godRaysPass
    };
    
    // Orbit controls
    const controls = new THREE.OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 10;
    controls.maxDistance = 250; // Increased for wider city layout
    controls.target.set(0, 5, 0);
    
    // Zoom sound trigger
    let lastZoomDistance = camera.position.distanceTo(controls.target);
    let zoomSoundThrottle = 0;
    canvas.addEventListener('wheel', (e) => {
      const now = Date.now();
      if (now - zoomSoundThrottle < 200) return; // Throttle
      
      const currentDistance = camera.position.distanceTo(controls.target);
      const delta = currentDistance - lastZoomDistance;
      
      if (Math.abs(delta) > 2) {
        soundManager.playZoomSound(delta < 0); // Zooming in = negative delta
        zoomSoundThrottle = now;
      }
      lastZoomDistance = currentDistance;
    }, { passive: true });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT DEFINITIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const DISTRICTS = {
      core: { 
        name: 'NEXUS CORE', 
        color: new THREE.Color(0x00ffff),
        emissive: new THREE.Color(0x003344),
        position: new THREE.Vector3(0, 0, 0),
        keywords: ['self', 'identity', 'soul', 'absalom']
      },
      trading: { 
        name: 'TRADING MIND', 
        color: new THREE.Color(0xffd700),
        emissive: new THREE.Color(0x332200),
        position: new THREE.Vector3(50, 0, 25),
        keywords: ['stock', 'trading', 'market', 'options', 'scanner', 'asymmetry', 'portfolio']
      },
      execution: { 
        name: 'EXECUTION', 
        color: new THREE.Color(0xff6b9d),
        emissive: new THREE.Color(0x331122),
        position: new THREE.Vector3(-45, 0, 35),
        keywords: ['tool', 'skill', 'deploy', 'action', 'execute', 'integration']
      },
      cognition: { 
        name: 'COGNITION', 
        color: new THREE.Color(0x9d6bff),
        emissive: new THREE.Color(0x220033),
        position: new THREE.Vector3(25, 0, -50),
        keywords: ['think', 'decide', 'analyze', 'reason', 'logic', 'model']
      },
      memory: { 
        name: 'MEMORY', 
        color: new THREE.Color(0x6bff9d),
        emissive: new THREE.Color(0x113322),
        position: new THREE.Vector3(-35, 0, -45),
        keywords: ['memory', 'remember', 'decision', 'learned', 'preference', 'history']
      },
      perception: {
        name: 'PERCEPTION',
        color: new THREE.Color(0x00ddff),
        emissive: new THREE.Color(0x002233),
        position: new THREE.Vector3(55, 0, -20),
        keywords: ['sense', 'observe', 'market', 'signal', 'news', 'external']
      },
      growth: {
        name: 'GROWTH',
        color: new THREE.Color(0x00ff88),
        emissive: new THREE.Color(0x003322),
        position: new THREE.Vector3(-20, 0, 55),
        keywords: ['learn', 'improve', 'adapt', 'evolve', 'error', 'feedback']
      },
      relationship: {
        name: 'RELATIONSHIP',
        color: new THREE.Color(0xff8800),
        emissive: new THREE.Color(0x332200),
        position: new THREE.Vector3(-55, 0, -10),
        keywords: ['anton', 'bond', 'trust', 'protect', 'communicate', 'loyalty']
      },
      emotion: {
        name: 'EMOTION',
        color: new THREE.Color(0xff4466),
        emissive: new THREE.Color(0x331122),
        position: new THREE.Vector3(10, 0, 55),
        keywords: ['feel', 'humor', 'empathy', 'mood', 'personality']
      },
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CITY STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const city = {
      buildings: [],
      connections: [],
      districts: new Map(),
      drones: [],
      particles: null,
      districtLabels: [],
      stars: null,
      coreRings: [],
      time: 0,
      realTime: new Date(),
      sunPosition: new THREE.Vector3(),
      nightIntensity: 0,
      // Ambient life systems
      trafficLights: [],
      elevators: [],
      fireflies: null,
      dustMotes: null,
      dataStreams: [],
      aircraft: [],
      shootingStars: [],
      windowStates: new Map(), // Track individual window states
      // Weather system
      weather: 'clear', // 'clear' | 'rain' | 'fog' | 'aurora'
      weatherTransition: 0, // 0-1 transition progress
      targetWeather: 'clear',
      rainSystem: null,
      puddles: [],
      fogPlanes: [],
      aurora: null,
      weatherIntensity: 0, // Current effect intensity (for transitions)
      // Lightning system (during rain)
      lightning: {
        active: false,
        flashIntensity: 0,
        bolts: [],
        nextFlashTime: 0,
        flashHoldTime: 0,
      },
      // Auto weather cycling
      weatherCycleEnabled: true,
      nextWeatherChange: 0,
      // Thought bubbles (floating text)
      thoughts: [],
      thoughtsGroup: null,
      lastThoughtTime: 0,
    };
    
    const weatherStateEl = document.getElementById('weatherState');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT RHYTHM PROFILES - Each district has its own "personality"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT RHYTHM PROFILES - CALMED DOWN for peaceful idle state
    // Activity should only be noticeable during actual cognitive work
    // Idle = quiet city at 3am, not epileptic lightshow
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const DISTRICT_RHYTHMS = {
      core: {
        baseSpeed: 0.3,         // Slow, meditative
        pulseFrequency: 0.4,    // Very gentle breathing
        activityLevel: 0.15,    // Minimal idle activity
        burstChance: 0.0001,    // Almost never in idle
        color: 0x00ffff
      },
      trading: {
        baseSpeed: 0.5,         // Calmed from 1.8
        pulseFrequency: 0.6,    // Slow pulse, not frantic ticker
        activityLevel: 0.2,     // Low idle activity
        burstChance: 0.0002,    // Very rare (only during actual trading)
        color: 0xffd700
      },
      infrastructure: {
        baseSpeed: 0.2,         // Steady, quiet
        pulseFrequency: 0.3,    // Slow server heartbeat
        activityLevel: 0.1,     // Minimal, steady
        burstChance: 0.00005,   // Servers rarely spike when idle
        color: 0xff6b9d
      },
      projects: {
        baseSpeed: 0.3,         // Dormant until active
        pulseFrequency: 0.4,
        activityLevel: 0.12,
        burstChance: 0.0001,    // Creative work is intentional
        color: 0x9d6bff
      },
      memory: {
        baseSpeed: 0.15,        // Slowest, archival silence
        pulseFrequency: 0.2,    // Barely perceptible breathing
        activityLevel: 0.05,    // Archives at rest
        burstChance: 0.00002,   // Memories only recalled when needed
        color: 0x6bff9d
      }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: TRAFFIC LIGHTS (vehicles/data packets on roads)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createTrafficLights() {
      const trafficCount = isMobile ? 12 : 30; // Reduced for calmer traffic
      const trafficGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(trafficCount * 3);
      const colors = new Float32Array(trafficCount * 3);
      const velocities = [];
      const paths = [];
      
      // Define road paths between districts
      const districtPositions = Object.values(DISTRICTS).map(d => d.position);
      const roadPaths = [];
      
      // Core to each district
      districtPositions.forEach(pos => {
        if (pos.x !== 0 || pos.z !== 0) {
          roadPaths.push({ start: { x: 0, z: 0 }, end: { x: pos.x, z: pos.z } });
        }
      });
      
      // Between adjacent districts
      for (let i = 1; i < districtPositions.length; i++) {
        const curr = districtPositions[i];
        const next = districtPositions[(i % (districtPositions.length - 1)) + 1];
        if (curr && next) {
          roadPaths.push({ start: { x: curr.x, z: curr.z }, end: { x: next.x, z: next.z } });
        }
      }
      
      for (let i = 0; i < trafficCount; i++) {
        const path = roadPaths[i % roadPaths.length];
        const progress = Math.random();
        
        // Position along path
        const x = path.start.x + (path.end.x - path.start.x) * progress;
        const z = path.start.z + (path.end.z - path.start.z) * progress;
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = 0.3 + Math.random() * 0.3; // Slightly above ground
        positions[i * 3 + 2] = z;
        
        // Color based on direction (cyan going out, warm coming in)
        const outbound = Math.random() > 0.5;
        const color = outbound ? new THREE.Color(0x00ffff) : new THREE.Color(0xffaa44);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
        
        velocities.push({
          progress: progress,
          speed: 0.0008 + Math.random() * 0.0012, // Slower, calmer traffic
          direction: outbound ? 1 : -1,
          pathIndex: i % roadPaths.length
        });
        paths.push(path);
      }
      
      trafficGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      trafficGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const trafficMaterial = new THREE.PointsMaterial({
        size: isMobile ? 0.4 : 0.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
      });
      
      city.trafficLights = new THREE.Points(trafficGeometry, trafficMaterial);
      city.trafficLights.userData = { velocities, paths, roadPaths };
      scene.add(city.trafficLights);
    }
    
    function updateTrafficLights(dt) {
      if (!city.trafficLights) return;
      
      const positions = city.trafficLights.geometry.attributes.position.array;
      const { velocities, roadPaths } = city.trafficLights.userData;
      
      for (let i = 0; i < velocities.length; i++) {
        const v = velocities[i];
        const path = roadPaths[v.pathIndex];
        
        // Move along path
        v.progress += v.speed * v.direction;
        
        // Loop back when reaching end
        if (v.progress > 1) {
          v.progress = 0;
          v.pathIndex = Math.floor(Math.random() * roadPaths.length);
        } else if (v.progress < 0) {
          v.progress = 1;
          v.pathIndex = Math.floor(Math.random() * roadPaths.length);
        }
        
        const newPath = roadPaths[v.pathIndex];
        positions[i * 3] = newPath.start.x + (newPath.end.x - newPath.start.x) * v.progress;
        positions[i * 3 + 1] = 0.3 + Math.sin(dt * 0.8 + i) * 0.05; // Very gentle, slow bobbing
        positions[i * 3 + 2] = newPath.start.z + (newPath.end.z - newPath.start.z) * v.progress;
      }
      
      city.trafficLights.geometry.attributes.position.needsUpdate = true;
      
      // Brighter at night
      city.trafficLights.material.opacity = 0.6 + city.nightIntensity * 0.4;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: ELEVATORS (visible in tall buildings)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function addElevatorToBuilding(building) {
      if (building.height < 25) return; // Only the tallest buildings
      
      const elevatorCount = Math.floor(building.height / 40) + 1; // Fewer elevators
      const baseHeight = 2; // Above the base/lobby section
      
      for (let e = 0; e < elevatorCount; e++) {
        const elevatorGeo = new THREE.BoxGeometry(0.15, 0.4, 0.15);
        const elevatorMat = new THREE.MeshBasicMaterial({
          color: 0xffffcc,
          transparent: true,
          opacity: 0.8
        });
        const elevator = new THREE.Mesh(elevatorGeo, elevatorMat);
        
        // Position on building edge
        const side = e % 4;
        const offset = building.width / 2 + 0.1;
        switch (side) {
          case 0: elevator.position.set(offset, baseHeight, 0); break;
          case 1: elevator.position.set(-offset, baseHeight, 0); break;
          case 2: elevator.position.set(0, baseHeight, offset); break;
          case 3: elevator.position.set(0, baseHeight, -offset); break;
        }
        
        elevator.userData = {
          isElevator: true,
          floor: Math.random(),
          targetFloor: Math.random(),
          speed: 0.002 + Math.random() * 0.004, // Slower elevators
          waitTime: 0,
          maxWait: 200 + Math.random() * 400, // Much longer waits between trips
          buildingHeight: building.height,
          baseHeight: baseHeight // Floor where elevator starts
        };
        
        building.mesh.add(elevator);
        city.elevators.push(elevator);
      }
    }
    
    function updateElevators(dt) {
      city.elevators.forEach(elevator => {
        const data = elevator.userData;
        
        if (data.waitTime > 0) {
          data.waitTime--;
          // Subtle glow while waiting (no aggressive blinking)
          elevator.material.opacity = 0.6 + Math.sin(dt * 1.5) * 0.15;
          return;
        }
        
        elevator.material.opacity = 0.5 + city.nightIntensity * 0.2;
        
        // Move toward target - slower
        const diff = data.targetFloor - data.floor;
        if (Math.abs(diff) < 0.01) {
          // Arrived - wait longer then pick new target
          data.waitTime = data.maxWait * 2; // Double the wait time
          data.targetFloor = Math.random();
        } else {
          data.floor += Math.sign(diff) * data.speed * 0.5; // Move slower
        }
        
        // Position elevator - now goes from baseHeight to buildingHeight
        const baseHeight = data.baseHeight || 2;
        const travelHeight = data.buildingHeight - baseHeight;
        const yPos = baseHeight + data.floor * travelHeight;
        elevator.position.y = yPos;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: FIREFLIES (night) & DUST MOTES (day)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENERGY MOTES - Floating holographic particles for AAA atmosphere
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createEnergyMotes() {
      const moteCount = isMobile ? 100 : 300;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(moteCount * 3);
      const colors = new Float32Array(moteCount * 3);
      const sizes = new Float32Array(moteCount);
      const phases = new Float32Array(moteCount);
      
      // District colors for energy motes
      const districtColors = [
        new THREE.Color(0x00ffff), // Core - cyan
        new THREE.Color(0xffd700), // Trading - gold
        new THREE.Color(0xff6b9d), // Execution - pink
        new THREE.Color(0x9d6bff), // Cognition - purple
        new THREE.Color(0x6bff9d), // Memory - green
      ];
      
      for (let i = 0; i < moteCount; i++) {
        // Position in district areas
        const angle = Math.random() * Math.PI * 2;
        const radius = 10 + Math.random() * 60;
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = 2 + Math.random() * 45; // Varied heights
        positions[i * 3 + 2] = Math.sin(angle) * radius;
        
        // Color based on nearest district
        const districtIdx = Math.floor(Math.random() * districtColors.length);
        const color = districtColors[districtIdx];
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
        
        // Varied sizes
        sizes[i] = 0.2 + Math.random() * 0.6;
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      // Custom shader material for glowing motes
      const moteMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          nightIntensity: { value: 0 }
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float time;
          uniform float nightIntensity;
          
          void main() {
            vColor = color;
            vec3 pos = position;
            
            // Gentle floating motion
            float uniquePhase = position.x * 0.1 + position.z * 0.1;
            pos.y += sin(time * 0.5 + uniquePhase) * 1.5;
            pos.x += sin(time * 0.3 + uniquePhase * 2.0) * 0.5;
            pos.z += cos(time * 0.4 + uniquePhase * 1.5) * 0.5;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // Pulsing size
            float pulse = 0.8 + 0.4 * sin(time * 2.0 + uniquePhase * 3.0);
            float nightBoost = 1.0 + nightIntensity * 0.8;
            
            gl_PointSize = size * pulse * nightBoost * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          uniform float nightIntensity;
          
          void main() {
            // Soft circular gradient
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            if (dist > 0.5) discard;
            
            // Glowing core
            float glow = 1.0 - smoothstep(0.0, 0.5, dist);
            glow = pow(glow, 1.5);
            
            // Brighter at night
            float alpha = glow * (0.4 + nightIntensity * 0.5);
            
            gl_FragColor = vec4(vColor * (1.0 + glow * 0.5), alpha);
          }
        `,
        transparent: true,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      city.energyMotes = new THREE.Points(geometry, moteMaterial);
      city.energyMotes.userData = { phases };
      scene.add(city.energyMotes);
    }
    
    function updateEnergyMotes(dt) {
      if (!city.energyMotes) return;
      
      // Update shader uniforms
      city.energyMotes.material.uniforms.time.value = dt;
      city.energyMotes.material.uniforms.nightIntensity.value = city.nightIntensity;
      
      // Respawn motes that drift too far
      const positions = city.energyMotes.geometry.attributes.position.array;
      for (let i = 0; i < positions.length / 3; i++) {
        const y = positions[i * 3 + 1];
        if (y > 55 || y < 1) {
          // Reset to random position
          const angle = Math.random() * Math.PI * 2;
          const radius = 10 + Math.random() * 60;
          positions[i * 3] = Math.cos(angle) * radius;
          positions[i * 3 + 1] = 5 + Math.random() * 30;
          positions[i * 3 + 2] = Math.sin(angle) * radius;
        }
      }
      city.energyMotes.geometry.attributes.position.needsUpdate = true;
    }
    
    function createFirefliesAndDust() {
      const count = isMobile ? 80 : 200;
      
      // Fireflies (visible at night)
      const fireflyGeometry = new THREE.BufferGeometry();
      const fireflyPositions = new Float32Array(count * 3);
      const fireflyPhases = new Float32Array(count); // For twinkling
      
      for (let i = 0; i < count; i++) {
        fireflyPositions[i * 3] = (Math.random() - 0.5) * 120;
        fireflyPositions[i * 3 + 1] = 2 + Math.random() * 30;
        fireflyPositions[i * 3 + 2] = (Math.random() - 0.5) * 120;
        fireflyPhases[i] = Math.random() * Math.PI * 2;
      }
      
      fireflyGeometry.setAttribute('position', new THREE.BufferAttribute(fireflyPositions, 3));
      fireflyGeometry.setAttribute('phase', new THREE.BufferAttribute(fireflyPhases, 1));
      
      const fireflyMaterial = new THREE.PointsMaterial({
        color: 0xccff66,
        size: 0.4,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
      });
      
      city.fireflies = new THREE.Points(fireflyGeometry, fireflyMaterial);
      city.fireflies.userData = { phases: fireflyPhases, velocities: [] };
      
      // Initialize velocities for wandering
      for (let i = 0; i < count; i++) {
        city.fireflies.userData.velocities.push({
          x: (Math.random() - 0.5) * 0.02,
          y: (Math.random() - 0.5) * 0.01,
          z: (Math.random() - 0.5) * 0.02
        });
      }
      
      scene.add(city.fireflies);
      
      // Dust motes (visible during day, especially in light shafts)
      const dustGeometry = new THREE.BufferGeometry();
      const dustPositions = new Float32Array(count * 3);
      
      for (let i = 0; i < count; i++) {
        dustPositions[i * 3] = (Math.random() - 0.5) * 80;
        dustPositions[i * 3 + 1] = 5 + Math.random() * 40;
        dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
      }
      
      dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
      
      const dustMaterial = new THREE.PointsMaterial({
        color: 0xffffee,
        size: 0.15,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
      });
      
      city.dustMotes = new THREE.Points(dustGeometry, dustMaterial);
      scene.add(city.dustMotes);
    }
    
    function updateFirefliesAndDust(dt) {
      // Fireflies - only visible at night, twinkle randomly
      if (city.fireflies) {
        const positions = city.fireflies.geometry.attributes.position.array;
        const phases = city.fireflies.userData.phases;
        const velocities = city.fireflies.userData.velocities;
        
        city.fireflies.material.opacity = city.nightIntensity * 0.8;
        
        // Only update positions if visible
        if (city.nightIntensity > 0.2) {
          for (let i = 0; i < phases.length; i++) {
            // Gentle wandering motion
            const v = velocities[i];
            positions[i * 3] += v.x + Math.sin(dt + phases[i]) * 0.01;
            positions[i * 3 + 1] += v.y + Math.cos(dt * 0.7 + phases[i]) * 0.005;
            positions[i * 3 + 2] += v.z + Math.sin(dt * 0.8 + phases[i]) * 0.01;
            
            // Boundary check - keep in city area
            if (Math.abs(positions[i * 3]) > 60) v.x *= -1;
            if (positions[i * 3 + 1] < 2 || positions[i * 3 + 1] > 35) v.y *= -1;
            if (Math.abs(positions[i * 3 + 2]) > 60) v.z *= -1;
            
            // Occasionally change direction
            if (Math.random() < 0.002) {
              v.x = (Math.random() - 0.5) * 0.02;
              v.y = (Math.random() - 0.5) * 0.01;
              v.z = (Math.random() - 0.5) * 0.02;
            }
          }
          city.fireflies.geometry.attributes.position.needsUpdate = true;
        }
        
        // Twinkle effect - vary size
        city.fireflies.material.size = 0.3 + Math.sin(dt * 3) * 0.15;
      }
      
      // Dust motes - visible during day, drift slowly
      if (city.dustMotes) {
        const dayIntensity = 1 - city.nightIntensity;
        // More visible during golden hour (dramatic light shafts)
        const goldenBoost = lighting.goldenHourIntensity * 0.5;
        city.dustMotes.material.opacity = dayIntensity * 0.25 + goldenBoost;
        
        // Warm color during golden hour
        if (lighting.goldenHourIntensity > 0) {
          city.dustMotes.material.color.setHex(0xffddaa);
        } else {
          city.dustMotes.material.color.setHex(0xffffee);
        }
        
        // Gentle drift
        const positions = city.dustMotes.geometry.attributes.position.array;
        for (let i = 0; i < positions.length / 3; i++) {
          positions[i * 3] += Math.sin(dt * 0.2 + i * 0.5) * 0.005;
          positions[i * 3 + 1] += 0.002 + Math.sin(dt * 0.3 + i) * 0.002;
          positions[i * 3 + 2] += Math.cos(dt * 0.15 + i * 0.3) * 0.005;
          
          // Reset when too high
          if (positions[i * 3 + 1] > 50) {
            positions[i * 3 + 1] = 5;
            positions[i * 3] = (Math.random() - 0.5) * 80;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 80;
          }
        }
        city.dustMotes.geometry.attributes.position.needsUpdate = true;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: DATA STREAMS (flowing between connected buildings)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDataStream(connection) {
      const particleCount = isMobile ? 8 : 15;
      const streamGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const progresses = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount; i++) {
        progresses[i] = i / particleCount;
        // Initial positions will be updated in animation
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;
      }
      
      streamGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const streamMaterial = new THREE.PointsMaterial({
        color: connection.line.material.color,
        size: 0.25,
        transparent: true,
        opacity: 0.7,
        sizeAttenuation: true,
      });
      
      const stream = new THREE.Points(streamGeometry, streamMaterial);
      stream.userData = {
        connection,
        progresses,
        speed: 0.004 + Math.random() * 0.006, // Much slower, calmer flow
        active: Math.random() > 0.7 // Most connections dormant in idle (only 30% active)
      };
      
      scene.add(stream);
      city.dataStreams.push(stream);
    }
    
    function updateDataStreams(dt) {
      city.dataStreams.forEach(stream => {
        if (!stream.userData.active) {
          // Very rarely activate in idle - data flows when there's work
          if (Math.random() < 0.0002) stream.userData.active = true;
          stream.material.opacity = 0;
          return;
        }
        
        const { connection, progresses, speed } = stream.userData;
        const from = connection.from;
        const to = connection.to;
        const positions = stream.geometry.attributes.position.array;
        
        // Bezier curve midpoint (same as connection)
        const midX = (from.x + to.x) / 2;
        const midY = 2 + Math.random() * 2;
        const midZ = (from.z + to.z) / 2;
        
        for (let i = 0; i < progresses.length; i++) {
          progresses[i] += speed;
          if (progresses[i] > 1) progresses[i] -= 1;
          
          // Quadratic bezier interpolation
          const t = progresses[i];
          const mt = 1 - t;
          
          positions[i * 3] = mt * mt * from.x + 2 * mt * t * midX + t * t * to.x;
          positions[i * 3 + 1] = mt * mt * 0.5 + 2 * mt * t * midY + t * t * 0.5 + Math.sin(t * Math.PI) * 1.5;
          positions[i * 3 + 2] = mt * mt * from.z + 2 * mt * t * midZ + t * t * to.z;
        }
        
        stream.geometry.attributes.position.needsUpdate = true;
        stream.material.opacity = 0.3 + city.nightIntensity * 0.3; // Slightly dimmer
        
        // More frequently deactivate to keep city calm
        if (Math.random() < 0.002) stream.userData.active = false;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: AIRCRAFT & SATELLITES (distant sky movement)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createAircraft() {
      const aircraftCount = isMobile ? 3 : 6;
      
      for (let i = 0; i < aircraftCount; i++) {
        const aircraftGroup = new THREE.Group();
        
        // Main light
        const lightGeo = new THREE.SphereGeometry(0.3, 6, 6);
        const lightMat = new THREE.MeshBasicMaterial({
          color: i < aircraftCount / 2 ? 0xffffff : 0xff3333, // White for planes, red for others
          transparent: true,
          opacity: 0.9
        });
        const mainLight = new THREE.Mesh(lightGeo, lightMat);
        aircraftGroup.add(mainLight);
        
        // Blinking nav light
        const navGeo = new THREE.SphereGeometry(0.15, 4, 4);
        const navMat = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.8
        });
        const navLight = new THREE.Mesh(navGeo, navMat);
        navLight.position.x = 0.5;
        navLight.userData.blink = true;
        aircraftGroup.add(navLight);
        
        // Trail (for satellites)
        if (i >= aircraftCount / 2) {
          const trailGeo = new THREE.CylinderGeometry(0.05, 0.15, 2, 4);
          const trailMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2
          });
          const trail = new THREE.Mesh(trailGeo, trailMat);
          trail.rotation.z = Math.PI / 2;
          trail.position.x = -1.2;
          aircraftGroup.add(trail);
        }
        
        // Random path across sky
        const isHighAltitude = i >= aircraftCount / 2; // Satellites higher
        aircraftGroup.userData = {
          startAngle: Math.random() * Math.PI * 2,
          speed: isHighAltitude ? 0.0003 : 0.0008,
          altitude: isHighAltitude ? 200 + Math.random() * 100 : 80 + Math.random() * 40,
          radius: 250 + Math.random() * 100,
          progress: Math.random(),
          isPlane: !isHighAltitude
        };
        
        scene.add(aircraftGroup);
        city.aircraft.push(aircraftGroup);
      }
    }
    
    function updateAircraft(dt) {
      city.aircraft.forEach(aircraft => {
        const data = aircraft.userData;
        
        // Move along arc
        data.progress += data.speed;
        if (data.progress > 1) {
          data.progress = 0;
          data.startAngle = Math.random() * Math.PI * 2;
        }
        
        const angle = data.startAngle + data.progress * Math.PI;
        aircraft.position.x = Math.cos(angle) * data.radius;
        aircraft.position.y = data.altitude + Math.sin(data.progress * Math.PI) * 20;
        aircraft.position.z = Math.sin(angle) * data.radius * 0.6;
        
        // Face direction of movement
        aircraft.lookAt(
          aircraft.position.x + Math.cos(angle + 0.1) * 10,
          aircraft.position.y,
          aircraft.position.z + Math.sin(angle + 0.1) * 10
        );
        
        // Blinking nav lights
        aircraft.children.forEach(child => {
          if (child.userData.blink) {
            child.material.opacity = Math.sin(dt * 5) > 0.5 ? 0.9 : 0;
          }
        });
        
        // Less visible during bright day, more at night
        const visibility = 0.3 + city.nightIntensity * 0.7;
        aircraft.children[0].material.opacity = visibility;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: SHOOTING STARS (occasional at night)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createShootingStar() {
      if (city.nightIntensity < 0.5) return; // Only at night
      if (city.shootingStars.length > 2) return; // Limit concurrent
      
      const starGroup = new THREE.Group();
      
      // Star head
      const headGeo = new THREE.SphereGeometry(0.5, 6, 6);
      const headMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1
      });
      const head = new THREE.Mesh(headGeo, headMat);
      starGroup.add(head);
      
      // Trail
      const trailLength = 8 + Math.random() * 12;
      const trailGeo = new THREE.ConeGeometry(0.4, trailLength, 6);
      const trailMat = new THREE.MeshBasicMaterial({
        color: 0xaaddff,
        transparent: true,
        opacity: 0.6
      });
      const trail = new THREE.Mesh(trailGeo, trailMat);
      trail.rotation.x = Math.PI / 2;
      trail.position.z = trailLength / 2;
      starGroup.add(trail);
      
      // Random start position (high in sky)
      const startAngle = Math.random() * Math.PI * 2;
      starGroup.position.set(
        Math.cos(startAngle) * 300,
        150 + Math.random() * 100,
        Math.sin(startAngle) * 200
      );
      
      // Direction (generally downward and inward)
      const endAngle = startAngle + (Math.random() - 0.5) * 1;
      starGroup.userData = {
        velocity: new THREE.Vector3(
          (Math.cos(endAngle) * 100 - starGroup.position.x) * 0.02,
          -2 - Math.random() * 2,
          (Math.sin(endAngle) * 100 - starGroup.position.z) * 0.02
        ),
        life: 1.0,
        decay: 0.015 + Math.random() * 0.01
      };
      
      // Face direction of travel
      starGroup.lookAt(
        starGroup.position.x + starGroup.userData.velocity.x * 10,
        starGroup.position.y + starGroup.userData.velocity.y * 10,
        starGroup.position.z + starGroup.userData.velocity.z * 10
      );
      
      scene.add(starGroup);
      city.shootingStars.push(starGroup);
    }
    
    // Meteor shower state
    let meteorShowerActive = false;
    let meteorShowerEndTime = 0;
    
    /**
     * Trigger a meteor shower event (many shooting stars at once)
     */
    function triggerMeteorShower(durationSeconds = 30) {
      if (city.nightIntensity < 0.3) {
        console.log('[MeteorShower] Can only trigger at night');
        return false;
      }
      
      meteorShowerActive = true;
      meteorShowerEndTime = Date.now() + durationSeconds * 1000;
      console.log(`[MeteorShower] Started! Duration: ${durationSeconds}s`);
      
      // Initial burst
      for (let i = 0; i < 5; i++) {
        setTimeout(() => createShootingStar(), i * 200);
      }
      
      return true;
    }
    
    function updateShootingStars() {
      // Check if meteor shower is active
      if (meteorShowerActive) {
        if (Date.now() > meteorShowerEndTime) {
          meteorShowerActive = false;
          console.log('[MeteorShower] Ended');
        } else {
          // Spawn many more shooting stars during shower
          if (Math.random() < 0.15) { // 15% chance per frame
            createShootingStar();
          }
        }
      }
      
      // Occasionally spawn new ones at night (normal rate)
      if (city.nightIntensity > 0.5 && Math.random() < 0.002) {
        createShootingStar();
      }
      
      for (let i = city.shootingStars.length - 1; i >= 0; i--) {
        const star = city.shootingStars[i];
        const data = star.userData;
        
        // Move
        star.position.add(data.velocity);
        
        // Fade
        data.life -= data.decay;
        star.children.forEach(child => {
          child.material.opacity = data.life;
        });
        
        // Remove when faded
        if (data.life <= 0) {
          scene.remove(star);
          city.shootingStars.splice(i, 1);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: WINDOW ACTIVITY SYSTEM (turning on/off, TV flicker)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function initializeWindowStates(building) {
      const windowStates = [];
      
      // Recursively find all window-like elements in the building
      function findWindows(obj) {
        if (!obj) return;
        
        // Check if this is a window-like element (plane with basic material, not a frame line)
        if (obj.geometry && obj.material && 
            (obj.geometry.type === 'PlaneGeometry' || 
             obj.geometry.type === 'BoxGeometry' || 
             obj.geometry.type === 'TorusGeometry') &&
            obj.material.type === 'MeshBasicMaterial' &&
            obj.material.transparent === true &&
            !obj.userData.hologram) { // Exclude holograms
          
          const state = {
            isOn: Math.random() > 0.08,  // 92% windows stay lit - stable city
            isTV: Math.random() < 0.03,  // Only 3% are TVs - much rarer
            baseOpacity: obj.material.opacity,
            targetOpacity: obj.material.opacity,
            transitionSpeed: 0.003 + Math.random() * 0.005, // Very slow transitions
            nextToggle: 300 + Math.random() * 600,
            tvFlickerPhase: Math.random() * Math.PI * 2,
            originalColor: obj.material.color.clone()
          };
          windowStates.push({ child: obj, state });
        }
        
        // Recurse into children
        if (obj.children) {
          obj.children.forEach(child => findWindows(child));
        }
      }
      
      findWindows(building.mesh);
      city.windowStates.set(building, windowStates);
    }
    
    function updateWindowActivity(dt) {
      city.windowStates.forEach((windows, building) => {
        const districtRhythm = DISTRICT_RHYTHMS[building.district] || DISTRICT_RHYTHMS.core;
        
        windows.forEach(({ child, state }) => {
          // Count down to next toggle
          state.nextToggle--;
          
          // Very rarely toggle window state - city is peaceful at rest
          if (state.nextToggle <= 0) {
            // Windows almost always stay on (95%+), especially at night
            const onChance = 0.92 + city.nightIntensity * 0.06;
            state.isOn = Math.random() < onChance;
            // Windows are BRIGHTER at night (like real cities)
            const nightBrightness = 1 + city.nightIntensity * 0.6;
            state.targetOpacity = state.isOn ? 
              (state.baseOpacity * 0.8 + Math.random() * state.baseOpacity * 0.4) * nightBrightness : 
              0.08;
            // Very long intervals: 8-20 seconds before next possible change
            state.nextToggle = 500 + Math.random() * 700;
          }
          
          // TV effect - VERY subtle, no rapid flicker
          if (state.isTV && state.isOn && city.nightIntensity > 0.3) {
            // Slow, gentle color shift instead of frantic flicker
            const slowPulse = Math.sin(dt * 0.5 + state.tvFlickerPhase) * 0.05;
            child.material.opacity = state.targetOpacity + slowPulse;
            // Subtle blue TV glow, no rapid color changes
            child.material.color.setHex(0x9999cc);
          } else {
            // Very smooth transition to target
            const current = child.material.opacity;
            const diff = state.targetOpacity - current;
            child.material.opacity = current + diff * state.transitionSpeed;
            
            // Restore original district color with night warmth adjustment
            if (!state.isTV && state.originalColor) {
              const warmth = city.nightIntensity * 0.15;
              child.material.color.copy(state.originalColor);
              child.material.color.r = Math.min(1, state.originalColor.r + warmth * 0.3);
              child.material.color.g = Math.min(1, state.originalColor.g + warmth * 0.1);
            }
          }
        });
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT LIFE: DISTRICT-SPECIFIC BUILDING PULSE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateDistrictPulses(dt) {
      city.buildings.forEach(building => {
        const rhythm = DISTRICT_RHYTHMS[building.district] || DISTRICT_RHYTHMS.core;
        
        // Very gentle, slow pulse - like breathing at rest
        const pulse = Math.sin(dt * rhythm.pulseFrequency) * 0.5 + 0.5;
        
        // Activity burst - almost never in idle state
        const burst = Math.random() < rhythm.burstChance ? 0.15 : 0;
        
        // Base glow is stable, minimal variation
        const baseIntensity = 0.25 + city.nightIntensity * 0.2;
        const rhythmIntensity = pulse * rhythm.activityLevel * 0.08;
        const targetEmissive = baseIntensity + rhythmIntensity + burst;
        
        // Recursively update emissive materials and pulsing elements
        function updateMesh(obj) {
          if (!obj) return;
          
          // Update emissive intensity on materials
          if (obj.material && obj.material.emissiveIntensity !== undefined) {
            obj.material.emissiveIntensity = targetEmissive;
          }
          
          // Update pulsing beacons/lights
          if (obj.userData && obj.userData.pulse) {
            const beaconPulse = Math.sin(dt * rhythm.pulseFrequency * 0.5 + obj.userData.pulsePhase);
            const scale = 1 + beaconPulse * 0.1 * rhythm.activityLevel;
            obj.scale.set(scale, scale, scale);
          }
          
          // Recurse into children
          if (obj.children) {
            obj.children.forEach(child => updateMesh(child));
          }
        }
        
        updateMesh(building.mesh);
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SOUND MANAGER â€” Ambient Soundscape
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    class SoundManager {
      constructor() {
        this.enabled = false;
        this.muted = false;
        this.context = null;
        this.masterGain = null;
        this.initialized = false;
        
        // Sound layers
        this.layers = {
          cityHum: null,      // Constant low drone
          wind: null,         // Altitude-based wind
          electrical: null,   // Building hum
          morning: null,      // Bird-like chirps
          night: null,        // Cricket/owl sounds
          thinking: null,     // Processing sounds
          responding: null,   // Response chime
        };
        
        // Current state
        this.currentPhase = 'day';
        this.cognitiveState = 'idle';
        this.cameraDistance = 50;
        
        // UI elements
        this.soundToggleBtn = document.getElementById('soundToggle');
        this.muteToggleBtn = document.getElementById('muteToggle');
        
        this.setupUI();
        this.setupKeyboard();
      }
      
      setupUI() {
        if (this.soundToggleBtn) {
          this.soundToggleBtn.addEventListener('click', () => this.toggle());
        }
        if (this.muteToggleBtn) {
          this.muteToggleBtn.addEventListener('click', () => this.toggleMute());
        }
      }
      
      setupKeyboard() {
        window.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 's' && !e.ctrlKey && !e.metaKey) {
            this.toggle();
          }
          if (e.key.toLowerCase() === 'm' && !e.ctrlKey && !e.metaKey) {
            this.toggleMute();
          }
        });
      }
      
      async init() {
        if (this.initialized) return;
        
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          
          // Master gain for overall volume
          this.masterGain = this.context.createGain();
          this.masterGain.gain.value = 0.3; // Start quiet
          this.masterGain.connect(this.context.destination);
          
          // Create all sound layers
          this.createCityHum();
          this.createWind();
          this.createElectrical();
          this.createMorningSounds();
          this.createNightSounds();
          this.createThinkingSound();
          this.createRespondingSound();
          
          this.initialized = true;
          console.log('[Sound] Initialized');
        } catch (err) {
          console.error('[Sound] Init failed:', err);
        }
      }
      
      // === SOUND GENERATORS (Oscillator-based, no external files) ===
      
      createCityHum() {
        // Low frequency drone - the heartbeat of the city
        const osc1 = this.context.createOscillator();
        const osc2 = this.context.createOscillator();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc1.type = 'sine';
        osc1.frequency.value = 55; // Low A
        osc2.type = 'sine';
        osc2.frequency.value = 82.5; // Harmonic
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        gain.gain.value = 0;
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc1.start();
        osc2.start();
        
        this.layers.cityHum = { oscillators: [osc1, osc2], gain, filter };
      }
      
      createWind() {
        // White noise with bandpass for wind effect
        const bufferSize = 2 * this.context.sampleRate;
        const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.context.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.loop = true;
        
        const filter = this.context.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 0.5;
        
        const gain = this.context.createGain();
        gain.gain.value = 0;
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start();
        
        this.layers.wind = { source: noise, gain, filter };
      }
      
      createElectrical() {
        // High-frequency hum with slight modulation
        const osc = this.context.createOscillator();
        const modulator = this.context.createOscillator();
        const modulatorGain = this.context.createGain();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = 120; // Electrical hum frequency
        
        modulator.type = 'sine';
        modulator.frequency.value = 0.5; // Slow wobble
        modulatorGain.gain.value = 5;
        
        modulator.connect(modulatorGain);
        modulatorGain.connect(osc.frequency);
        
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        
        gain.gain.value = 0;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        modulator.start();
        
        this.layers.electrical = { oscillators: [osc, modulator], gain, filter };
      }
      
      createMorningSounds() {
        // Bird-like chirps using FM synthesis
        const gain = this.context.createGain();
        gain.gain.value = 0;
        gain.connect(this.masterGain);
        
        this.layers.morning = { 
          gain,
          lastChirp: 0,
          active: false
        };
      }
      
      playChirp() {
        if (!this.enabled || this.muted || !this.layers.morning?.active) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const modulator = this.context.createOscillator();
        const modGain = this.context.createGain();
        const env = this.context.createGain();
        
        // Random bird-like frequency
        const baseFreq = 1200 + Math.random() * 800;
        osc.type = 'sine';
        osc.frequency.value = baseFreq;
        
        modulator.type = 'sine';
        modulator.frequency.value = 20 + Math.random() * 30;
        modGain.gain.value = baseFreq * 0.3;
        
        modulator.connect(modGain);
        modGain.connect(osc.frequency);
        
        // Quick attack, medium decay
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.15, now + 0.02);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        osc.connect(env);
        env.connect(this.layers.morning.gain);
        
        osc.start(now);
        modulator.start(now);
        osc.stop(now + 0.2);
        modulator.stop(now + 0.2);
      }
      
      createNightSounds() {
        // Cricket-like chirps and occasional owl hoot
        const gain = this.context.createGain();
        gain.gain.value = 0;
        gain.connect(this.masterGain);
        
        this.layers.night = {
          gain,
          lastCricket: 0,
          active: false
        };
      }
      
      playCricket() {
        if (!this.enabled || this.muted || !this.layers.night?.active) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const env = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = 4000 + Math.random() * 1000;
        
        // Rapid on-off pattern
        const duration = 0.3 + Math.random() * 0.2;
        const pulses = 3 + Math.floor(Math.random() * 4);
        const pulseLength = duration / (pulses * 2);
        
        env.gain.setValueAtTime(0, now);
        for (let i = 0; i < pulses; i++) {
          const t = now + i * pulseLength * 2;
          env.gain.setValueAtTime(0.08, t);
          env.gain.setValueAtTime(0, t + pulseLength * 0.8);
        }
        
        osc.connect(env);
        env.connect(this.layers.night.gain);
        
        osc.start(now);
        osc.stop(now + duration);
      }
      
      createThinkingSound() {
        // Electronic processing hum - pulsing, digital feel
        const osc1 = this.context.createOscillator();
        const osc2 = this.context.createOscillator();
        const lfo = this.context.createOscillator();
        const lfoGain = this.context.createGain();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc1.type = 'triangle';
        osc1.frequency.value = 220;
        
        osc2.type = 'sine';
        osc2.frequency.value = 330;
        
        lfo.type = 'sine';
        lfo.frequency.value = 4; // Pulsing rhythm
        lfoGain.gain.value = 0.3;
        
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);
        
        filter.type = 'bandpass';
        filter.frequency.value = 600;
        filter.Q.value = 2;
        
        gain.gain.value = 0;
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc1.start();
        osc2.start();
        lfo.start();
        
        this.layers.thinking = { oscillators: [osc1, osc2, lfo], gain, filter };
      }
      
      createRespondingSound() {
        // Soft chime/pulse when responding
        const gain = this.context.createGain();
        gain.gain.value = 0;
        gain.connect(this.masterGain);
        
        this.layers.responding = { gain, active: false };
      }
      
      playResponseChime() {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        const frequencies = [523, 659, 784]; // C, E, G chord
        
        frequencies.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const env = this.context.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          const delay = i * 0.05;
          env.gain.setValueAtTime(0, now + delay);
          env.gain.linearRampToValueAtTime(0.12, now + delay + 0.05);
          env.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.8);
          
          osc.connect(env);
          env.connect(this.layers.responding.gain);
          
          osc.start(now + delay);
          osc.stop(now + delay + 1);
        });
      }
      
      // === STATE CONTROL ===
      
      async toggle() {
        if (!this.enabled) {
          await this.init();
          this.enable();
        } else {
          this.disable();
        }
      }
      
      enable() {
        if (!this.initialized) return;
        
        this.enabled = true;
        
        // Resume context if suspended (required for mobile)
        if (this.context.state === 'suspended') {
          this.context.resume();
        }
        
        // Fade in base layers
        this.fadeLayer('cityHum', 0.12, 2);
        
        this.updateUI();
        console.log('[Sound] Enabled');
      }
      
      disable() {
        this.enabled = false;
        
        // Fade out all layers
        Object.keys(this.layers).forEach(key => {
          this.fadeLayer(key, 0, 0.5);
        });
        
        this.updateUI();
        console.log('[Sound] Disabled');
      }
      
      toggleMute() {
        if (!this.enabled) return;
        
        this.muted = !this.muted;
        
        if (this.muted) {
          this.masterGain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);
        } else {
          this.masterGain.gain.linearRampToValueAtTime(0.3, this.context.currentTime + 0.1);
        }
        
        this.updateUI();
        console.log('[Sound] Muted:', this.muted);
      }
      
      updateUI() {
        if (this.soundToggleBtn) {
          this.soundToggleBtn.textContent = this.enabled ? 'ğŸ”Š On' : 'ğŸ”‡ Off';
          this.soundToggleBtn.classList.toggle('active', this.enabled);
        }
        if (this.muteToggleBtn) {
          this.muteToggleBtn.style.display = this.enabled ? 'block' : 'none';
          this.muteToggleBtn.textContent = this.muted ? 'ğŸ”‡' : 'ğŸ”Š';
          this.muteToggleBtn.classList.toggle('muted', this.muted);
        }
      }
      
      fadeLayer(layerName, targetVolume, duration = 1) {
        const layer = this.layers[layerName];
        if (!layer || !layer.gain) return;
        
        const now = this.context.currentTime;
        layer.gain.gain.linearRampToValueAtTime(targetVolume, now + duration);
      }
      
      // === REACTIVE UPDATES ===
      
      updateTimePhase(hours, nightIntensity) {
        if (!this.enabled || !this.initialized) return;
        
        let newPhase = 'day';
        if (hours >= 5 && hours < 8) newPhase = 'morning';
        else if (hours >= 8 && hours < 18) newPhase = 'day';
        else if (hours >= 18 && hours < 21) newPhase = 'evening';
        else newPhase = 'night';
        
        if (newPhase !== this.currentPhase) {
          this.currentPhase = newPhase;
          this.transitionToPhase(newPhase, nightIntensity);
        }
        
        // Continuous adjustments
        this.updateContinuousLayers(nightIntensity);
        
        // Trigger occasional sounds
        this.triggerPhaseSounds(newPhase);
      }
      
      transitionToPhase(phase, nightIntensity) {
        const fadeTime = 3;
        
        // Base city hum - always present, louder during day
        const humVolume = phase === 'night' ? 0.06 : 0.12;
        this.fadeLayer('cityHum', humVolume, fadeTime);
        
        // Morning sounds (birds)
        if (this.layers.morning) {
          this.layers.morning.active = (phase === 'morning');
          this.fadeLayer('morning', phase === 'morning' ? 0.4 : 0, fadeTime);
        }
        
        // Night sounds (crickets)
        if (this.layers.night) {
          this.layers.night.active = (phase === 'night');
          this.fadeLayer('night', phase === 'night' ? 0.3 : 0, fadeTime);
        }
        
        // Electrical hum - more noticeable at night
        const elecVolume = phase === 'night' ? 0.08 : 0.03;
        this.fadeLayer('electrical', elecVolume, fadeTime);
        
        console.log('[Sound] Phase:', phase);
      }
      
      updateContinuousLayers(nightIntensity) {
        if (!this.layers.cityHum) return;
        
        // Modulate city hum pitch slightly based on time
        const basePitch = 55 + nightIntensity * 10;
        if (this.layers.cityHum.oscillators) {
          this.layers.cityHum.oscillators[0].frequency.value = basePitch;
          this.layers.cityHum.oscillators[1].frequency.value = basePitch * 1.5;
        }
      }
      
      triggerPhaseSounds(phase) {
        const now = Date.now();
        
        // Morning bird chirps
        if (phase === 'morning' && this.layers.morning?.active) {
          if (now - this.layers.morning.lastChirp > 2000 + Math.random() * 5000) {
            this.playChirp();
            // Sometimes double chirp
            if (Math.random() > 0.6) {
              setTimeout(() => this.playChirp(), 100 + Math.random() * 200);
            }
            this.layers.morning.lastChirp = now;
          }
        }
        
        // Night crickets
        if (phase === 'night' && this.layers.night?.active) {
          if (now - this.layers.night.lastCricket > 1500 + Math.random() * 3000) {
            this.playCricket();
            this.layers.night.lastCricket = now;
          }
        }
      }
      
      updateCameraDistance(distance) {
        if (!this.enabled || !this.initialized) return;
        
        this.cameraDistance = distance;
        
        // Wind increases with altitude/distance
        const windVolume = Math.min(0.15, (distance - 20) / 200);
        this.fadeLayer('wind', Math.max(0, windVolume), 0.5);
        
        // City hum decreases with distance
        const humVolume = Math.max(0.03, 0.12 - (distance - 30) / 300);
        if (this.currentPhase === 'night') {
          this.fadeLayer('cityHum', humVolume * 0.5, 0.5);
        } else {
          this.fadeLayer('cityHum', humVolume, 0.5);
        }
      }
      
      updateCognitiveState(state, message = '') {
        if (!this.enabled || !this.initialized) return;
        
        const prevState = this.cognitiveState;
        this.cognitiveState = state;
        
        if (state === 'thinking' && prevState !== 'thinking') {
          // Start thinking sound
          this.fadeLayer('thinking', 0.08, 0.5);
        } else if (state !== 'thinking' && prevState === 'thinking') {
          // Stop thinking sound
          this.fadeLayer('thinking', 0, 0.5);
        }
        
        if (state === 'responding' && prevState !== 'responding') {
          this.playResponseChime();
        }
      }
      
      // Interactive sounds
      playZoomSound(zoomingIn) {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const env = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(zoomingIn ? 300 : 500, now);
        osc.frequency.exponentialRampToValueAtTime(zoomingIn ? 500 : 300, now + 0.15);
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.05, now + 0.02);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.connect(env);
        env.connect(this.masterGain);
        
        osc.start(now);
        osc.stop(now + 0.25);
      }
      
      playDistrictActivation(districtName) {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        
        // Whoosh + tonal element
        const noise = this.context.createBufferSource();
        const noiseBuffer = this.context.createBuffer(1, this.context.sampleRate * 0.5, this.context.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        const noiseFilter = this.context.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.setValueAtTime(200, now);
        noiseFilter.frequency.exponentialRampToValueAtTime(2000, now + 0.15);
        noiseFilter.frequency.exponentialRampToValueAtTime(500, now + 0.4);
        noiseFilter.Q.value = 1;
        
        const noiseEnv = this.context.createGain();
        noiseEnv.gain.setValueAtTime(0, now);
        noiseEnv.gain.linearRampToValueAtTime(0.08, now + 0.05);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseEnv);
        noiseEnv.connect(this.masterGain);
        
        noise.start(now);
        
        console.log('[Sound] District activation:', districtName);
      }
      
      playInfoPing() {
        if (!this.enabled || this.muted) return;
        
        const now = this.context.currentTime;
        const osc = this.context.createOscillator();
        const env = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = 880;
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.1, now + 0.01);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.connect(env);
        env.connect(this.masterGain);
        
        osc.start(now);
        osc.stop(now + 0.35);
      }
    }
    
    // Initialize sound manager (sounds OFF by default)
    const soundManager = new SoundManager();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SKY DOME WITH DYNAMIC GRADIENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createSkyDome() {
      // Sky dome shader for beautiful time-based gradients
      const skyVertexShader = `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      
      const skyFragmentShader = `
        uniform vec3 topColor;
        uniform vec3 middleColor;
        uniform vec3 horizonColor;
        uniform vec3 horizonGlow;
        uniform float horizonSharpness;
        uniform float glowIntensity;
        uniform float sunY;
        varying vec3 vWorldPosition;
        
        void main() {
          float height = normalize(vWorldPosition).y;
          float heightClamped = max(0.0, height);
          
          // Three-zone gradient: horizon -> middle -> top
          vec3 color;
          if (heightClamped < 0.3) {
            // Horizon to middle
            float t = heightClamped / 0.3;
            t = smoothstep(0.0, 1.0, t);
            color = mix(horizonColor, middleColor, t);
            // Add horizon glow (concentrated at very bottom)
            float glowFactor = (1.0 - t) * (1.0 - t) * glowIntensity;
            color = mix(color, horizonGlow, glowFactor);
          } else {
            // Middle to top
            float t = (heightClamped - 0.3) / 0.7;
            t = smoothstep(0.0, 1.0, t);
            color = mix(middleColor, topColor, t);
          }
          
          // Add subtle atmospheric scattering near horizon
          float scatter = exp(-heightClamped * horizonSharpness) * 0.15;
          color += horizonGlow * scatter;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      
      const skyUniforms = {
        topColor: { value: new THREE.Color(0x0a0a20) },
        middleColor: { value: new THREE.Color(0x1a1a40) },
        horizonColor: { value: new THREE.Color(0x2a2a50) },
        horizonGlow: { value: new THREE.Color(0x4a3060) },
        horizonSharpness: { value: 3.0 },
        glowIntensity: { value: 0.3 },
        sunY: { value: 0.0 }
      };
      
      const skyGeo = new THREE.SphereGeometry(450, 32, 24);
      const skyMat = new THREE.ShaderMaterial({
        vertexShader: skyVertexShader,
        fragmentShader: skyFragmentShader,
        uniforms: skyUniforms,
        side: THREE.BackSide,
        depthWrite: false
      });
      
      city.skyDome = new THREE.Mesh(skyGeo, skyMat);
      city.skyUniforms = skyUniforms;
      scene.add(city.skyDome);
      
      // Disable default background
      scene.background = null;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SUN & MOON CELESTIAL BODIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createCelestialBodies() {
      // === SUN ===
      const sunGroup = new THREE.Group();
      
      // Sun core (bright center)
      const sunCoreGeo = new THREE.SphereGeometry(8, 24, 24);
      const sunCoreMat = new THREE.MeshBasicMaterial({
        color: 0xffffcc,
        transparent: true,
        opacity: 1.0
      });
      const sunCore = new THREE.Mesh(sunCoreGeo, sunCoreMat);
      sunGroup.add(sunCore);
      
      // Sun glow layer 1 (inner glow)
      const sunGlow1Geo = new THREE.SphereGeometry(12, 24, 24);
      const sunGlow1Mat = new THREE.MeshBasicMaterial({
        color: 0xffdd88,
        transparent: true,
        opacity: 0.4
      });
      const sunGlow1 = new THREE.Mesh(sunGlow1Geo, sunGlow1Mat);
      sunGroup.add(sunGlow1);
      
      // Sun glow layer 2 (outer glow)
      const sunGlow2Geo = new THREE.SphereGeometry(18, 24, 24);
      const sunGlow2Mat = new THREE.MeshBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.2
      });
      const sunGlow2 = new THREE.Mesh(sunGlow2Geo, sunGlow2Mat);
      sunGroup.add(sunGlow2);
      
      // Sun corona (large faint glow)
      const coronaGeo = new THREE.SphereGeometry(30, 16, 16);
      const coronaMat = new THREE.MeshBasicMaterial({
        color: 0xff8844,
        transparent: true,
        opacity: 0.1
      });
      const corona = new THREE.Mesh(coronaGeo, coronaMat);
      sunGroup.add(corona);
      
      city.sun = sunGroup;
      city.sunCore = sunCore;
      city.sunGlows = [sunGlow1, sunGlow2, corona];
      scene.add(sunGroup);
      
      // === MOON ===
      const moonGroup = new THREE.Group();
      
      // Moon surface
      const moonGeo = new THREE.SphereGeometry(5, 24, 24);
      const moonMat = new THREE.MeshBasicMaterial({
        color: 0xddeeff,
        transparent: true,
        opacity: 0.95
      });
      const moon = new THREE.Mesh(moonGeo, moonMat);
      moonGroup.add(moon);
      
      // Moon glow
      const moonGlowGeo = new THREE.SphereGeometry(8, 16, 16);
      const moonGlowMat = new THREE.MeshBasicMaterial({
        color: 0x8899bb,
        transparent: true,
        opacity: 0.25
      });
      const moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
      moonGroup.add(moonGlow);
      
      // Outer moon halo
      const moonHaloGeo = new THREE.SphereGeometry(12, 16, 16);
      const moonHaloMat = new THREE.MeshBasicMaterial({
        color: 0x6677aa,
        transparent: true,
        opacity: 0.1
      });
      const moonHalo = new THREE.Mesh(moonHaloGeo, moonHaloMat);
      moonGroup.add(moonHalo);
      
      city.moon = moonGroup;
      city.moonCore = moon;
      city.moonGlows = [moonGlow, moonHalo];
      scene.add(moonGroup);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STARFIELD SKYBOX
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createStarfield() {
      const starCount = isMobile ? 1000 : 3000;
      const starGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        // Distribute on a large sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 380 + Math.random() * 40;
        
        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = Math.abs(radius * Math.cos(phi)); // Only upper hemisphere
        positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        
        // Slight color variation (warm to cool white)
        const temp = 0.8 + Math.random() * 0.4;
        colors[i * 3] = temp;
        colors[i * 3 + 1] = temp * 0.95;
        colors[i * 3 + 2] = temp * (0.8 + Math.random() * 0.2);
        
        sizes[i] = 0.5 + Math.random() * 1.5;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      const starMaterial = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0,
        sizeAttenuation: false,
      });
      
      city.stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(city.stars);
      
      // Create constellations using some of the star positions
      createConstellations(positions);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTELLATION PATTERNS (visible at night, connecting stars)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createConstellations(starPositions) {
      city.constellations = [];
      
      // Define constellation patterns (indices into star positions would be random, so we use fixed sky positions)
      const constellationData = [
        { // Orion-like
          name: 'The Shepherd',
          stars: [
            { x: 200, y: 280, z: -100 },
            { x: 210, y: 300, z: -95 },
            { x: 190, y: 310, z: -105 },
            { x: 205, y: 320, z: -90 },
            { x: 180, y: 295, z: -110 },
            { x: 220, y: 295, z: -85 },
            { x: 200, y: 260, z: -100 },
          ],
          connections: [[0, 1], [1, 2], [1, 3], [0, 4], [0, 5], [0, 6]]
        },
        { // Big Dipper-like
          name: 'The Vessel',
          stars: [
            { x: -150, y: 320, z: 80 },
            { x: -180, y: 310, z: 100 },
            { x: -200, y: 330, z: 120 },
            { x: -170, y: 350, z: 90 },
            { x: -130, y: 340, z: 70 },
            { x: -100, y: 360, z: 50 },
            { x: -70, y: 340, z: 40 },
          ],
          connections: [[0, 1], [1, 2], [2, 3], [3, 0], [3, 4], [4, 5], [5, 6]]
        },
        { // Triangle
          name: 'The Core',
          stars: [
            { x: 50, y: 350, z: 180 },
            { x: 80, y: 380, z: 160 },
            { x: 30, y: 370, z: 200 },
          ],
          connections: [[0, 1], [1, 2], [2, 0]]
        },
        { // Cassiopeia-like W
          name: 'The Wave',
          stars: [
            { x: -80, y: 300, z: -200 },
            { x: -50, y: 320, z: -190 },
            { x: -30, y: 290, z: -180 },
            { x: 0, y: 330, z: -170 },
            { x: 30, y: 300, z: -160 },
          ],
          connections: [[0, 1], [1, 2], [2, 3], [3, 4]]
        },
        { // Cross
          name: 'The Node',
          stars: [
            { x: 280, y: 340, z: 50 },
            { x: 280, y: 380, z: 50 },
            { x: 260, y: 360, z: 60 },
            { x: 300, y: 360, z: 40 },
            { x: 280, y: 320, z: 50 },
          ],
          connections: [[0, 1], [2, 3], [0, 4]]
        },
      ];
      
      const constellationGroup = new THREE.Group();
      constellationGroup.visible = false; // Hidden until night
      
      constellationData.forEach(constellation => {
        const group = new THREE.Group();
        group.userData = { name: constellation.name };
        
        // Add star points
        const starGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(constellation.stars.length * 3);
        constellation.stars.forEach((star, i) => {
          positions[i * 3] = star.x;
          positions[i * 3 + 1] = star.y;
          positions[i * 3 + 2] = star.z;
        });
        starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const starMat = new THREE.PointsMaterial({
          color: 0xffffee,
          size: 3,
          transparent: true,
          opacity: 0.9,
          sizeAttenuation: false,
        });
        const stars = new THREE.Points(starGeo, starMat);
        group.add(stars);
        
        // Add connection lines
        constellation.connections.forEach(([a, b]) => {
          const lineGeo = new THREE.BufferGeometry();
          const linePositions = new Float32Array([
            constellation.stars[a].x, constellation.stars[a].y, constellation.stars[a].z,
            constellation.stars[b].x, constellation.stars[b].y, constellation.stars[b].z,
          ]);
          lineGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
          
          const lineMat = new THREE.LineBasicMaterial({
            color: 0x4488aa,
            transparent: true,
            opacity: 0.3,
          });
          const line = new THREE.Line(lineGeo, lineMat);
          group.add(line);
        });
        
        constellationGroup.add(group);
      });
      
      scene.add(constellationGroup);
      city.constellations = constellationGroup;
    }
    
    /**
     * Update constellation visibility based on night intensity
     */
    function updateConstellations() {
      if (!city.constellations) return;
      
      // Only visible at night
      const visibility = Math.max(0, city.nightIntensity - 0.4) / 0.6;
      city.constellations.visible = visibility > 0.1;
      
      if (city.constellations.visible) {
        city.constellations.children.forEach(group => {
          group.children.forEach(child => {
            if (child.material) {
              if (child.type === 'Points') {
                child.material.opacity = visibility * 0.9;
              } else {
                child.material.opacity = visibility * 0.4;
              }
            }
          });
        });
        
        // Gentle rotation with the stars
        city.constellations.rotation.y += 0.00002;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THOUGHT BUBBLES (floating text/ideas above the city)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Sample thoughts that can appear (pulled from memory, decisions, ideas)
    const SAMPLE_THOUGHTS = [
      'Optimizing memory...',
      'Analyzing patterns',
      'Processing request',
      'Learning adaptation',
      'Strategic planning',
      'Data synthesis',
      'Context building',
      'Evaluating options',
      'Pattern recognition',
      'Neural pathway',
    ];
    
    /**
     * Initialize thought bubble system
     */
    function initThoughtBubbles() {
      city.thoughtsGroup = new THREE.Group();
      scene.add(city.thoughtsGroup);
    }
    
    /**
     * Create a floating thought bubble with CSS2D or sprite
     */
    function createThought(text) {
      // Use canvas texture for the text
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;
      
      // Draw background
      ctx.fillStyle = 'rgba(10, 20, 40, 0.7)';
      ctx.roundRect(0, 0, canvas.width, canvas.height, 8);
      ctx.fill();
      
      // Draw border
      ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
      ctx.lineWidth = 2;
      ctx.roundRect(0, 0, canvas.width, canvas.height, 8);
      ctx.stroke();
      
      // Draw text
      ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
      ctx.font = '18px SF Mono, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text.substring(0, 25), canvas.width / 2, canvas.height / 2);
      
      // Create texture and sprite
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0,
      });
      
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(12, 3, 1);
      
      // Random position above the city
      const angle = Math.random() * Math.PI * 2;
      const radius = 20 + Math.random() * 40;
      sprite.position.set(
        Math.cos(angle) * radius,
        50 + Math.random() * 30,
        Math.sin(angle) * radius
      );
      
      sprite.userData = {
        life: 1,
        fadeIn: true,
        driftSpeed: 0.01 + Math.random() * 0.02,
        driftAngle: Math.random() * Math.PI * 2,
      };
      
      city.thoughtsGroup.add(sprite);
      city.thoughts.push(sprite);
      
      return sprite;
    }
    
    /**
     * Update thought bubbles
     */
    function updateThoughts(dt) {
      if (!city.thoughtsGroup) return;
      
      const now = Date.now();
      
      // Occasionally spawn new thoughts (but not too many)
      if (city.thoughts.length < 3 && now - city.lastThoughtTime > 15000) {
        if (Math.random() < 0.3) {
          const text = SAMPLE_THOUGHTS[Math.floor(Math.random() * SAMPLE_THOUGHTS.length)];
          createThought(text);
          city.lastThoughtTime = now;
        }
      }
      
      // Update existing thoughts
      for (let i = city.thoughts.length - 1; i >= 0; i--) {
        const thought = city.thoughts[i];
        const data = thought.userData;
        
        // Fade in
        if (data.fadeIn) {
          thought.material.opacity = Math.min(1, thought.material.opacity + 0.02);
          if (thought.material.opacity >= 1) {
            data.fadeIn = false;
          }
        }
        
        // Drift upward and sideways
        thought.position.y += data.driftSpeed;
        thought.position.x += Math.sin(data.driftAngle) * 0.01;
        thought.position.z += Math.cos(data.driftAngle) * 0.01;
        
        // Fade out and remove when high
        if (thought.position.y > 85) {
          data.life -= 0.02;
          thought.material.opacity = data.life;
        }
        
        if (data.life <= 0 || thought.position.y > 100) {
          city.thoughtsGroup.remove(thought);
          thought.material.map.dispose();
          thought.material.dispose();
          city.thoughts.splice(i, 1);
        }
      }
    }
    
    /**
     * Add a custom thought (can be called from external API)
     */
    function addThought(text) {
      createThought(text);
      city.lastThoughtTime = Date.now();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HEX GRID GROUND WITH GLOWING ROADS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createGround() {
      // Dark base plane
      const groundGeo = new THREE.PlaneGeometry(250, 250);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a2e,
        roughness: 0.85,
        metalness: 0.15,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Hex grid
      createHexGrid();
      
      // Glowing road network
      createRoadNetwork();
    }
    
    function createHexGrid() {
      const hexRadius = 3;
      const hexHeight = hexRadius * Math.sqrt(3);
      const gridSize = 15;
      
      const hexShape = new THREE.Shape();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
        const x = Math.cos(angle) * hexRadius * 0.95;
        const y = Math.sin(angle) * hexRadius * 0.95;
        if (i === 0) hexShape.moveTo(x, y);
        else hexShape.lineTo(x, y);
      }
      hexShape.closePath();
      
      const hexLineGeo = new THREE.EdgesGeometry(new THREE.ShapeGeometry(hexShape));
      const hexLineMat = new THREE.LineBasicMaterial({
        color: 0x4a6a8a,
        transparent: true,
        opacity: 0.6,
      });
      
      // Instanced hex outlines
      for (let q = -gridSize; q <= gridSize; q++) {
        for (let r = -gridSize; r <= gridSize; r++) {
          if (Math.abs(q + r) > gridSize) continue;
          
          const x = hexRadius * 1.5 * q;
          const z = hexHeight * (r + q / 2);
          
          // Skip center area for core
          if (Math.abs(x) < 8 && Math.abs(z) < 8) continue;
          
          const hexLine = new THREE.LineSegments(hexLineGeo, hexLineMat);
          hexLine.rotation.x = -Math.PI / 2;
          hexLine.position.set(x, 0.05, z);
          scene.add(hexLine);
        }
      }
    }
    
    function createRoadNetwork() {
      const roadMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.15,
      });
      
      const roadGlowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.6,
      });
      
      // Main roads connecting districts
      const districtPositions = Object.values(DISTRICTS).map(d => d.position);
      
      districtPositions.forEach((pos, i) => {
        // Road to center
        createRoadSegment(pos.x, pos.z, 0, 0, roadMaterial, roadGlowMaterial);
        
        // Connect to next district
        const next = districtPositions[(i + 1) % districtPositions.length];
        createRoadSegment(pos.x, pos.z, next.x, next.z, roadMaterial, roadGlowMaterial);
      });
    }
    
    function createRoadSegment(x1, z1, x2, z2, baseMat, glowMat) {
      const length = Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);
      const angle = Math.atan2(z2 - z1, x2 - x1);
      
      // Base road
      const roadGeo = new THREE.PlaneGeometry(length, 1.5);
      const road = new THREE.Mesh(roadGeo, baseMat);
      road.rotation.x = -Math.PI / 2;
      road.rotation.z = -angle;
      road.position.set((x1 + x2) / 2, 0.06, (z1 + z2) / 2);
      scene.add(road);
      
      // Center glow line
      const lineGeo = new THREE.PlaneGeometry(length, 0.15);
      const line = new THREE.Mesh(lineGeo, glowMat);
      line.rotation.x = -Math.PI / 2;
      line.rotation.z = -angle;
      line.position.set((x1 + x2) / 2, 0.08, (z1 + z2) / 2);
      scene.add(line);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NEON ACCENT RINGS - Pulsing ground effects around districts
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createNeonAccentRings() {
      if (isMobile) return;
      
      city.neonRings = [];
      
      // Ring around core
      const coreRings = [
        { radius: 12, color: 0x00ffff, pulseSpeed: 1.0, baseOpacity: 0.35 },
        { radius: 18, color: 0x00ffff, pulseSpeed: 0.8, baseOpacity: 0.2 },
      ];
      
      coreRings.forEach((config, i) => {
        const ringGeo = new THREE.RingGeometry(config.radius - 0.15, config.radius, 64);
        const ringMat = new THREE.MeshBasicMaterial({
          color: config.color,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.1;
        ring.userData = {
          ...config,
          phaseOffset: i * 0.5,
          isNeonRing: true,
        };
        scene.add(ring);
        city.neonRings.push(ring);
      });
      
      // Rings around each district
      Object.entries(DISTRICTS).forEach(([key, district], idx) => {
        if (key === 'core') return;
        
        const ringGeo = new THREE.RingGeometry(14, 15, 32);
        const ringMat = new THREE.MeshBasicMaterial({
          color: district.color.getHex(),
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.set(district.position.x, 0.1, district.position.z);
        ring.userData = {
          radius: 15,
          color: district.color.getHex(),
          pulseSpeed: 0.6 + Math.random() * 0.4,
          baseOpacity: 0.15,
          phaseOffset: idx * 0.7,
          isNeonRing: true,
          districtKey: key,
        };
        scene.add(ring);
        city.neonRings.push(ring);
      });
    }
    
    function updateNeonAccentRings(dt) {
      if (!city.neonRings) return;
      
      city.neonRings.forEach(ring => {
        const data = ring.userData;
        
        // Only visible at night
        const nightVisibility = Math.max(0, city.nightIntensity - 0.2) / 0.8;
        
        // Pulsing effect
        const pulse = Math.sin(dt * data.pulseSpeed + data.phaseOffset) * 0.5 + 0.5;
        
        // Extra glow if this district is active
        let activityBoost = 0;
        if (data.districtKey && activityState.activeDistrict === data.districtKey) {
          activityBoost = 0.3;
        }
        
        ring.material.opacity = (data.baseOpacity + pulse * 0.15 + activityBoost) * nightVisibility;
        
        // Subtle scale pulse
        const scalePulse = 1 + pulse * 0.02;
        ring.scale.set(scalePulse, scalePulse, 1);
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENVIRONMENT â€” Island, Clouds, Horizon
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createEnvironment() {
      // Floating island platform with glowing edge
      const islandRadius = 140;
      const islandGeo = new THREE.CylinderGeometry(islandRadius, islandRadius * 0.85, 8, 64);
      const islandMat = new THREE.MeshStandardMaterial({
        color: 0x0a0a15,
        roughness: 0.9,
        metalness: 0.2,
      });
      const island = new THREE.Mesh(islandGeo, islandMat);
      island.position.y = -4;
      island.receiveShadow = true;
      scene.add(island);
      
      // Glowing edge ring
      const edgeGeo = new THREE.TorusGeometry(islandRadius * 0.92, 0.5, 8, 128);
      const edgeMat = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.4,
      });
      const edge = new THREE.Mesh(edgeGeo, edgeMat);
      edge.rotation.x = Math.PI / 2;
      edge.position.y = -0.5;
      scene.add(edge);
      city.islandEdge = edge;
      
      // Second inner edge
      const edge2Geo = new THREE.TorusGeometry(islandRadius * 0.7, 0.3, 8, 96);
      const edge2 = new THREE.Mesh(edge2Geo, edgeMat.clone());
      edge2.material.opacity = 0.2;
      edge2.rotation.x = Math.PI / 2;
      edge2.position.y = -0.3;
      scene.add(edge2);
      
      // Cloud layer below
      createCloudLayer();
      
      // Horizon glow ring
      createHorizonGlow();
      
      // Distant floating rocks
      createFloatingRocks();
    }
    
    function createCloudLayer() {
      const cloudCount = isMobile ? 30 : 60;
      city.clouds = [];
      
      for (let i = 0; i < cloudCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 80 + Math.random() * 200;
        const size = 15 + Math.random() * 40;
        
        const cloudGeo = new THREE.SphereGeometry(size, 8, 6);
        const cloudMat = new THREE.MeshBasicMaterial({
          color: 0x334455,
          transparent: true,
          opacity: 0.15 + Math.random() * 0.15,
        });
        
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        cloud.position.set(
          Math.cos(angle) * radius,
          -20 - Math.random() * 60,
          Math.sin(angle) * radius
        );
        cloud.scale.set(1, 0.3, 1); // Flatten
        cloud.userData.angle = angle;
        cloud.userData.radius = radius;
        cloud.userData.speed = 0.0001 + Math.random() * 0.0002;
        cloud.userData.baseY = cloud.position.y;
        
        scene.add(cloud);
        city.clouds.push(cloud);
      }
    }
    
    function createHorizonGlow() {
      // Large glowing ring at horizon
      const horizonGeo = new THREE.TorusGeometry(300, 2, 8, 128);
      const horizonMat = new THREE.MeshBasicMaterial({
        color: 0x003355,
        transparent: true,
        opacity: 0.3,
      });
      const horizon = new THREE.Mesh(horizonGeo, horizonMat);
      horizon.rotation.x = Math.PI / 2;
      horizon.position.y = -10;
      scene.add(horizon);
      city.horizonRing = horizon;
      
      // Fog plane at horizon
      const fogGeo = new THREE.RingGeometry(150, 400, 64);
      const fogMat = new THREE.MeshBasicMaterial({
        color: 0x0a1525,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
      });
      const fog = new THREE.Mesh(fogGeo, fogMat);
      fog.rotation.x = -Math.PI / 2;
      fog.position.y = -15;
      scene.add(fog);
    }
    
    function createFloatingRocks() {
      const rockCount = isMobile ? 8 : 15;
      city.floatingRocks = [];
      
      for (let i = 0; i < rockCount; i++) {
        const angle = (i / rockCount) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 180 + Math.random() * 100;
        const size = 3 + Math.random() * 8;
        
        const rockGeo = new THREE.DodecahedronGeometry(size, 0);
        const rockMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a2a,
          roughness: 0.9,
          metalness: 0.1,
          emissive: 0x001122,
          emissiveIntensity: 0.3,
        });
        
        const rock = new THREE.Mesh(rockGeo, rockMat);
        rock.position.set(
          Math.cos(angle) * radius,
          -5 + Math.random() * 30,
          Math.sin(angle) * radius
        );
        rock.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        rock.userData.baseY = rock.position.y;
        rock.userData.floatSpeed = 0.5 + Math.random() * 0.5;
        rock.userData.floatPhase = Math.random() * Math.PI * 2;
        
        scene.add(rock);
        city.floatingRocks.push(rock);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VOLUMETRIC GOD RAYS (Light Shafts from Sky)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createGodRays() {
      if (isMobile) return; // Skip on mobile for performance
      
      city.godRays = [];
      const rayCount = 5;
      
      for (let i = 0; i < rayCount; i++) {
        // Create cone-shaped light shaft
        const rayHeight = 150 + Math.random() * 50;
        const rayTopRadius = 2 + Math.random() * 3;
        const rayBottomRadius = 15 + Math.random() * 20;
        
        const rayGeo = new THREE.CylinderGeometry(rayTopRadius, rayBottomRadius, rayHeight, 8, 1, true);
        const rayMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });
        
        const ray = new THREE.Mesh(rayGeo, rayMat);
        
        // Position rays around the city
        const angle = (i / rayCount) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 30 + Math.random() * 50;
        ray.position.set(
          Math.cos(angle) * radius,
          rayHeight / 2 + 20,
          Math.sin(angle) * radius
        );
        
        // Slight tilt for more natural look
        ray.rotation.x = (Math.random() - 0.5) * 0.1;
        ray.rotation.z = (Math.random() - 0.5) * 0.1;
        
        ray.userData = {
          baseAngle: angle,
          radius: radius,
          phase: Math.random() * Math.PI * 2,
          driftSpeed: 0.0002 + Math.random() * 0.0003,
          pulseSpeed: 0.3 + Math.random() * 0.2,
          maxOpacity: 0.03 + Math.random() * 0.02, // Very subtle
        };
        
        scene.add(ray);
        city.godRays.push(ray);
      }
      
      // Create volumetric dust particles in god rays
      createGodRayParticles();
    }
    
    function createGodRayParticles() {
      const particleCount = 200;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const opacities = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount; i++) {
        // Random position within god ray zones
        const angle = Math.random() * Math.PI * 2;
        const radius = 20 + Math.random() * 60;
        positions[i * 3] = Math.cos(angle) * radius + (Math.random() - 0.5) * 30;
        positions[i * 3 + 1] = 10 + Math.random() * 100;
        positions[i * 3 + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * 30;
        opacities[i] = Math.random();
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));
      
      const material = new THREE.PointsMaterial({
        color: 0xffffee,
        size: 0.3,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      
      city.godRayParticles = new THREE.Points(geometry, material);
      scene.add(city.godRayParticles);
    }
    
    function updateGodRays(dt) {
      if (!city.godRays) return;
      
      // God rays only visible during specific conditions
      const sunVisible = city.nightIntensity < 0.3;
      const goldenHour = lighting.goldenHourIntensity > 0;
      const fogActive = city.weather === 'fog' && city.weatherIntensity > 0.3;
      
      // Best visibility during golden hour or fog
      let visibility = 0;
      if (fogActive) {
        visibility = city.weatherIntensity * 0.8;
      } else if (goldenHour) {
        visibility = lighting.goldenHourIntensity * 0.6;
      } else if (sunVisible) {
        visibility = (1 - city.nightIntensity) * 0.2;
      }
      
      city.godRays.forEach((ray, i) => {
        const data = ray.userData;
        
        // Drift slowly
        data.baseAngle += data.driftSpeed;
        ray.position.x = Math.cos(data.baseAngle) * data.radius;
        ray.position.z = Math.sin(data.baseAngle) * data.radius;
        
        // Pulsing opacity
        const pulse = Math.sin(dt * data.pulseSpeed + data.phase) * 0.5 + 0.5;
        ray.material.opacity = data.maxOpacity * visibility * pulse;
        
        // Color based on time of day
        if (goldenHour) {
          ray.material.color.setHex(0xffddaa); // Warm golden
        } else if (city.nightIntensity > 0.1) {
          ray.material.color.setHex(0x88aaff); // Cool moonlight
        } else {
          ray.material.color.setHex(0xffffff); // Neutral white
        }
      });
      
      // Update god ray particles
      if (city.godRayParticles) {
        const positions = city.godRayParticles.geometry.attributes.position.array;
        
        for (let i = 0; i < positions.length / 3; i++) {
          // Slow drift upward
          positions[i * 3 + 1] += 0.02;
          
          // Slight horizontal drift
          positions[i * 3] += Math.sin(dt + i * 0.1) * 0.005;
          positions[i * 3 + 2] += Math.cos(dt + i * 0.1) * 0.005;
          
          // Reset when too high
          if (positions[i * 3 + 1] > 120) {
            positions[i * 3 + 1] = 10;
          }
        }
        
        city.godRayParticles.geometry.attributes.position.needsUpdate = true;
        city.godRayParticles.material.opacity = visibility * 0.4;
        
        // Match color to rays
        if (goldenHour) {
          city.godRayParticles.material.color.setHex(0xffeecc);
        } else {
          city.godRayParticles.material.color.setHex(0xffffee);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CINEMATIC LIGHTING SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let sunLight, moonLight, ambientLight, hemiLight;
    
    // Lighting state for smooth transitions
    const lighting = {
      targetSunColor: new THREE.Color(),
      targetAmbientColor: new THREE.Color(),
      targetFogColor: new THREE.Color(),
      currentSunColor: new THREE.Color(0xffeedd),
      currentAmbientColor: new THREE.Color(0x111122),
      currentFogColor: new THREE.Color(0x0a0a15),
      goldenHourIntensity: 0,
      rimLightIntensity: 0,
      windowLightProgress: 0, // 0 = day, 1 = fully lit windows
    };
    
    // Color presets for different times of day
    const LIGHT_PRESETS = {
      dawn: {
        sun: new THREE.Color(0xff6633), // Deep orange-red
        ambient: new THREE.Color(0x332244), // Purple-blue
        fog: new THREE.Color(0x1a1525),
        skyHue: 0.05, skySat: 0.7, skyLight: 0.08,
      },
      sunrise: {
        sun: new THREE.Color(0xffaa55), // Warm orange
        ambient: new THREE.Color(0x443322), // Warm brown
        fog: new THREE.Color(0x2a1a15),
        skyHue: 0.08, skySat: 0.6, skyLight: 0.15,
      },
      morning: {
        sun: new THREE.Color(0xffeebb), // Warm white
        ambient: new THREE.Color(0x556677), // Brighter ambient
        fog: new THREE.Color(0x354050),
        skyHue: 0.58, skySat: 0.5, skyLight: 0.45,
      },
      noon: {
        sun: new THREE.Color(0xffffff), // Neutral white
        ambient: new THREE.Color(0x667788), // Bright blue ambient
        fog: new THREE.Color(0x405060),
        skyHue: 0.58, skySat: 0.5, skyLight: 0.55,
      },
      afternoon: {
        sun: new THREE.Color(0xfff5e0), // Slightly warm
        ambient: new THREE.Color(0x556677), // Neutral bright
        fog: new THREE.Color(0x354555),
        skyHue: 0.56, skySat: 0.5, skyLight: 0.4,
      },
      goldenHour: {
        sun: new THREE.Color(0xffcc66), // Golden
        ambient: new THREE.Color(0x553322), // Warm
        fog: new THREE.Color(0x251a10),
        skyHue: 0.07, skySat: 0.65, skyLight: 0.12,
      },
      sunset: {
        sun: new THREE.Color(0xff7744), // Deep orange
        ambient: new THREE.Color(0x442233), // Purple warm
        fog: new THREE.Color(0x201515),
        skyHue: 0.02, skySat: 0.7, skyLight: 0.08,
      },
      dusk: {
        sun: new THREE.Color(0x663355), // Purple
        ambient: new THREE.Color(0x221133), // Deep purple
        fog: new THREE.Color(0x0f0a15),
        skyHue: 0.75, skySat: 0.6, skyLight: 0.04,
      },
      night: {
        sun: new THREE.Color(0x000000), // Off
        ambient: new THREE.Color(0x0a1525), // Cool blue
        fog: new THREE.Color(0x050810),
        skyHue: 0.65, skySat: 0.7, skyLight: 0.01,
      },
    };
    
    function createLighting() {
      // Main sun light with shadows
      sunLight = new THREE.DirectionalLight(0xffeedd, 1);
      if (!isMobile) {
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -60;
        sunLight.shadow.camera.right = 60;
        sunLight.shadow.camera.top = 60;
        sunLight.shadow.camera.bottom = -60;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.normalBias = 0.02;
      }
      scene.add(sunLight);
      
      // Moon light - cooler, softer
      moonLight = new THREE.DirectionalLight(0x3355aa, 0.3);
      moonLight.position.set(30, 50, -40);
      scene.add(moonLight);
      
      // Ambient light - fills shadows
      ambientLight = new THREE.AmbientLight(0x334455, 0.8);
      scene.add(ambientLight);
      
      // Hemisphere light - sky/ground color influence
      hemiLight = new THREE.HemisphereLight(0x2244aa, 0x221100, 0.2);
      scene.add(hemiLight);
      
      // City glow light - warm light from below to simulate street lights at night
      // This light will be controlled by nightIntensity
      lighting.cityGlowLight = new THREE.PointLight(0xffaa66, 0, 150);
      lighting.cityGlowLight.position.set(0, -10, 0);
      scene.add(lighting.cityGlowLight);
    }
    
    // Smooth interpolation helper
    function smoothstep(x) {
      return x * x * (3 - 2 * x);
    }
    
    // Get lighting preset blend based on hour
    function getLightingBlend(hours) {
      // Define time ranges for each phase
      const phases = [
        { start: 0, end: 5, preset: 'night' },
        { start: 5, end: 6, preset: 'dawn', nextPreset: 'sunrise' },
        { start: 6, end: 7.5, preset: 'sunrise', nextPreset: 'morning' },
        { start: 7.5, end: 11, preset: 'morning', nextPreset: 'noon' },
        { start: 11, end: 14, preset: 'noon' },
        { start: 14, end: 17, preset: 'afternoon', nextPreset: 'goldenHour' },
        { start: 17, end: 18.5, preset: 'goldenHour', nextPreset: 'sunset' },
        { start: 18.5, end: 20, preset: 'sunset', nextPreset: 'dusk' },
        { start: 20, end: 21.5, preset: 'dusk', nextPreset: 'night' },
        { start: 21.5, end: 24, preset: 'night' },
      ];
      
      for (const phase of phases) {
        if (hours >= phase.start && hours < phase.end) {
          if (phase.nextPreset) {
            const t = (hours - phase.start) / (phase.end - phase.start);
            return { from: phase.preset, to: phase.nextPreset, blend: smoothstep(t) };
          }
          return { from: phase.preset, to: phase.preset, blend: 0 };
        }
      }
      return { from: 'night', to: 'night', blend: 0 };
    }
    
    // Blend two colors
    function blendColors(color1, color2, t) {
      const result = new THREE.Color();
      result.r = color1.r + (color2.r - color1.r) * t;
      result.g = color1.g + (color2.g - color1.g) * t;
      result.b = color1.b + (color2.b - color1.b) * t;
      return result;
    }
    
    function updateLighting() {
      const now = new Date();
      const hours = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
      
      timeDisplayEl.textContent = now.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
      
      // Calculate sun position (rises at 6, sets at 18)
      const sunAngle = ((hours - 6) / 24) * Math.PI * 2;
      const sunHeight = Math.sin(sunAngle);
      const sunAzimuth = Math.cos(sunAngle);
      
      // Sun position in world space
      const sunDistance = 80;
      const sunX = sunAzimuth * sunDistance * 0.8;
      const sunY = Math.max(sunHeight * sunDistance, -30);
      const sunZ = 40;
      sunLight.position.set(sunX, sunY, sunZ);
      
      // Update GOD RAYS based on sun position (project sun to screen space)
      if (postProcessing.godRaysPass && !isMobile) {
        const sunVector = new THREE.Vector3(sunX, sunY, sunZ);
        sunVector.project(camera);
        
        // Convert to 0-1 UV space
        const screenX = (sunVector.x + 1) / 2;
        const screenY = (sunVector.y + 1) / 2;
        
        postProcessing.godRaysPass.uniforms.lightPosition.value.set(screenX, screenY);
        
        // Only show god rays when sun is visible and above horizon
        const sunVisible = sunHeight > 0 && sunVector.z < 1;
        const inFrame = screenX > -0.2 && screenX < 1.2 && screenY > -0.2 && screenY < 1.2;
        
        // Stronger during golden hour for dramatic effect
        const baseIntensity = sunVisible && inFrame ? Math.max(0, sunHeight) : 0;
        const isNearGoldenHour = (hours >= 6 && hours <= 7.5) || (hours >= 17 && hours <= 19);
        const goldenBoost = isNearGoldenHour ? 0.4 : 0;
        postProcessing.godRaysPass.uniforms.lightIntensity.value = 
          Math.min(1, baseIntensity * 0.6 + goldenBoost);
      }
      
      // Moon opposite to sun, slightly offset
      moonLight.position.set(-sunX * 0.8, -sunY + 60, -sunZ * 0.7);
      
      // Get current lighting preset blend
      const { from, to, blend } = getLightingBlend(hours);
      const fromPreset = LIGHT_PRESETS[from];
      const toPreset = LIGHT_PRESETS[to];
      
      // Blend target colors
      lighting.targetSunColor = blendColors(fromPreset.sun, toPreset.sun, blend);
      lighting.targetAmbientColor = blendColors(fromPreset.ambient, toPreset.ambient, blend);
      lighting.targetFogColor = blendColors(fromPreset.fog, toPreset.fog, blend);
      
      // Smooth transition (lerp current toward target)
      const colorLerpSpeed = 0.02;
      lighting.currentSunColor.lerp(lighting.targetSunColor, colorLerpSpeed);
      lighting.currentAmbientColor.lerp(lighting.targetAmbientColor, colorLerpSpeed);
      lighting.currentFogColor.lerp(lighting.targetFogColor, colorLerpSpeed);
      
      // Apply colors to lights
      sunLight.color.copy(lighting.currentSunColor);
      ambientLight.color.copy(lighting.currentAmbientColor);
      
      // Calculate intensities
      const dayProgress = Math.max(0, sunHeight); // 0 at horizon, 1 at noon
      const horizonFactor = Math.abs(sunHeight); // Low at horizon
      
      // Sun intensity: parabolic curve, brightest at noon
      const sunIntensityBase = Math.pow(dayProgress, 0.6); // Softer falloff
      sunLight.intensity = sunIntensityBase * 2.0;
      
      // Night intensity for other systems
      city.nightIntensity = Math.max(0, -sunHeight);
      const twilightIntensity = (1 - Math.abs(sunHeight)) * (sunHeight < 0.3 ? 1 : 0);
      
      // Moon intensity - stronger when sun is down
      moonLight.intensity = city.nightIntensity * 0.7;
      moonLight.color.setHSL(0.6, 0.5, 0.6 + city.nightIntensity * 0.2);
      
      // Ambient intensity - never fully dark, boosted at night for city glow
      ambientLight.intensity = 0.7 + dayProgress * 0.5 + city.nightIntensity * 0.5;
      
      // City glow effect at night - warm light from below simulating street lights
      if (city.nightIntensity > 0.2) {
        const cityGlow = city.nightIntensity * 0.4;
        hemiLight.groundColor.setHSL(0.08, 0.6, 0.15 + cityGlow);
        
        // Activate the city glow point light
        if (lighting.cityGlowLight) {
          lighting.cityGlowLight.intensity = city.nightIntensity * 1.5;
        }
      } else {
        if (lighting.cityGlowLight) {
          lighting.cityGlowLight.intensity = 0;
        }
      }
      
      // Hemisphere light adapts to time
      const skyBlend = blend;
      const skyHue = fromPreset.skyHue + (toPreset.skyHue - fromPreset.skyHue) * skyBlend;
      const skySat = fromPreset.skySat + (toPreset.skySat - fromPreset.skySat) * skyBlend;
      const skyLight_l = fromPreset.skyLight + (toPreset.skyLight - fromPreset.skyLight) * skyBlend;
      
      hemiLight.color.setHSL(skyHue, skySat, skyLight_l + 0.1);
      hemiLight.groundColor.setHSL(0.08, 0.4, 0.08 + dayProgress * 0.06);
      hemiLight.intensity = 0.15 + dayProgress * 0.15;
      
      // Shadow softness varies with sun angle (lower sun = softer shadows)
      if (!isMobile && sunLight.shadow) {
        const shadowRadius = 1 + (1 - horizonFactor) * 3; // 1-4 range
        sunLight.shadow.radius = shadowRadius;
      }
      
      // Sky color
      scene.background = new THREE.Color().setHSL(skyHue, skySat, skyLight_l);
      
      // Fog color and density
      scene.fog.color.copy(lighting.currentFogColor);
      // Denser fog at night (mystery), lighter during day
      scene.fog.density = 0.004 + city.nightIntensity * 0.003 + twilightIntensity * 0.001;
      
      // Stars visibility - fade in during dusk, full at night
      if (city.stars) {
        const starVisibility = Math.max(0, city.nightIntensity * 1.2 - 0.1);
        city.stars.material.opacity = Math.min(0.9, starVisibility);
      }
      
      // Constellation visibility
      updateConstellations();
      
      // Golden hour detection (1 hour before/after sunset/sunrise)
      const isGoldenHour = (hours >= 6 && hours <= 7.5) || (hours >= 17 && hours <= 19);
      lighting.goldenHourIntensity = isGoldenHour ? 
        (1 - Math.abs((hours > 12 ? hours - 18 : hours - 6.75)) / 1.5) : 0;
      lighting.goldenHourIntensity = Math.max(0, Math.min(1, lighting.goldenHourIntensity));
      
      // Rim lighting intensity (strong at sunrise/sunset when sun is low)
      lighting.rimLightIntensity = (sunHeight > -0.1 && sunHeight < 0.3) ? 
        (1 - Math.abs(sunHeight - 0.1) / 0.4) : 0;
      
      // Window light progress - gradual transition
      const targetWindowLight = city.nightIntensity > 0.1 ? 
        Math.min(1, (city.nightIntensity - 0.1) / 0.5) : 0;
      lighting.windowLightProgress += (targetWindowLight - lighting.windowLightProgress) * 0.01;
      
      // Bloom: AAA-quality vibrant city lights (MAXIMIZED for cyberpunk/video game feel)
      const baseBloom = isMobile ? 0.5 : 0.8;
      const nightBloom = city.nightIntensity * (isMobile ? 1.2 : 2.0); // Much stronger night bloom
      const goldenBloom = lighting.goldenHourIntensity * 0.6;
      const actionBloom = activityState.mode !== 'idle' ? 0.3 : 0; // Extra bloom during activity
      bloomPass.strength = baseBloom + nightBloom + goldenBloom + actionBloom;
      bloomPass.threshold = 0.7 - city.nightIntensity * 0.35; // Even lower threshold for more glow
      bloomPass.radius = 0.6 + city.nightIntensity * 0.5; // Much wider bloom at night for dreamy city glow
      
      // Tone mapping exposure - maintain brightness at night for city glow
      renderer.toneMappingExposure = 0.9 + dayProgress * 0.3 + city.nightIntensity * 0.1;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SKY DOME UPDATE - Dynamic gradient based on time of day
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.skyUniforms) {
        // Calculate sky colors based on time
        let topColor, middleColor, horizonColor, horizonGlow, glowIntensity;
        
        if (hours >= 5 && hours < 7) {
          // SUNRISE - purple â†’ orange â†’ pink
          const t = (hours - 5) / 2;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x0a0520), new THREE.Color(0x2244aa), t
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2a1050), new THREE.Color(0x5588cc), t
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x883355), new THREE.Color(0xffaa77), t
          );
          horizonGlow = new THREE.Color().lerpColors(
            new THREE.Color(0xcc6655), new THREE.Color(0xffcc99), t
          );
          glowIntensity = 0.7 - t * 0.3;
        } else if (hours >= 7 && hours < 17) {
          // DAYTIME - deep blue â†’ lighter blue
          const morningT = Math.min(1, (hours - 7) / 3);
          topColor = new THREE.Color(0x1155bb);
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x4488dd), new THREE.Color(0x3377cc), morningT
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x99ccff), new THREE.Color(0x88bbee), morningT
          );
          horizonGlow = new THREE.Color(0xaaddff);
          glowIntensity = 0.2;
        } else if (hours >= 17 && hours < 20) {
          // SUNSET - blue â†’ orange â†’ red â†’ purple
          const t = (hours - 17) / 3;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2244aa), new THREE.Color(0x1a1040), t
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x6677aa), new THREE.Color(0x552255), t
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0xffaa66), new THREE.Color(0xff5533), t
          );
          horizonGlow = new THREE.Color().lerpColors(
            new THREE.Color(0xffcc88), new THREE.Color(0xff7744), t
          );
          glowIntensity = 0.5 + t * 0.3;
        } else {
          // NIGHT - dark blue/purple
          const nightT = hours >= 20 ? Math.min(1, (hours - 20) / 2) : 1;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x0a0820), new THREE.Color(0x050510), nightT
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x151230), new THREE.Color(0x080815), nightT
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2a2040), new THREE.Color(0x101020), nightT
          );
          horizonGlow = new THREE.Color(0x1a1530);
          glowIntensity = 0.15;
        }
        
        // Apply to sky dome shader
        city.skyUniforms.topColor.value.copy(topColor);
        city.skyUniforms.middleColor.value.copy(middleColor);
        city.skyUniforms.horizonColor.value.copy(horizonColor);
        city.skyUniforms.horizonGlow.value.copy(horizonGlow);
        city.skyUniforms.glowIntensity.value = glowIntensity;
        city.skyUniforms.horizonSharpness.value = isGoldenHour ? 2.0 : 4.0;
        city.skyUniforms.sunY.value = sunHeight;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SUN MESH UPDATE - Position and visibility
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.sun) {
        const celestialRadius = 350;
        const sunMeshX = sunAzimuth * celestialRadius * 0.7;
        const sunMeshY = Math.max(sunHeight * celestialRadius * 0.8, -100);
        const sunMeshZ = 100;
        
        city.sun.position.set(sunMeshX, sunMeshY, sunMeshZ);
        
        // Larger sun at horizon (atmospheric lensing effect)
        const horizonScale = 1 + (1 - Math.abs(sunHeight)) * 0.4;
        const visibility = Math.max(0, sunHeight + 0.15);
        city.sun.scale.setScalar(horizonScale * Math.max(0.01, visibility));
        
        // Update sun colors based on time
        if (city.sunCore) {
          let sunCoreColor;
          if (hours >= 5 && hours < 7) {
            sunCoreColor = new THREE.Color(0xffaa55); // Orange sunrise
          } else if (hours >= 7 && hours < 17) {
            sunCoreColor = new THREE.Color(0xffffee); // Bright white day
          } else if (hours >= 17 && hours < 20) {
            const t = (hours - 17) / 3;
            sunCoreColor = new THREE.Color().lerpColors(
              new THREE.Color(0xffdd77), new THREE.Color(0xff5522), t
            );
          } else {
            sunCoreColor = new THREE.Color(0x000000);
          }
          city.sunCore.material.color.copy(sunCoreColor);
          city.sunCore.material.opacity = visibility;
          
          // Update glow colors too
          city.sunGlows.forEach((glow, i) => {
            glow.material.color.copy(sunCoreColor);
            glow.material.opacity = [0.4, 0.2, 0.1][i] * visibility;
          });
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MOON MESH UPDATE - Position and visibility  
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.moon) {
        const moonAngle = sunAngle + Math.PI;
        const moonHeight = Math.sin(moonAngle);
        const moonAzimuth = Math.cos(moonAngle);
        const celestialRadius = 320;
        
        const moonMeshX = moonAzimuth * celestialRadius * 0.7;
        const moonMeshY = Math.max(moonHeight * celestialRadius * 0.6, -80);
        const moonMeshZ = -80;
        
        city.moon.position.set(moonMeshX, moonMeshY, moonMeshZ);
        
        const moonVisibility = Math.max(0, moonHeight + 0.1);
        city.moon.scale.setScalar(Math.max(0.01, moonVisibility));
        
        if (city.moonCore) {
          city.moonCore.material.opacity = moonVisibility * 0.95;
          city.moonGlows.forEach((glow, i) => {
            glow.material.opacity = [0.25, 0.1][i] * moonVisibility;
          });
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CLOUD COLOR UPDATE - Based on time of day
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (city.clouds) {
        let cloudColor;
        if (hours >= 5 && hours < 7) {
          // Sunrise - pink/orange clouds
          const t = (hours - 5) / 2;
          cloudColor = new THREE.Color().lerpColors(
            new THREE.Color(0x332233), new THREE.Color(0xff8866), t
          );
        } else if (hours >= 7 && hours < 17) {
          // Day - white/light gray
          cloudColor = new THREE.Color(0xccddee);
        } else if (hours >= 17 && hours < 20) {
          // Sunset - dramatic oranges/pinks
          const t = (hours - 17) / 3;
          cloudColor = new THREE.Color().lerpColors(
            new THREE.Color(0xffaa77), new THREE.Color(0xff6644), t
          );
        } else {
          // Night - dark
          cloudColor = new THREE.Color(0x1a1a25);
        }
        
        city.clouds.forEach(cloud => {
          cloud.material.color.copy(cloudColor);
          // Vary opacity
          const baseOpacity = 0.12;
          const goldenBoost = isGoldenHour ? 0.15 : 0;
          cloud.material.opacity = baseOpacity + goldenBoost - city.nightIntensity * 0.04;
        });
      }
      
      // Disable scene.background since we have sky dome
      scene.background = null;
      
      // Cycle phase display
      let phase = 'night';
      if (hours >= 5 && hours < 6) phase = 'dawn';
      else if (hours >= 6 && hours < 7.5) phase = 'sunrise';
      else if (hours >= 7.5 && hours < 11) phase = 'morning';
      else if (hours >= 11 && hours < 14) phase = 'noon';
      else if (hours >= 14 && hours < 17) phase = 'afternoon';
      else if (hours >= 17 && hours < 18.5) phase = 'golden hour';
      else if (hours >= 18.5 && hours < 20) phase = 'sunset';
      else if (hours >= 20 && hours < 21.5) phase = 'dusk';
      cyclePhaseEl.textContent = phase;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ARCHITECTURAL BUILDING STYLES - Defines building appearance by function
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const BUILDING_STYLES = {
      office: {
        windowDensity: 0.85,        // Many windows
        windowSize: 0.7,            // Larger windows (glass curtain wall)
        windowSpacing: 1.2,         // Tight grid
        glassReflectivity: 0.7,     // Reflective glass
        colorTint: 0x4488cc,        // Blue tint
        hasSetbacks: true,          // Tall ones step back
        crownStyle: 'flat',         // Flat or antenna tops
        baseStyle: 'lobby',         // Glass lobby entrance
      },
      residential: {
        windowDensity: 0.6,
        windowSize: 0.4,            // Smaller windows
        windowSpacing: 1.8,         // More spacing
        glassReflectivity: 0.3,
        colorTint: 0xddaa77,        // Warm brown/beige
        hasSetbacks: false,
        crownStyle: 'cornice',      // Decorative top edge
        baseStyle: 'brick',
      },
      industrial: {
        windowDensity: 0.25,        // Few windows
        windowSize: 0.5,
        windowSpacing: 3.0,         // Sparse
        glassReflectivity: 0.2,
        colorTint: 0x556677,        // Gray/metallic
        hasSetbacks: false,
        crownStyle: 'utilitarian',  // Pipes, vents
        baseStyle: 'loading',       // Loading dock
      },
      landmark: {
        windowDensity: 0.5,
        windowSize: 0.6,
        windowSpacing: 1.5,
        glassReflectivity: 0.5,
        colorTint: 0xaaccff,        // Light blue/white
        hasSetbacks: true,
        crownStyle: 'spire',        // Decorative spire/crown
        baseStyle: 'grand',         // Grand entrance
      },
      mixed: {
        windowDensity: 0.7,
        windowSize: 0.5,
        windowSpacing: 1.5,
        glassReflectivity: 0.4,
        colorTint: 0x888888,
        hasSetbacks: false,
        crownStyle: 'flat',
        baseStyle: 'retail',        // Ground floor retail
      }
    };
    
    // Building shape types
    const BUILDING_SHAPES = {
      tower: 'box',
      cylinder: 'cylinder',
      tapered: 'tapered',
      hexPrism: 'hex',
      octagon: 'octagon',
      lShape: 'lShape',
      uShape: 'uShape',
    };
    
    // Get building style based on district
    function getBuildingStyle(district, height) {
      const styleWeights = {
        core: { landmark: 3, office: 4, mixed: 2 },
        trading: { office: 5, landmark: 2, mixed: 2 },
        infrastructure: { industrial: 4, office: 2, mixed: 1 },
        projects: { office: 3, mixed: 3, landmark: 2 },
        memory: { residential: 3, mixed: 2, landmark: 1 },
      };
      
      const weights = styleWeights[district] || { mixed: 1 };
      const styles = Object.keys(weights);
      const total = Object.values(weights).reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      
      for (const style of styles) {
        r -= weights[style];
        if (r <= 0) return style;
      }
      return 'mixed';
    }
    
    function getRandomBuildingShape() {
      const shapes = ['tower', 'tower', 'tower', 'cylinder', 'tapered', 'hexPrism', 'octagon', 'lShape'];
      return shapes[Math.floor(Math.random() * shapes.length)];
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ARCHITECTURAL DETAIL GENERATORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Create window grid on a face
    function createWindowGrid(faceWidth, faceHeight, style, districtColor, isMainFace = true) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      
      // Calculate window grid
      const windowSize = styleData.windowSize;
      const spacing = styleData.windowSpacing;
      const cols = Math.max(1, Math.floor(faceWidth / spacing));
      const rows = Math.max(1, Math.floor(faceHeight / spacing));
      
      // Skip on mobile if too many windows
      const maxWindows = isMobile ? 30 : 100;
      if (cols * rows > maxWindows) {
        // Use merged geometry for performance
        return createMergedWindowGrid(faceWidth, faceHeight, style, districtColor, cols, rows);
      }
      
      const windowGeo = new THREE.PlaneGeometry(windowSize * 0.8, windowSize * 1.2);
      
      for (let col = 0; col < cols; col++) {
        for (let row = 0; row < rows; row++) {
          // Skip some windows randomly for variety
          if (Math.random() > styleData.windowDensity) continue;
          
          const isLit = Math.random() > 0.4;
          const windowMat = new THREE.MeshBasicMaterial({
            color: isLit ? 
              new THREE.Color(styleData.colorTint).lerp(districtColor, 0.3) : 
              new THREE.Color(0x111122),
            transparent: true,
            opacity: isLit ? (0.4 + Math.random() * 0.4) : 0.15,
            side: THREE.DoubleSide,
          });
          
          const window = new THREE.Mesh(windowGeo, windowMat);
          
          // Position in grid
          const xPos = (col - (cols - 1) / 2) * spacing;
          const yPos = (row - (rows - 1) / 2) * spacing;
          window.position.set(xPos, yPos, 0.02);
          
          // Add subtle frame
          if (!isMobile && Math.random() > 0.5) {
            const frameGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(windowSize * 0.85, windowSize * 1.25));
            const frameMat = new THREE.LineBasicMaterial({ 
              color: 0x334455, 
              transparent: true, 
              opacity: 0.5 
            });
            const frame = new THREE.LineSegments(frameGeo, frameMat);
            frame.position.copy(window.position);
            frame.position.z += 0.01;
            group.add(frame);
          }
          
          group.add(window);
        }
      }
      
      return group;
    }
    
    // Merged window grid for performance
    function createMergedWindowGrid(faceWidth, faceHeight, style, districtColor, cols, rows) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const spacing = styleData.windowSpacing;
      
      // Create horizontal floor lines
      const floorCount = Math.min(rows, 15);
      const floorSpacing = faceHeight / floorCount;
      
      for (let i = 1; i < floorCount; i++) {
        const lineGeo = new THREE.PlaneGeometry(faceWidth * 0.9, 0.05);
        const lineMat = new THREE.MeshBasicMaterial({
          color: districtColor,
          transparent: true,
          opacity: 0.3,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.y = -faceHeight / 2 + i * floorSpacing;
        line.position.z = 0.02;
        group.add(line);
      }
      
      // Add vertical column lines
      const colCount = Math.min(cols, 8);
      const colSpacing = faceWidth / colCount;
      
      for (let i = 1; i < colCount; i++) {
        const lineGeo = new THREE.PlaneGeometry(0.08, faceHeight * 0.95);
        const lineMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(styleData.colorTint).multiplyScalar(0.5),
          transparent: true,
          opacity: 0.4,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.x = -faceWidth / 2 + i * colSpacing;
        line.position.z = 0.02;
        group.add(line);
      }
      
      // Add glow overlay
      const glowGeo = new THREE.PlaneGeometry(faceWidth * 0.95, faceHeight * 0.95);
      const glowMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.15,
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.z = 0.01;
      group.add(glow);
      
      return group;
    }
    
    // Create building base/foundation section
    function createBuildingBase(width, depth, style, districtColor) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const baseHeight = 1.5 + Math.random() * 1;
      const baseExpand = 0.15; // How much wider the base is
      
      // Main base block
      const baseGeo = new THREE.BoxGeometry(
        width * (1 + baseExpand), 
        baseHeight, 
        depth * (1 + baseExpand)
      );
      const baseMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(styleData.colorTint).multiplyScalar(0.15),
        roughness: 0.8,
        metalness: 0.2,
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = baseHeight / 2;
      base.castShadow = !isMobile;
      group.add(base);
      
      // Entrance glow (lobby/door)
      if (styleData.baseStyle === 'lobby' || styleData.baseStyle === 'grand') {
        const entranceWidth = width * 0.4;
        const entranceHeight = baseHeight * 0.8;
        const entranceGeo = new THREE.PlaneGeometry(entranceWidth, entranceHeight);
        const entranceMat = new THREE.MeshBasicMaterial({
          color: districtColor,
          transparent: true,
          opacity: 0.6,
        });
        const entrance = new THREE.Mesh(entranceGeo, entranceMat);
        entrance.position.set(0, entranceHeight / 2 + 0.1, depth * (1 + baseExpand) / 2 + 0.02);
        group.add(entrance);
      }
      
      // Decorative ledge line
      const ledgeGeo = new THREE.BoxGeometry(width * (1 + baseExpand) + 0.1, 0.15, depth * (1 + baseExpand) + 0.1);
      const ledgeMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.4,
      });
      const ledge = new THREE.Mesh(ledgeGeo, ledgeMat);
      ledge.position.y = baseHeight;
      group.add(ledge);
      
      group.userData.baseHeight = baseHeight;
      return group;
    }
    
    // Create building crown/top section
    function createBuildingCrown(width, depth, height, style, districtColor) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const crownStyle = styleData.crownStyle;
      
      if (crownStyle === 'spire' && height > 15) {
        // Decorative spire
        const spireHeight = 3 + Math.random() * 4;
        const spireGeo = new THREE.ConeGeometry(width * 0.2, spireHeight, 6);
        const spireMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(styleData.colorTint).multiplyScalar(0.3),
          emissive: districtColor,
          emissiveIntensity: 0.8,
          metalness: 0.7,
          roughness: 0.3,
        });
        const spire = new THREE.Mesh(spireGeo, spireMat);
        spire.position.y = spireHeight / 2;
        group.add(spire);
        
        // Spire tip light
        const tipGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const tipMat = new THREE.MeshBasicMaterial({ color: districtColor });
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.position.y = spireHeight + 0.2;
        tip.userData.pulse = true;
        tip.userData.pulsePhase = Math.random() * Math.PI * 2;
        group.add(tip);
        
      } else if (crownStyle === 'cornice') {
        // Decorative cornice edge
        const corniceGeo = new THREE.BoxGeometry(width + 0.3, 0.4, depth + 0.3);
        const corniceMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(styleData.colorTint).multiplyScalar(0.4),
          roughness: 0.6,
          metalness: 0.3,
        });
        const cornice = new THREE.Mesh(corniceGeo, corniceMat);
        cornice.position.y = 0.2;
        group.add(cornice);
        
        // Small decorative elements
        for (let i = 0; i < 4; i++) {
          const ornGeo = new THREE.BoxGeometry(0.3, 0.6, 0.3);
          const ornMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(styleData.colorTint).multiplyScalar(0.35),
            emissive: districtColor,
            emissiveIntensity: 0.5,
          });
          const orn = new THREE.Mesh(ornGeo, ornMat);
          const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
          orn.position.set(
            Math.cos(angle) * (width / 2),
            0.5,
            Math.sin(angle) * (depth / 2)
          );
          group.add(orn);
        }
        
      } else if (crownStyle === 'utilitarian') {
        // Industrial: pipes, vents
        const ventCount = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < ventCount; i++) {
          const ventGeo = new THREE.CylinderGeometry(0.3, 0.3, 1 + Math.random(), 6);
          const ventMat = new THREE.MeshStandardMaterial({
            color: 0x445566,
            roughness: 0.9,
            metalness: 0.4,
          });
          const vent = new THREE.Mesh(ventGeo, ventMat);
          vent.position.set(
            (Math.random() - 0.5) * width * 0.7,
            0.5 + Math.random() * 0.3,
            (Math.random() - 0.5) * depth * 0.7
          );
          group.add(vent);
        }
      }
      
      return group;
    }
    
    // Create setback (narrower upper section for tall buildings)
    function createSetback(width, depth, setbackHeight, style, districtColor) {
      const group = new THREE.Group();
      const styleData = BUILDING_STYLES[style];
      const reduction = 0.7 + Math.random() * 0.15; // 70-85% of original size
      
      const setbackWidth = width * reduction;
      const setbackDepth = depth * reduction;
      
      // Main setback body
      const bodyGeo = new THREE.BoxGeometry(setbackWidth, setbackHeight, setbackDepth);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(styleData.colorTint).multiplyScalar(0.2),
        emissive: new THREE.Color(styleData.colorTint).multiplyScalar(0.1),
        emissiveIntensity: 0.6,
        roughness: 0.5,
        metalness: 0.5,
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = !isMobile;
      body.receiveShadow = !isMobile;
      group.add(body);
      
      // Windows on setback
      if (!isMobile) {
        const faces = [
          { rot: 0, pos: [0, 0, setbackDepth / 2 + 0.01], w: setbackWidth, h: setbackHeight },
          { rot: Math.PI, pos: [0, 0, -setbackDepth / 2 - 0.01], w: setbackWidth, h: setbackHeight },
          { rot: Math.PI / 2, pos: [setbackWidth / 2 + 0.01, 0, 0], w: setbackDepth, h: setbackHeight },
          { rot: -Math.PI / 2, pos: [-setbackWidth / 2 - 0.01, 0, 0], w: setbackDepth, h: setbackHeight },
        ];
        
        faces.forEach(face => {
          const windows = createWindowGrid(face.w * 0.9, face.h * 0.9, style, districtColor, false);
          windows.rotation.y = face.rot;
          windows.position.set(...face.pos);
          group.add(windows);
        });
      }
      
      // Ledge at setback base
      const ledgeGeo = new THREE.BoxGeometry(width + 0.1, 0.2, depth + 0.1);
      const ledgeMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.35,
      });
      const ledge = new THREE.Mesh(ledgeGeo, ledgeMat);
      ledge.position.y = -setbackHeight / 2;
      group.add(ledge);
      
      group.userData.setbackWidth = setbackWidth;
      group.userData.setbackDepth = setbackDepth;
      
      return group;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROOFTOP FEATURES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function addACUnits(group, width, depth) {
      const unitCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < unitCount; i++) {
        const unitGeo = new THREE.BoxGeometry(0.8, 0.5, 0.6);
        const unitMat = new THREE.MeshStandardMaterial({
          color: 0x556666,
          roughness: 0.8,
          metalness: 0.3,
        });
        const unit = new THREE.Mesh(unitGeo, unitMat);
        unit.position.set(
          (Math.random() - 0.5) * width * 0.6,
          0.25,
          (Math.random() - 0.5) * depth * 0.6
        );
        group.add(unit);
        
        // Fan on top
        const fanGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 8);
        const fanMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
        const fan = new THREE.Mesh(fanGeo, fanMat);
        fan.position.y = 0.3;
        unit.add(fan);
      }
    }
    
    function addWaterTower(group, width, depth, districtColor) {
      const towerGroup = new THREE.Group();
      
      // Tank
      const tankGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 12);
      const tankMat = new THREE.MeshStandardMaterial({
        color: 0x445566,
        roughness: 0.7,
        metalness: 0.4,
      });
      const tank = new THREE.Mesh(tankGeo, tankMat);
      tank.position.y = 1.5;
      towerGroup.add(tank);
      
      // Cone top
      const topGeo = new THREE.ConeGeometry(0.9, 0.6, 12);
      const topMat = new THREE.MeshStandardMaterial({ color: 0x334455 });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = 2.55;
      towerGroup.add(top);
      
      // Legs
      for (let i = 0; i < 4; i++) {
        const legGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 4);
        const legMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
        const leg = new THREE.Mesh(legGeo, legMat);
        const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
        leg.position.set(
          Math.cos(angle) * 0.5,
          0.4,
          Math.sin(angle) * 0.5
        );
        towerGroup.add(leg);
      }
      
      towerGroup.position.set(
        (Math.random() - 0.5) * width * 0.5,
        0,
        (Math.random() - 0.5) * depth * 0.5
      );
      group.add(towerGroup);
    }
    
    function addHelipad(group, width, depth, districtColor) {
      // Pad surface
      const padSize = Math.min(width, depth) * 0.8;
      const padGeo = new THREE.CylinderGeometry(padSize / 2, padSize / 2, 0.1, 16);
      const padMat = new THREE.MeshStandardMaterial({
        color: 0x222233,
        roughness: 0.9,
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.y = 0.05;
      group.add(pad);
      
      // H marking
      const hMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.8,
      });
      
      // Vertical bars of H
      const barGeo = new THREE.PlaneGeometry(0.3, padSize * 0.5);
      const bar1 = new THREE.Mesh(barGeo, hMat);
      bar1.rotation.x = -Math.PI / 2;
      bar1.position.set(-padSize * 0.15, 0.12, 0);
      group.add(bar1);
      
      const bar2 = new THREE.Mesh(barGeo, hMat);
      bar2.rotation.x = -Math.PI / 2;
      bar2.position.set(padSize * 0.15, 0.12, 0);
      group.add(bar2);
      
      // Horizontal bar of H
      const hBarGeo = new THREE.PlaneGeometry(padSize * 0.3, 0.25);
      const hBar = new THREE.Mesh(hBarGeo, hMat);
      hBar.rotation.x = -Math.PI / 2;
      hBar.position.y = 0.12;
      group.add(hBar);
      
      // Edge lights
      const lightCount = 8;
      for (let i = 0; i < lightCount; i++) {
        const angle = (i / lightCount) * Math.PI * 2;
        const lightGeo = new THREE.SphereGeometry(0.1, 4, 4);
        const lightMat = new THREE.MeshBasicMaterial({
          color: districtColor,
          transparent: true,
          opacity: 0.9,
        });
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.set(
          Math.cos(angle) * (padSize / 2 - 0.15),
          0.15,
          Math.sin(angle) * (padSize / 2 - 0.15)
        );
        light.userData.pulse = true;
        light.userData.pulsePhase = i * Math.PI / 4;
        group.add(light);
      }
    }
    
    function addRooftopGarden(group, width, depth) {
      const gardenGeo = new THREE.BoxGeometry(width * 0.6, 0.3, depth * 0.6);
      const gardenMat = new THREE.MeshBasicMaterial({
        color: 0x2d5a2d,
        transparent: true,
        opacity: 0.9,
      });
      const garden = new THREE.Mesh(gardenGeo, gardenMat);
      garden.position.set(
        (Math.random() - 0.5) * width * 0.3,
        0.15,
        (Math.random() - 0.5) * depth * 0.3
      );
      group.add(garden);
      
      // Foliage particles
      const particleCount = isMobile ? 8 : 15;
      const particleGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = garden.position.x + (Math.random() - 0.5) * width * 0.5;
        positions[i * 3 + 1] = 0.4 + Math.random() * 0.4;
        positions[i * 3 + 2] = garden.position.z + (Math.random() - 0.5) * depth * 0.5;
      }
      
      particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const particleMat = new THREE.PointsMaterial({
        color: 0x6bff9d,
        size: 0.25,
        transparent: true,
        opacity: 0.7,
      });
      const particles = new THREE.Points(particleGeo, particleMat);
      group.add(particles);
    }
    
    function addAntennaArray(group, districtColor) {
      const antennaCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < antennaCount; i++) {
        const antennaHeight = 1.5 + Math.random() * 2.5;
        const antennaGeo = new THREE.CylinderGeometry(0.04, 0.06, antennaHeight, 4);
        const antennaMat = new THREE.MeshStandardMaterial({ 
          color: 0x333344,
          metalness: 0.6,
          roughness: 0.4,
        });
        const antenna = new THREE.Mesh(antennaGeo, antennaMat);
        antenna.position.set(
          (Math.random() - 0.5) * 1.5,
          antennaHeight / 2,
          (Math.random() - 0.5) * 1.5
        );
        group.add(antenna);
        
        // Blinking light
        const lightGeo = new THREE.SphereGeometry(0.08, 4, 4);
        const lightMat = new THREE.MeshBasicMaterial({ color: districtColor });
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.y = antennaHeight / 2 + 0.1;
        light.userData.blink = true;
        light.userData.blinkPhase = Math.random() * Math.PI * 2;
        antenna.add(light);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HOLOGRAPHIC ADVERTISEMENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function addHolographicAd(mesh, width, height, districtColor) {
      const adHeight = 1.5 + Math.random() * 1.5;
      const adWidth = width * 0.7;
      
      const holoGeo = new THREE.PlaneGeometry(adWidth, adHeight);
      const holoMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
      });
      const holo = new THREE.Mesh(holoGeo, holoMat);
      
      const side = Math.floor(Math.random() * 4);
      const offset = width / 2 + 0.1;
      const yPos = height * 0.3 + Math.random() * height * 0.3;
      
      switch(side) {
        case 0: holo.position.set(offset, yPos, 0); holo.rotation.y = Math.PI / 2; break;
        case 1: holo.position.set(-offset, yPos, 0); holo.rotation.y = -Math.PI / 2; break;
        case 2: holo.position.set(0, yPos, offset); break;
        case 3: holo.position.set(0, yPos, -offset); holo.rotation.y = Math.PI; break;
      }
      
      holo.userData.hologram = true;
      holo.userData.flickerPhase = Math.random() * Math.PI * 2;
      mesh.add(holo);
      
      // Scanlines
      for (let i = 0; i < 3; i++) {
        const lineGeo = new THREE.PlaneGeometry(adWidth, 0.04);
        const lineMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.25,
          side: THREE.DoubleSide,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.y = -adHeight/2 + (i + 1) * (adHeight / 4);
        line.position.z = 0.01;
        holo.add(line);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENERGY PULSE LINES - Traveling light bands on buildings
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createEnergyPulseLine(width, depth, height, type, districtColor) {
      const group = new THREE.Group();
      
      // Determine which face to place the pulse line on
      const side = Math.floor(Math.random() * 4);
      const isBox = type === 'tower' || type === 'lShape';
      
      // Create the pulse bar (thin glowing strip)
      const pulseWidth = isBox ? (side % 2 === 0 ? width * 0.6 : depth * 0.6) : width * 0.4;
      const pulseHeight = 0.3;
      
      const pulseGeo = new THREE.PlaneGeometry(pulseWidth, pulseHeight);
      const pulseMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
      });
      
      const pulse = new THREE.Mesh(pulseGeo, pulseMat);
      
      // Glow halo behind the pulse
      const glowGeo = new THREE.PlaneGeometry(pulseWidth * 1.3, pulseHeight * 3);
      const glowMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.25,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.z = -0.01;
      pulse.add(glow);
      
      // Position based on building type and side
      if (isBox) {
        const offset = (side % 2 === 0 ? depth : width) / 2 + 0.05;
        switch (side) {
          case 0: pulse.position.set(0, 0, offset); break;
          case 1: pulse.position.set(0, 0, -offset); pulse.rotation.y = Math.PI; break;
          case 2: pulse.position.set(offset, 0, 0); pulse.rotation.y = Math.PI / 2; break;
          case 3: pulse.position.set(-offset, 0, 0); pulse.rotation.y = -Math.PI / 2; break;
        }
      } else {
        // Cylindrical building - place on surface
        const angle = Math.random() * Math.PI * 2;
        const radius = width / 2 + 0.05;
        pulse.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
        pulse.rotation.y = angle + Math.PI / 2;
      }
      
      group.add(pulse);
      
      // Store animation data
      group.userData = {
        energyPulse: true,
        progress: Math.random(),
        speed: 0.003 + Math.random() * 0.004,
        height: height,
        pulseElement: pulse,
        baseY: 0,
      };
      
      return group;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN BUILDING GENERATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createBuilding(config) {
      const {
        x = 0, z = 0,
        width = 2 + Math.random() * 3,
        depth = 2 + Math.random() * 3,
        height = 5 + Math.random() * 20,
        district = 'core',
        label = '',
        type = getRandomBuildingShape(),
        sources = [],
      } = config;
      
      const districtData = DISTRICTS[district] || DISTRICTS.core;
      const style = getBuildingStyle(district, height);
      const styleData = BUILDING_STYLES[style];
      
      // Create main building group
      const buildingGroup = new THREE.Group();
      buildingGroup.position.set(x, 0, z);
      
      // === BASE SECTION ===
      const base = createBuildingBase(width, depth, style, districtData.color);
      buildingGroup.add(base);
      const baseHeight = base.userData.baseHeight;
      
      // === MAIN BODY ===
      // Calculate if we need setbacks (for tall buildings)
      const needsSetback = styleData.hasSetbacks && height > 20;
      const setbackHeight = needsSetback ? height * 0.3 : 0;
      const mainBodyHeight = height - baseHeight - setbackHeight;
      
      // Main body material
      const bodyMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(styleData.colorTint).multiplyScalar(0.18),
        emissive: districtData.emissive,
        emissiveIntensity: 0.7,
        roughness: 0.55 - styleData.glassReflectivity * 0.3,
        metalness: 0.3 + styleData.glassReflectivity * 0.4,
      });
      
      let mainBody;
      if (type === 'cylinder' || type === 'octagon' || type === 'hex') {
        const segments = type === 'hex' ? 6 : (type === 'octagon' ? 8 : 12);
        const bodyGeo = new THREE.CylinderGeometry(width/2, width/2, mainBodyHeight, segments);
        mainBody = new THREE.Mesh(bodyGeo, bodyMat);
      } else if (type === 'tapered') {
        const bodyGeo = new THREE.CylinderGeometry(width * 0.4, width/2, mainBodyHeight, 8);
        mainBody = new THREE.Mesh(bodyGeo, bodyMat);
      } else if (type === 'lShape') {
        // L-shaped building using merged boxes
        const group = new THREE.Group();
        const box1Geo = new THREE.BoxGeometry(width, mainBodyHeight, depth * 0.6);
        const box1 = new THREE.Mesh(box1Geo, bodyMat);
        box1.position.z = depth * 0.2;
        group.add(box1);
        
        const box2Geo = new THREE.BoxGeometry(width * 0.6, mainBodyHeight, depth);
        const box2 = new THREE.Mesh(box2Geo, bodyMat.clone());
        box2.position.x = -width * 0.2;
        group.add(box2);
        
        mainBody = group;
      } else {
        // Default box tower
        const bodyGeo = new THREE.BoxGeometry(width, mainBodyHeight, depth);
        mainBody = new THREE.Mesh(bodyGeo, bodyMat);
      }
      
      mainBody.position.y = baseHeight + mainBodyHeight / 2;
      if (mainBody.castShadow !== undefined) {
        mainBody.castShadow = !isMobile;
        mainBody.receiveShadow = !isMobile;
      }
      buildingGroup.add(mainBody);
      
      // === WINDOWS ON MAIN BODY ===
      if (type === 'tower' || type === 'lShape') {
        // Add window grids to box faces
        const faces = [
          { rot: 0, pos: [0, baseHeight + mainBodyHeight/2, depth/2 + 0.02], w: width, h: mainBodyHeight },
          { rot: Math.PI, pos: [0, baseHeight + mainBodyHeight/2, -depth/2 - 0.02], w: width, h: mainBodyHeight },
          { rot: Math.PI/2, pos: [width/2 + 0.02, baseHeight + mainBodyHeight/2, 0], w: depth, h: mainBodyHeight },
          { rot: -Math.PI/2, pos: [-width/2 - 0.02, baseHeight + mainBodyHeight/2, 0], w: depth, h: mainBodyHeight },
        ];
        
        faces.forEach((face, idx) => {
          const windows = createWindowGrid(face.w * 0.92, face.h * 0.92, style, districtData.color, idx < 2);
          windows.rotation.y = face.rot;
          windows.position.set(...face.pos);
          buildingGroup.add(windows);
        });
      } else if (type !== 'dome' && type !== 'spire') {
        // Cylindrical buildings: add ring windows
        const floorCount = Math.floor(mainBodyHeight / styleData.windowSpacing);
        for (let i = 1; i < floorCount; i++) {
          if (Math.random() > styleData.windowDensity) continue;
          
          const ringRadius = type === 'tapered' ? 
            width/2 * (0.4 + 0.6 * (1 - i/floorCount)) + 0.03 :
            width/2 + 0.03;
          const segments = type === 'hex' ? 6 : (type === 'octagon' ? 8 : 16);
          const ringGeo = new THREE.TorusGeometry(ringRadius, 0.06, 4, segments);
          const ringMat = new THREE.MeshBasicMaterial({
            color: districtData.color,
            transparent: true,
            opacity: 0.4 + Math.random() * 0.3,
          });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = Math.PI / 2;
          ring.position.y = baseHeight + i * styleData.windowSpacing;
          buildingGroup.add(ring);
        }
      }
      
      // === FLOOR LEDGES (horizontal lines) ===
      if (!isMobile && height > 10) {
        const ledgeCount = Math.floor(mainBodyHeight / 5);
        for (let i = 1; i < ledgeCount; i++) {
          const ledgeY = baseHeight + i * 5;
          if (type === 'tower' || type === 'lShape') {
            const ledgeGeo = new THREE.BoxGeometry(width + 0.08, 0.1, depth + 0.08);
            const ledgeMat = new THREE.MeshBasicMaterial({
              color: new THREE.Color(styleData.colorTint).multiplyScalar(0.3),
              transparent: true,
              opacity: 0.5,
            });
            const ledge = new THREE.Mesh(ledgeGeo, ledgeMat);
            ledge.position.y = ledgeY;
            buildingGroup.add(ledge);
          }
        }
      }
      
      // === SETBACK SECTION (for tall buildings) ===
      let topY = baseHeight + mainBodyHeight;
      let topWidth = width;
      let topDepth = depth;
      
      if (needsSetback) {
        const setback = createSetback(width, depth, setbackHeight, style, districtData.color);
        setback.position.y = topY + setbackHeight / 2;
        buildingGroup.add(setback);
        
        topY += setbackHeight;
        topWidth = setback.userData.setbackWidth;
        topDepth = setback.userData.setbackDepth;
      }
      
      // === CROWN/TOP SECTION ===
      const crown = createBuildingCrown(topWidth, topDepth, height, style, districtData.color);
      crown.position.y = topY;
      buildingGroup.add(crown);
      
      // === ROOFTOP FEATURES ===
      const rooftopGroup = new THREE.Group();
      rooftopGroup.position.y = topY;
      
      const rooftopRoll = Math.random();
      if (height > 25 && rooftopRoll < 0.15) {
        // Helipad for very tall buildings
        addHelipad(rooftopGroup, topWidth, topDepth, districtData.color);
      } else if (height > 15 && rooftopRoll < 0.35) {
        // Water tower
        addWaterTower(rooftopGroup, topWidth, topDepth, districtData.color);
      } else if (height > 10 && rooftopRoll < 0.55) {
        // AC units
        addACUnits(rooftopGroup, topWidth, topDepth);
      } else if (height > 8 && rooftopRoll < 0.7) {
        // Rooftop garden
        addRooftopGarden(rooftopGroup, topWidth, topDepth);
      } else if (height > 12) {
        // Antennas
        addAntennaArray(rooftopGroup, districtData.color);
      }
      
      buildingGroup.add(rooftopGroup);
      
      // === TOP BEACON ===
      if (height > 18 && styleData.crownStyle !== 'spire') {
        const beaconGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const beaconMat = new THREE.MeshBasicMaterial({ color: districtData.color });
        const beacon = new THREE.Mesh(beaconGeo, beaconMat);
        beacon.position.y = topY + 1;
        beacon.userData.pulse = true;
        beacon.userData.pulsePhase = Math.random() * Math.PI * 2;
        buildingGroup.add(beacon);
      }
      
      // === EDGE GLOW - Cyberpunk neon outline effect ===
      if (!isMobile && height > 8) {
        // Vertical edge lines on corners
        const edgeCount = type === 'cylinder' || type === 'octagon' || type === 'hex' ? 
          (type === 'hex' ? 6 : 8) : 4;
        const edgeRadius = type === 'tower' || type === 'lShape' ? 
          Math.sqrt((width/2)**2 + (depth/2)**2) : width/2;
        
        for (let i = 0; i < edgeCount; i++) {
          const angle = (i / edgeCount) * Math.PI * 2;
          const isCorner = type === 'tower' || type === 'lShape';
          const ex = isCorner ? 
            (i % 2 === 0 ? width/2 : -width/2) * (i < 2 ? 1 : 1) :
            Math.cos(angle) * edgeRadius;
          const ez = isCorner ?
            (i < 2 ? depth/2 : -depth/2) :
            Math.sin(angle) * edgeRadius;
          
          // Vertical edge line
          const edgeGeo = new THREE.CylinderGeometry(0.05, 0.05, height * 0.9, 4);
          const edgeMat = new THREE.MeshBasicMaterial({
            color: districtData.color,
            transparent: true,
            opacity: 0.3 + Math.random() * 0.2,
          });
          const edge = new THREE.Mesh(edgeGeo, edgeMat);
          
          if (isCorner) {
            const cx = i === 0 || i === 3 ? width/2 : -width/2;
            const cz = i < 2 ? depth/2 : -depth/2;
            edge.position.set(cx * 0.98, baseHeight + height * 0.45, cz * 0.98);
          } else {
            edge.position.set(ex * 0.98, baseHeight + height * 0.45, ez * 0.98);
          }
          
          edge.userData.edgeGlow = true;
          edge.userData.glowPhase = Math.random() * Math.PI * 2;
          buildingGroup.add(edge);
        }
        
        // Horizontal trim lines at intervals
        const trimCount = Math.floor(height / 12);
        for (let t = 1; t <= trimCount; t++) {
          const trimY = baseHeight + t * 12;
          if (trimY > topY - 2) continue;
          
          // Simple box trim for tower types
          if (type === 'tower' || type === 'lShape') {
            const trimGeo = new THREE.BoxGeometry(width + 0.15, 0.08, depth + 0.15);
            const trimMat = new THREE.MeshBasicMaterial({
              color: districtData.color,
              transparent: true,
              opacity: 0.4,
            });
            const trim = new THREE.Mesh(trimGeo, trimMat);
            trim.position.y = trimY;
            trim.userData.edgeGlow = true;
            trim.userData.glowPhase = t * 0.5;
            buildingGroup.add(trim);
          } else {
            // Ring trim for cylindrical buildings
            const trimRadius = type === 'tapered' ? 
              width/2 * (1 - (trimY - baseHeight) / height * 0.3) : width/2;
            const segments = type === 'hex' ? 6 : (type === 'octagon' ? 8 : 16);
            const trimGeo = new THREE.TorusGeometry(trimRadius + 0.05, 0.04, 4, segments);
            const trimMat = new THREE.MeshBasicMaterial({
              color: districtData.color,
              transparent: true,
              opacity: 0.35,
            });
            const trim = new THREE.Mesh(trimGeo, trimMat);
            trim.rotation.x = Math.PI / 2;
            trim.position.y = trimY;
            trim.userData.edgeGlow = true;
            trim.userData.glowPhase = t * 0.5;
            buildingGroup.add(trim);
          }
        }
      }
      
      // === HOLOGRAPHIC AD (occasional) ===
      if (height > 10 && Math.random() < 0.25) {
        addHolographicAd(buildingGroup, width, height, districtData.color);
      }
      
      // === ENERGY PULSE LINES - Vertical light bands traveling up building ===
      if (!isMobile && height > 15 && Math.random() < 0.6) {
        const pulseCount = 1 + Math.floor(Math.random() * 2);
        for (let p = 0; p < pulseCount; p++) {
          const pulseLine = createEnergyPulseLine(width, depth, height, type, districtData.color);
          pulseLine.position.y = baseHeight;
          buildingGroup.add(pulseLine);
        }
      }
      
      scene.add(buildingGroup);
      
      const building = {
        mesh: buildingGroup,
        district,
        label,
        type,
        style,
        x, z,
        width, depth, height,
        sources,
        createdAt: Date.now(),
      };
      
      city.buildings.push(building);
      
      if (!city.districts.has(district)) {
        city.districts.set(district, []);
      }
      city.districts.get(district).push(building);
      
      // Initialize ambient life for this building
      addElevatorToBuilding(building);
      initializeWindowStates(building);
      
      updateStats();
      return building;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION LINES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createConnection(building1, building2) {
      const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(building1.x, 0.5, building1.z),
        new THREE.Vector3(
          (building1.x + building2.x) / 2,
          2 + Math.random() * 2,
          (building1.z + building2.z) / 2
        ),
        new THREE.Vector3(building2.x, 0.5, building2.z)
      );
      
      const points = curve.getPoints(20);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.25,
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      
      const connection = { line, from: building1, to: building2 };
      city.connections.push(connection);
      
      // Create data stream particles for this connection
      createDataStream(connection);
      
      updateStats();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HOLOGRAPHIC DISTRICT LABELS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDistrictLabels() {
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;
        
        // Transparent background
        ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Glowing text
        ctx.font = 'bold 48px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Glow effect
        ctx.shadowColor = '#' + district.color.getHexString();
        ctx.shadowBlur = 20;
        ctx.fillStyle = '#' + district.color.getHexString();
        ctx.fillText(district.name, canvas.width / 2, canvas.height / 2);
        
        // Brighter center
        ctx.shadowBlur = 5;
        ctx.fillStyle = '#ffffff';
        ctx.fillText(district.name, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const labelMat = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.8,
        });
        
        const label = new THREE.Sprite(labelMat);
        label.position.set(
          district.position.x,
          25 + Math.random() * 5,
          district.position.z
        );
        label.scale.set(15, 4, 1);
        
        label.userData.baseY = label.position.y;
        label.userData.floatPhase = Math.random() * Math.PI * 2;
        
        scene.add(label);
        city.districtLabels.push(label);
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FLYING DRONES/VEHICLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDrones() {
      const droneCount = isMobile ? 8 : 15;
      
      for (let i = 0; i < droneCount; i++) {
        const droneGroup = new THREE.Group();
        
        // Main body
        const bodyGeo = new THREE.SphereGeometry(0.3, 6, 4);
        const bodyMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.8,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        droneGroup.add(body);
        
        // Light trail
        const trailGeo = new THREE.ConeGeometry(0.15, 1.5, 4);
        const trailMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.rotation.x = Math.PI / 2;
        trail.position.z = 0.8;
        droneGroup.add(trail);
        
        // Random patrol path
        const pathRadius = 15 + Math.random() * 40;
        const pathHeight = 10 + Math.random() * 25;
        const pathSpeed = 0.2 + Math.random() * 0.3;
        const pathOffset = Math.random() * Math.PI * 2;
        const pathTilt = (Math.random() - 0.5) * 0.5;
        
        droneGroup.userData = {
          pathRadius,
          pathHeight,
          pathSpeed,
          pathOffset,
          pathTilt,
        };
        
        scene.add(droneGroup);
        city.drones.push(droneGroup);
      }
    }
    
    function updateDrones(time) {
      city.drones.forEach((drone, i) => {
        const { pathRadius, pathHeight, pathSpeed, pathOffset, pathTilt } = drone.userData;
        
        const t = time * pathSpeed + pathOffset;
        const x = Math.cos(t) * pathRadius;
        const z = Math.sin(t) * pathRadius + Math.sin(t * 2) * pathRadius * 0.2;
        const y = pathHeight + Math.sin(t * 1.5) * 5;
        
        drone.position.set(x, y, z);
        
        // Face movement direction
        const nextT = t + 0.1;
        const nextX = Math.cos(nextT) * pathRadius;
        const nextZ = Math.sin(nextT) * pathRadius + Math.sin(nextT * 2) * pathRadius * 0.2;
        drone.lookAt(nextX, y, nextZ);
        
        // Update drone lighting based on time of day
        drone.children.forEach(child => {
          if (child.material) {
            // Brighter at night, dimmer during bright day
            const baseOpacity = 0.5 + city.nightIntensity * 0.4;
            child.material.opacity = baseOpacity;
            
            // Color shift: warmer during golden hour, cooler at night
            if (lighting.goldenHourIntensity > 0) {
              child.material.color.setHex(0x44ffcc);
            } else if (city.nightIntensity > 0.5) {
              child.material.color.setHex(0x4488ff);
            } else {
              child.material.color.setHex(0x00ffff);
            }
          }
        });
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT PARTICLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createParticles() {
      const particleCount = isMobile ? 200 : 500;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        velocities[i * 3] = (Math.random() - 0.5) * 0.02;
        velocities[i * 3 + 1] = Math.random() * 0.02 + 0.01;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.userData = { velocities };
      
      const material = new THREE.PointsMaterial({
        color: 0x66ddff,
        size: 0.15,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
      });
      
      city.particles = new THREE.Points(geometry, material);
      scene.add(city.particles);
    }
    
    function updateParticles() {
      if (!city.particles) return;
      
      const positions = city.particles.geometry.attributes.position.array;
      const velocities = city.particles.geometry.userData.velocities;
      
      for (let i = 0; i < positions.length / 3; i++) {
        positions[i * 3] += velocities[i * 3];
        positions[i * 3 + 1] += velocities[i * 3 + 1];
        positions[i * 3 + 2] += velocities[i * 3 + 2];
        
        // Reset particles that go too high
        if (positions[i * 3 + 1] > 60) {
          positions[i * 3] = (Math.random() - 0.5) * 100;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        }
      }
      
      city.particles.geometry.attributes.position.needsUpdate = true;
      
      // Particle color and visibility responds to time
      // Brighter and more visible at night, almost invisible during bright day
      const dayVisibility = 0.3;
      const nightVisibility = 0.8;
      city.particles.material.opacity = dayVisibility + (nightVisibility - dayVisibility) * city.nightIntensity;
      
      // Color shift with atmosphere
      if (lighting.goldenHourIntensity > 0) {
        city.particles.material.color.setHex(0xffdd88); // Warm golden
      } else if (city.nightIntensity > 0.5) {
        city.particles.material.color.setHex(0x88ccff); // Cool blue
      } else {
        city.particles.material.color.setHex(0x66ddff); // Neutral cyan
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CORE SPIRE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createCoreSpire() {
      // Main crystalline spire
      const spireGeo = new THREE.CylinderGeometry(0.3, 2.5, 40, 8);
      const spireMat = new THREE.MeshStandardMaterial({
        color: 0x001a1a,
        emissive: 0x00ffff,
        emissiveIntensity: 1.0,
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9,
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.set(0, 20, 0);
      spire.castShadow = !isMobile;
      scene.add(spire);
      
      // Inner glow core
      const coreGeo = new THREE.SphereGeometry(1.5, 16, 16);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.8,
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      core.position.set(0, 8, 0);
      core.userData.pulse = true;
      scene.add(core);
      city.coreGlow = core;
      
      // Rotating energy rings
      for (let i = 0; i < 4; i++) {
        const ringGeo = new THREE.TorusGeometry(3 + i * 2, 0.08, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.6 - i * 0.1,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(0, 8 + i * 7, 0);
        ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
        ring.userData.rotationSpeed = 0.4 + i * 0.15;
        ring.userData.rotationAxis = i % 2 === 0 ? 'z' : 'y';
        ring.userData.wobble = Math.random() * 0.02;
        scene.add(ring);
        city.coreRings.push(ring);
      }
      
      // Energy beams shooting up
      for (let i = 0; i < 3; i++) {
        const beamGeo = new THREE.CylinderGeometry(0.05, 0.15, 50, 4);
        const beamMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        const angle = (i / 3) * Math.PI * 2;
        beam.position.set(Math.cos(angle) * 2, 25, Math.sin(angle) * 2);
        beam.userData.beamPhase = i * 0.7;
        scene.add(beam);
        city.coreRings.push(beam);
      }
      
      // Base platform with glow
      const baseGeo = new THREE.CylinderGeometry(6, 7, 1.5, 8);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x0a1a1a,
        emissive: 0x004444,
        emissiveIntensity: 0.8,
        roughness: 0.4,
        metalness: 0.6,
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, 0.75, 0);
      base.receiveShadow = true;
      scene.add(base);
      
      // Pulsing floor rings
      for (let i = 0; i < 3; i++) {
        const floorRingGeo = new THREE.TorusGeometry(8 + i * 3, 0.15, 4, 32);
        const floorRingMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3 - i * 0.08,
        });
        const floorRing = new THREE.Mesh(floorRingGeo, floorRingMat);
        floorRing.rotation.x = -Math.PI / 2;
        floorRing.position.y = 0.1;
        floorRing.userData.pulseRing = true;
        floorRing.userData.pulsePhase = i * 0.5;
        scene.add(floorRing);
        city.coreRings.push(floorRing);
      }
      
      city.buildings.push({
        mesh: spire,
        district: 'core',
        label: 'Nexus Core',
        x: 0, z: 0,
        height: 40,
        createdAt: Date.now(),
      });
    }
    // NOTE: seedCity() removed - was dead code, replaced by seedCityFallback()
    // which is called from the init section after createCoreSpire()
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENVIRONMENT ANIMATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateEnvironment(dt) {
      // Animate clouds - color responds to fog/sky
      if (city.clouds) {
        city.clouds.forEach(cloud => {
          cloud.userData.angle += cloud.userData.speed;
          cloud.position.x = Math.cos(cloud.userData.angle) * cloud.userData.radius;
          cloud.position.z = Math.sin(cloud.userData.angle) * cloud.userData.radius;
          cloud.position.y = cloud.userData.baseY + Math.sin(dt * 0.2 + cloud.userData.angle) * 3;
          
          // Cloud color matches fog with slight warmth during golden hour
          if (cloud.material.color) {
            cloud.material.color.copy(lighting.currentFogColor).multiplyScalar(2.5);
            if (lighting.goldenHourIntensity > 0) {
              cloud.material.color.r += lighting.goldenHourIntensity * 0.15;
              cloud.material.color.g += lighting.goldenHourIntensity * 0.05;
            }
          }
          // Clouds more opaque at night (denser atmosphere feel)
          cloud.material.opacity = 0.12 + city.nightIntensity * 0.1;
        });
      }
      
      // Animate floating rocks - subtle glow at night
      if (city.floatingRocks) {
        city.floatingRocks.forEach(rock => {
          rock.position.y = rock.userData.baseY + 
            Math.sin(dt * rock.userData.floatSpeed + rock.userData.floatPhase) * 2;
          rock.rotation.y += 0.001;
          
          // Emissive glow intensifies at night
          if (rock.material.emissiveIntensity !== undefined) {
            rock.material.emissiveIntensity = 0.2 + city.nightIntensity * 0.5;
            // Moonlight tint
            if (city.nightIntensity > 0.3) {
              rock.material.emissive.setHex(0x112244);
            } else {
              rock.material.emissive.setHex(0x001122);
            }
          }
        });
      }
      
      // Pulse island edge - color shifts with time
      if (city.islandEdge) {
        const basePulse = Math.sin(dt * 0.5) * 0.1;
        city.islandEdge.material.opacity = 0.25 + basePulse + city.nightIntensity * 0.15;
        // Warmer during golden hour, cooler at night
        if (lighting.goldenHourIntensity > 0) {
          city.islandEdge.material.color.setHex(0xffaa44);
        } else if (city.nightIntensity > 0.3) {
          city.islandEdge.material.color.setHex(0x3366ff);
        } else {
          city.islandEdge.material.color.setHex(0x00aaff);
        }
      }
      
      // Pulse horizon ring - atmospheric glow
      if (city.horizonRing) {
        const scale = 1 + Math.sin(dt * 0.3) * 0.02;
        city.horizonRing.scale.set(scale, scale, 1);
        city.horizonRing.material.opacity = 0.2 + Math.sin(dt * 0.4) * 0.1 + city.nightIntensity * 0.2;
        
        // Horizon color matches atmosphere
        if (lighting.goldenHourIntensity > 0) {
          city.horizonRing.material.color.setHex(0xff7744);
        } else if (city.nightIntensity > 0.5) {
          city.horizonRing.material.color.setHex(0x1a3366);
        } else {
          city.horizonRing.material.color.setHex(0x003355);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEATHER SYSTEM - Rain, Fog, Aurora
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const WEATHER_CONFIG = {
      rain: {
        particleCount: isMobile ? 800 : 2000,
        speed: 0.8,
        spread: 120,
        height: 80,
      },
      fog: {
        layers: isMobile ? 3 : 6,
        baseOpacity: 0.15,
        nightMultiplier: 1.5,
      },
      aurora: {
        ribbonCount: isMobile ? 3 : 5,
        waveSpeed: 0.3,
        colors: [0x00ff88, 0x00ffaa, 0x88ffaa, 0xaa88ff, 0x6644ff],
      }
    };
    
    /**
     * Create rain particle system
     */
    function createRainSystem() {
      if (city.rainSystem) return;
      
      const config = WEATHER_CONFIG.rain;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(config.particleCount * 3);
      const velocities = new Float32Array(config.particleCount);
      
      for (let i = 0; i < config.particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * config.spread;
        positions[i * 3 + 1] = Math.random() * config.height;
        positions[i * 3 + 2] = (Math.random() - 0.5) * config.spread;
        velocities[i] = 0.5 + Math.random() * 0.5; // Individual speed variation
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.userData = { velocities };
      
      // Rain drop material - elongated points
      const material = new THREE.PointsMaterial({
        color: 0x8899aa,
        size: isMobile ? 0.08 : 0.12,
        transparent: true,
        opacity: 0,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
      });
      
      city.rainSystem = new THREE.Points(geometry, material);
      scene.add(city.rainSystem);
      
      // Create puddles on ground
      createPuddles();
    }
    
    /**
     * Create puddle reflections on ground
     */
    function createPuddles() {
      const puddleCount = isMobile ? 8 : 15;
      
      for (let i = 0; i < puddleCount; i++) {
        const size = 2 + Math.random() * 4;
        const geometry = new THREE.CircleGeometry(size, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0x2a3a4a,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
        });
        
        const puddle = new THREE.Mesh(geometry, material);
        puddle.rotation.x = -Math.PI / 2;
        puddle.position.set(
          (Math.random() - 0.5) * 80,
          0.02,
          (Math.random() - 0.5) * 80
        );
        puddle.userData.baseOpacity = 0.2 + Math.random() * 0.2;
        puddle.userData.ripplePhase = Math.random() * Math.PI * 2;
        
        scene.add(puddle);
        city.puddles.push(puddle);
      }
    }
    
    /**
     * Update rain system
     */
    function updateRain(dt, intensity) {
      if (!city.rainSystem) return;
      
      const config = WEATHER_CONFIG.rain;
      const positions = city.rainSystem.geometry.attributes.position.array;
      const velocities = city.rainSystem.geometry.userData.velocities;
      
      // Update rain drop positions
      for (let i = 0; i < positions.length / 3; i++) {
        positions[i * 3 + 1] -= config.speed * velocities[i] * intensity;
        
        // Add slight horizontal drift
        positions[i * 3] += Math.sin(dt + i) * 0.01;
        
        // Reset drops that hit ground
        if (positions[i * 3 + 1] < 0) {
          positions[i * 3] = (Math.random() - 0.5) * config.spread;
          positions[i * 3 + 1] = config.height;
          positions[i * 3 + 2] = (Math.random() - 0.5) * config.spread;
        }
      }
      
      city.rainSystem.geometry.attributes.position.needsUpdate = true;
      city.rainSystem.material.opacity = intensity * 0.6;
      
      // Update puddles with ripple effect
      city.puddles.forEach(puddle => {
        const ripple = Math.sin(dt * 3 + puddle.userData.ripplePhase) * 0.05;
        puddle.material.opacity = puddle.userData.baseOpacity * intensity + ripple * intensity;
        
        // Slight color variation based on sky reflection
        if (city.nightIntensity > 0.5) {
          puddle.material.color.setHex(0x1a2a3a);
        } else {
          puddle.material.color.setHex(0x3a4a5a);
        }
      });
    }
    
    /**
     * Create fog/mist layers
     */
    function createFogSystem() {
      if (city.fogPlanes.length > 0) return;
      
      const config = WEATHER_CONFIG.fog;
      
      for (let i = 0; i < config.layers; i++) {
        const size = 200 + i * 50;
        const geometry = new THREE.PlaneGeometry(size, size);
        const material = new THREE.MeshBasicMaterial({
          color: 0x445566,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          depthWrite: false,
        });
        
        const fogPlane = new THREE.Mesh(geometry, material);
        fogPlane.rotation.x = -Math.PI / 2;
        fogPlane.position.y = 0.5 + i * 3;
        fogPlane.userData.baseY = fogPlane.position.y;
        fogPlane.userData.driftPhase = Math.random() * Math.PI * 2;
        fogPlane.userData.layerIndex = i;
        
        scene.add(fogPlane);
        city.fogPlanes.push(fogPlane);
      }
    }
    
    /**
     * Update fog system
     */
    function updateFog(dt, intensity) {
      const config = WEATHER_CONFIG.fog;
      const nightBoost = 1 + city.nightIntensity * (config.nightMultiplier - 1);
      
      city.fogPlanes.forEach((fogPlane, i) => {
        // Gentle vertical drift
        fogPlane.position.y = fogPlane.userData.baseY + 
          Math.sin(dt * 0.2 + fogPlane.userData.driftPhase) * 1;
        
        // Horizontal drift
        fogPlane.position.x = Math.sin(dt * 0.1 + i) * 5;
        fogPlane.position.z = Math.cos(dt * 0.15 + i) * 5;
        
        // Opacity based on layer (lower = denser)
        const layerFactor = 1 - (fogPlane.userData.layerIndex / config.layers) * 0.5;
        fogPlane.material.opacity = config.baseOpacity * layerFactor * intensity * nightBoost;
        
        // Fog color shifts with time of day
        if (city.nightIntensity > 0.5) {
          fogPlane.material.color.setHex(0x1a2233); // Darker, bluer at night
        } else if (lighting.goldenHourIntensity > 0) {
          fogPlane.material.color.setHex(0x665544); // Warm during golden hour
        } else {
          fogPlane.material.color.setHex(0x445566); // Neutral gray-blue
        }
      });
      
      // Increase scene fog density when fog weather is active
      if (intensity > 0) {
        scene.fog.density = 0.004 + intensity * 0.008;
      }
    }
    
    /**
     * Create aurora borealis system
     */
    function createAuroraSystem() {
      if (city.aurora) return;
      
      const config = WEATHER_CONFIG.aurora;
      const auroraGroup = new THREE.Group();
      auroraGroup.ribbons = [];
      
      for (let i = 0; i < config.ribbonCount; i++) {
        // Create flowing ribbon geometry
        const width = 80 + Math.random() * 40;
        const segments = 32;
        const geometry = new THREE.PlaneGeometry(width, 30, segments, 1);
        
        const material = new THREE.MeshBasicMaterial({
          color: config.colors[i % config.colors.length],
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        
        const ribbon = new THREE.Mesh(geometry, material);
        ribbon.position.set(
          (Math.random() - 0.5) * 100,
          150 + Math.random() * 50,
          -100 - Math.random() * 100
        );
        ribbon.rotation.x = Math.PI / 6 + Math.random() * 0.2;
        ribbon.userData.phaseOffset = Math.random() * Math.PI * 2;
        ribbon.userData.waveScale = 0.5 + Math.random() * 0.5;
        ribbon.userData.colorIndex = i % config.colors.length;
        
        auroraGroup.add(ribbon);
        auroraGroup.ribbons.push(ribbon);
      }
      
      city.aurora = auroraGroup;
      scene.add(auroraGroup);
    }
    
    /**
     * Update aurora effect
     */
    function updateAurora(dt, intensity) {
      if (!city.aurora) return;
      
      const config = WEATHER_CONFIG.aurora;
      
      // Aurora only visible at night
      const nightFactor = Math.max(0, city.nightIntensity - 0.3) / 0.7;
      const effectiveIntensity = intensity * nightFactor;
      
      city.aurora.ribbons.forEach((ribbon, i) => {
        // Animate vertex positions for flowing effect
        const positions = ribbon.geometry.attributes.position.array;
        const segmentCount = 33; // segments + 1
        
        for (let j = 0; j < segmentCount; j++) {
          const waveOffset = dt * config.waveSpeed + j * 0.3 + ribbon.userData.phaseOffset;
          const wave = Math.sin(waveOffset) * 8 * ribbon.userData.waveScale;
          
          // Top and bottom vertices
          positions[j * 6 + 1] = 15 + wave; // Top y
          positions[j * 6 + 4] = -15 + wave * 0.5; // Bottom y
        }
        
        ribbon.geometry.attributes.position.needsUpdate = true;
        
        // Pulsing opacity
        const pulse = Math.sin(dt * 0.5 + i) * 0.1 + 0.9;
        ribbon.material.opacity = effectiveIntensity * 0.35 * pulse;
        
        // Gentle color cycling
        const colorPhase = (dt * 0.1 + i * 0.5) % config.colors.length;
        const colorIndex = Math.floor(colorPhase);
        const nextIndex = (colorIndex + 1) % config.colors.length;
        const colorBlend = colorPhase - colorIndex;
        
        const color1 = new THREE.Color(config.colors[colorIndex]);
        const color2 = new THREE.Color(config.colors[nextIndex]);
        ribbon.material.color.lerpColors(color1, color2, colorBlend);
        
        // Slow drift movement
        ribbon.position.x += Math.sin(dt * 0.1 + i) * 0.02;
      });
      
      // Subtle aurora reflection on buildings at night
      if (effectiveIntensity > 0.1) {
        city.buildings.forEach(b => {
          if (b.mesh.material && b.mesh.material.emissive) {
            const auroraGlow = new THREE.Color(0x004422).multiplyScalar(effectiveIntensity * 0.1);
            b.mesh.material.emissive.add(auroraGlow);
          }
        });
      }
    }
    
    /**
     * Set weather state with smooth transition
     */
    function setWeather(weather) {
      if (weather === city.weather && weather === city.targetWeather) return;
      
      city.targetWeather = weather;
      console.log(`[Weather] Transitioning to: ${weather}`);
      
      // Initialize systems if needed
      if (weather === 'rain' && !city.rainSystem) createRainSystem();
      if (weather === 'fog' && city.fogPlanes.length === 0) createFogSystem();
      if (weather === 'aurora' && !city.aurora) createAuroraSystem();
      
      // Update UI
      if (weatherStateEl) {
        weatherStateEl.textContent = weather;
        weatherStateEl.style.color = {
          clear: 'rgba(100, 200, 255, 0.8)',
          rain: 'rgba(100, 150, 200, 0.9)',
          fog: 'rgba(150, 150, 170, 0.9)',
          aurora: 'rgba(100, 255, 150, 0.9)',
        }[weather] || 'rgba(100, 200, 255, 0.8)';
      }
    }
    
    /**
     * Update weather system with transitions
     */
    function updateWeather(dt) {
      // Smooth transition to target weather
      const transitionSpeed = 0.01;
      
      if (city.weather !== city.targetWeather) {
        // Fade out current weather
        city.weatherIntensity -= transitionSpeed;
        if (city.weatherIntensity <= 0) {
          city.weatherIntensity = 0;
          city.weather = city.targetWeather;
        }
      } else if (city.weatherIntensity < 1 && city.weather !== 'clear') {
        // Fade in new weather
        city.weatherIntensity += transitionSpeed;
        if (city.weatherIntensity > 1) city.weatherIntensity = 1;
      } else if (city.weather === 'clear') {
        city.weatherIntensity = Math.max(0, city.weatherIntensity - transitionSpeed);
      }
      
      // Update active weather effects
      const intensity = city.weatherIntensity;
      
      // Rain
      if (city.rainSystem) {
        const rainActive = city.weather === 'rain' || (city.targetWeather === 'rain' && intensity > 0);
        updateRain(dt, rainActive ? intensity : Math.max(0, intensity - 0.5) * 2);
      }
      
      // Fog
      if (city.fogPlanes.length > 0) {
        const fogActive = city.weather === 'fog' || (city.targetWeather === 'fog' && intensity > 0);
        updateFog(dt, fogActive ? intensity : 0);
      }
      
      // Aurora
      if (city.aurora) {
        const auroraActive = city.weather === 'aurora' || (city.targetWeather === 'aurora' && intensity > 0);
        updateAurora(dt, auroraActive ? intensity : 0);
      }
      
      // Wet building effect during rain
      if (city.weather === 'rain' && intensity > 0.3) {
        city.buildings.forEach(b => {
          if (b.mesh.material) {
            // Increase specularity/metalness for wet look
            if (b.mesh.material.metalness !== undefined) {
              b.mesh.material.metalness = 0.4 + intensity * 0.3;
            }
            if (b.mesh.material.roughness !== undefined) {
              b.mesh.material.roughness = 0.6 - intensity * 0.2;
            }
          }
        });
      } else {
        // Reset to normal
        city.buildings.forEach(b => {
          if (b.mesh.material) {
            if (b.mesh.material.metalness !== undefined) {
              b.mesh.material.metalness = 0.4;
            }
            if (b.mesh.material.roughness !== undefined) {
              b.mesh.material.roughness = 0.6;
            }
          }
        });
      }
    }
    
    // Weather keyboard controls are handled in the main keyboard handler below
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LIGHTNING SYSTEM (during rain storms)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * Create a lightning bolt using jagged line segments
     */
    function createLightningBolt(startPos, endPos) {
      const points = [];
      const segments = 8 + Math.floor(Math.random() * 6);
      
      points.push(startPos.clone());
      
      // Create jagged path from start to end
      for (let i = 1; i < segments; i++) {
        const t = i / segments;
        const basePoint = new THREE.Vector3().lerpVectors(startPos, endPos, t);
        
        // Add random jitter (more at middle, less at ends)
        const jitterAmount = Math.sin(t * Math.PI) * 15;
        basePoint.x += (Math.random() - 0.5) * jitterAmount;
        basePoint.y += (Math.random() - 0.5) * jitterAmount * 0.3;
        basePoint.z += (Math.random() - 0.5) * jitterAmount;
        
        points.push(basePoint);
        
        // Occasionally create branches
        if (Math.random() < 0.3 && i > 2 && i < segments - 2) {
          const branchEnd = basePoint.clone();
          branchEnd.x += (Math.random() - 0.5) * 30;
          branchEnd.y -= 10 + Math.random() * 20;
          branchEnd.z += (Math.random() - 0.5) * 30;
          
          // Create branch bolt
          const branchPoints = [basePoint.clone()];
          const branchSegs = 3 + Math.floor(Math.random() * 3);
          for (let j = 1; j <= branchSegs; j++) {
            const bt = j / branchSegs;
            const bp = new THREE.Vector3().lerpVectors(basePoint, branchEnd, bt);
            bp.x += (Math.random() - 0.5) * 5;
            bp.z += (Math.random() - 0.5) * 5;
            branchPoints.push(bp);
          }
          
          const branchGeom = new THREE.BufferGeometry().setFromPoints(branchPoints);
          const branchMat = new THREE.LineBasicMaterial({
            color: 0xaaddff,
            transparent: true,
            opacity: 0.7,
            linewidth: 1,
          });
          const branchLine = new THREE.Line(branchGeom, branchMat);
          branchLine.userData = { life: 1, decay: 0.15 };
          scene.add(branchLine);
          city.lightning.bolts.push(branchLine);
        }
      }
      
      points.push(endPos.clone());
      
      // Create main bolt
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0xeeffff,
        transparent: true,
        opacity: 1,
        linewidth: 2,
      });
      
      const bolt = new THREE.Line(geometry, material);
      bolt.userData = { life: 1, decay: 0.12 };
      
      // Add glow effect with a wider, dimmer duplicate
      const glowGeom = geometry.clone();
      const glowMat = new THREE.LineBasicMaterial({
        color: 0x6688ff,
        transparent: true,
        opacity: 0.4,
        linewidth: 4,
      });
      const glow = new THREE.Line(glowGeom, glowMat);
      glow.userData = { life: 1, decay: 0.12 };
      
      scene.add(bolt);
      scene.add(glow);
      city.lightning.bolts.push(bolt, glow);
      
      return bolt;
    }
    
    /**
     * Trigger a lightning flash (screen flash + optional bolt)
     */
    function triggerLightningFlash() {
      // Bright flash
      city.lightning.flashIntensity = 1;
      city.lightning.flashHoldTime = 0.05 + Math.random() * 0.05; // 50-100ms hold
      city.lightning.active = true;
      
      // 60% chance to create visible bolt
      if (Math.random() < 0.6) {
        // Bolt starts in sky, ends near a building or ground
        const startX = (Math.random() - 0.5) * 150;
        const startZ = (Math.random() - 0.5) * 100;
        const startY = 120 + Math.random() * 40;
        
        // End near a random building or just ground
        let endX, endY, endZ;
        if (city.buildings.length > 0 && Math.random() < 0.7) {
          const target = city.buildings[Math.floor(Math.random() * city.buildings.length)];
          endX = target.x + (Math.random() - 0.5) * 5;
          endY = target.height + Math.random() * 3;
          endZ = target.z + (Math.random() - 0.5) * 5;
        } else {
          endX = startX + (Math.random() - 0.5) * 40;
          endY = 0;
          endZ = startZ + (Math.random() - 0.5) * 40;
        }
        
        createLightningBolt(
          new THREE.Vector3(startX, startY, startZ),
          new THREE.Vector3(endX, endY, endZ)
        );
      }
      
      // Sometimes double-flash
      if (Math.random() < 0.25) {
        setTimeout(() => {
          city.lightning.flashIntensity = 0.7;
          city.lightning.flashHoldTime = 0.03;
        }, 80 + Math.random() * 60);
      }
      
      // Schedule next flash (during rain)
      city.lightning.nextFlashTime = city.time + 3 + Math.random() * 12; // 3-15 seconds
    }
    
    /**
     * Update lightning system
     */
    function updateLightning(dt) {
      // Only active during rain
      if (city.weather !== 'rain' && city.targetWeather !== 'rain') {
        city.lightning.flashIntensity *= 0.9;
        return;
      }
      
      const rainIntensity = city.weatherIntensity;
      if (rainIntensity < 0.3) return; // Need decent rain for lightning
      
      // Check if time for next flash
      if (city.time > city.lightning.nextFlashTime && Math.random() < 0.02) {
        triggerLightningFlash();
      }
      
      // Update flash intensity
      if (city.lightning.flashHoldTime > 0) {
        city.lightning.flashHoldTime -= 0.016; // ~60fps
      } else {
        city.lightning.flashIntensity *= 0.85; // Quick fade
      }
      
      // Apply flash to ambient light
      if (city.lightning.flashIntensity > 0.01) {
        const flashBoost = city.lightning.flashIntensity * 2;
        if (lighting.ambientLight) {
          // Temporarily boost ambient during flash
          lighting.ambientLight.intensity = Math.min(3, lighting.ambientLight.intensity + flashBoost);
        }
      }
      
      // Update and remove old bolts
      for (let i = city.lightning.bolts.length - 1; i >= 0; i--) {
        const bolt = city.lightning.bolts[i];
        bolt.userData.life -= bolt.userData.decay;
        bolt.material.opacity = bolt.userData.life;
        
        if (bolt.userData.life <= 0) {
          scene.remove(bolt);
          bolt.geometry.dispose();
          bolt.material.dispose();
          city.lightning.bolts.splice(i, 1);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTO WEATHER CYCLING (natural progression through weather states)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const WEATHER_CYCLE_CONFIG = {
      minDuration: 180,  // Minimum 3 minutes per weather state
      maxDuration: 600,  // Maximum 10 minutes per weather state
      // Transition probabilities (weighted by time of day)
      transitions: {
        clear: { rain: 0.3, fog: 0.2, aurora: 0.2, clear: 0.3 },
        rain: { clear: 0.5, fog: 0.3, rain: 0.2, aurora: 0 },
        fog: { clear: 0.5, rain: 0.2, fog: 0.3, aurora: 0 },
        aurora: { clear: 0.6, aurora: 0.4, rain: 0, fog: 0 },
      }
    };
    
    /**
     * Choose next weather based on probabilities
     */
    function chooseNextWeather() {
      const current = city.weather;
      const probs = WEATHER_CYCLE_CONFIG.transitions[current] || WEATHER_CYCLE_CONFIG.transitions.clear;
      
      // Adjust for time of day
      let adjustedProbs = { ...probs };
      
      // Aurora only at night
      if (city.nightIntensity < 0.5) {
        adjustedProbs.aurora = 0;
      } else {
        adjustedProbs.aurora *= 2; // More likely at night
      }
      
      // Fog more likely at dawn/dusk
      if (lighting.goldenHourIntensity > 0) {
        adjustedProbs.fog *= 1.5;
      }
      
      // Normalize probabilities
      const total = Object.values(adjustedProbs).reduce((a, b) => a + b, 0);
      if (total === 0) return 'clear';
      
      // Weighted random selection
      let rand = Math.random() * total;
      for (const [weather, prob] of Object.entries(adjustedProbs)) {
        rand -= prob;
        if (rand <= 0) return weather;
      }
      
      return 'clear';
    }
    
    /**
     * Update auto weather cycling
     */
    function updateWeatherCycle(dt) {
      if (!city.weatherCycleEnabled) return;
      
      // Initialize next change time if not set
      if (city.nextWeatherChange === 0) {
        city.nextWeatherChange = city.time + 
          WEATHER_CYCLE_CONFIG.minDuration + 
          Math.random() * (WEATHER_CYCLE_CONFIG.maxDuration - WEATHER_CYCLE_CONFIG.minDuration);
      }
      
      // Check if time to change weather
      if (city.time > city.nextWeatherChange) {
        const nextWeather = chooseNextWeather();
        if (nextWeather !== city.weather) {
          setWeather(nextWeather);
          console.log(`[WeatherCycle] Auto-transitioning to: ${nextWeather}`);
        }
        
        // Schedule next change
        city.nextWeatherChange = city.time + 
          WEATHER_CYCLE_CONFIG.minDuration + 
          Math.random() * (WEATHER_CYCLE_CONFIG.maxDuration - WEATHER_CYCLE_CONFIG.minDuration);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GROWTH SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let lastGrowth = Date.now();
    const GROWTH_INTERVAL = 30000;
    
    function growCity() {
      const now = Date.now();
      if (now - lastGrowth < GROWTH_INTERVAL) return;
      lastGrowth = now;
      
      const districtKeys = Object.keys(DISTRICTS);
      const district = districtKeys[Math.floor(Math.random() * districtKeys.length)];
      const districtData = DISTRICTS[district];
      
      const existing = city.districts.get(district) || [];
      let x, z;
      
      if (existing.length > 0) {
        const parent = existing[Math.floor(Math.random() * existing.length)];
        const angle = Math.random() * Math.PI * 2;
        const radius = 5 + Math.random() * 8;
        x = parent.x + Math.cos(angle) * radius;
        z = parent.z + Math.sin(angle) * radius;
      } else {
        x = districtData.position.x + (Math.random() - 0.5) * 10;
        z = districtData.position.z + (Math.random() - 0.5) * 10;
      }
      
      const newBuilding = createBuilding({
        x, z,
        district,
        height: 5 + Math.random() * 15,
      });
      
      if (existing.length > 0) {
        const nearest = existing.reduce((best, b) => {
          const d1 = Math.hypot(b.x - x, b.z - z);
          const d2 = Math.hypot(best.x - x, best.z - z);
          return d1 < d2 ? b : best;
        });
        createConnection(newBuilding, nearest);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateStats() {
      buildingCountEl.textContent = city.buildings.length;
      districtCountEl.textContent = city.districts.size;
      connectionCountEl.textContent = city.connections.length;
      
      // Update agent count (show row only when agents exist)
      const agentCount = agentSystem?.agents?.size || 0;
      const agentRow = document.getElementById('agentRow');
      const agentCountEl = document.getElementById('agentCount');
      if (agentRow && agentCountEl) {
        agentCountEl.textContent = agentCount;
        agentRow.style.display = agentCount > 0 ? 'flex' : 'none';
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INTERACTION SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const interaction = {
      raycaster: new THREE.Raycaster(),
      mouse: new THREE.Vector2(),
      hoveredBuilding: null,
      selectedBuilding: null,
      focusedDistrict: null,
      isPaused: false,
      originalCameraPosition: null,
      originalControlsTarget: null,
      isAnimatingCamera: false,
      // Touch state
      touchStartTime: 0,
      touchStartPos: { x: 0, y: 0 },
      lastTapTime: 0,
      longPressTimer: null,
    };
    
    // UI Elements
    const tooltipEl = document.getElementById('tooltip');
    const infoPanelEl = document.getElementById('infoPanel');
    const infoPanelTitleEl = document.getElementById('infoPanelTitle');
    const infoPanelCloseEl = document.getElementById('infoPanelClose');
    const infoPanelDistrictEl = document.getElementById('infoPanelDistrict');
    const infoPanelTypeEl = document.getElementById('infoPanelType');
    const infoPanelDimensionsEl = document.getElementById('infoPanelDimensions');
    const infoPanelSourcesEl = document.getElementById('infoPanelSources');
    const focusIndicatorEl = document.getElementById('focusIndicator');
    const focusDistrictNameEl = document.getElementById('focusDistrictName');
    const pauseIndicatorEl = document.getElementById('pauseIndicator');
    const controlsHintEl = document.querySelector('.controls-hint');
    
    // District keys mapping for keyboard shortcuts
    const DISTRICT_KEYS = ['core', 'trading', 'execution', 'cognition', 'memory', 'perception', 'growth', 'relationship', 'emotion'];
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // RAYCASTING & SELECTION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function updateMousePosition(event) {
      const rect = canvas.getBoundingClientRect();
      interaction.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      interaction.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }
    
    function getBuildingMeshes() {
      return city.buildings.map(b => b.mesh).filter(m => m);
    }
    
    function getDistrictLabelSprites() {
      return city.districtLabels.filter(l => l);
    }
    
    function raycastBuildings() {
      interaction.raycaster.setFromCamera(interaction.mouse, camera);
      const meshes = getBuildingMeshes();
      if (meshes.length === 0) return null;
      
      // Use recursive=true to find children of compound buildings
      const intersects = interaction.raycaster.intersectObjects(meshes, true);
      
      if (intersects.length > 0 && intersects[0].object) {
        let mesh = intersects[0].object;
        
        // Traverse up to find the building group (parent might be the actual building)
        while (mesh && mesh.parent) {
          // Check if this mesh or its parent is a building
          const building = city.buildings.find(b => b.mesh === mesh);
          if (building) return building;
          mesh = mesh.parent;
        }
        
        // Fallback: direct match
        return city.buildings.find(b => b.mesh === intersects[0].object) || null;
      }
      return null;
    }
    
    function raycastDistrictLabels() {
      interaction.raycaster.setFromCamera(interaction.mouse, camera);
      const sprites = getDistrictLabelSprites();
      const intersects = interaction.raycaster.intersectObjects(sprites, false);
      
      if (intersects.length > 0) {
        const sprite = intersects[0].object;
        const index = city.districtLabels.indexOf(sprite);
        if (index >= 0) {
          return DISTRICT_KEYS[index];
        }
      }
      return null;
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // HOVER EFFECTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function setHoveredBuilding(building) {
      // Unhover previous
      if (interaction.hoveredBuilding && interaction.hoveredBuilding !== building) {
        unhighlightBuilding(interaction.hoveredBuilding);
      }
      
      interaction.hoveredBuilding = building;
      
      if (building) {
        highlightBuilding(building, 'hover');
        canvas.classList.add('interactive-hover');
      } else {
        canvas.classList.remove('interactive-hover');
        hideTooltip();
      }
    }
    
    function highlightBuilding(building, mode = 'hover') {
      if (!building || !building.mesh || !building.mesh.material) return;
      
      const material = building.mesh.material;
      if (material.emissiveIntensity === undefined) return; // Not all materials have emissive
      
      // Store original values if not already stored
      if (building.originalEmissiveIntensity === undefined) {
        building.originalEmissiveIntensity = material.emissiveIntensity;
      }
      
      // Apply highlight
      if (mode === 'hover') {
        material.emissiveIntensity = (building.originalEmissiveIntensity || 0.5) + 0.4;
      } else if (mode === 'selected') {
        material.emissiveIntensity = (building.originalEmissiveIntensity || 0.5) + 0.7;
      }
    }
    
    function unhighlightBuilding(building) {
      if (!building || !building.mesh || !building.mesh.material) return;
      
      const material = building.mesh.material;
      
      // Restore original intensity
      if (building.originalEmissiveIntensity !== undefined) {
        material.emissiveIntensity = building.originalEmissiveIntensity;
      }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TOOLTIP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function showTooltip(building, x, y) {
      if (!building) return;
      
      const districtData = DISTRICTS[building.district] || DISTRICTS.core;
      const name = building.label || `${districtData.name} Structure`;
      
      tooltipEl.querySelector('.tooltip-name').textContent = name;
      tooltipEl.querySelector('.district-tag').textContent = districtData.name;
      
      // Position tooltip
      const padding = 15;
      let posX = x + padding;
      let posY = y + padding;
      
      // Keep within viewport
      const tooltipRect = tooltipEl.getBoundingClientRect();
      if (posX + 200 > window.innerWidth) {
        posX = x - 200 - padding;
      }
      if (posY + 60 > window.innerHeight) {
        posY = y - 60 - padding;
      }
      
      tooltipEl.style.left = posX + 'px';
      tooltipEl.style.top = posY + 'px';
      tooltipEl.classList.add('visible');
    }
    
    function hideTooltip() {
      tooltipEl.classList.remove('visible');
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INFO PANEL
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function selectBuilding(building) {
      // Deselect previous
      if (interaction.selectedBuilding && interaction.selectedBuilding !== building) {
        unhighlightBuilding(interaction.selectedBuilding);
      }
      
      interaction.selectedBuilding = building;
      
      if (building) {
        highlightBuilding(building, 'selected');
        showInfoPanel(building);
      } else {
        hideInfoPanel();
      }
    }
    
    function showInfoPanel(building) {
      console.log('[showInfoPanel] Called with:', building?.label, 'panel element:', !!infoPanelEl);
      if (!building) return;
      
      const districtData = DISTRICTS[building.district] || DISTRICTS.core;
      const name = building.label || `${districtData.name} Structure`;
      const type = building.type ? building.type.charAt(0).toUpperCase() + building.type.slice(1) : 'Building';
      
      infoPanelTitleEl.textContent = name;
      infoPanelDistrictEl.textContent = districtData.name;
      infoPanelDistrictEl.style.backgroundColor = `rgba(${Math.round(districtData.color.r * 255)}, ${Math.round(districtData.color.g * 255)}, ${Math.round(districtData.color.b * 255)}, 0.2)`;
      infoPanelDistrictEl.style.color = '#' + districtData.color.getHexString();
      infoPanelDistrictEl.style.borderColor = `rgba(${Math.round(districtData.color.r * 255)}, ${Math.round(districtData.color.g * 255)}, ${Math.round(districtData.color.b * 255)}, 0.4)`;
      
      infoPanelTypeEl.textContent = type;
      
      // Importance based on mentions (if available)
      const mentions = building.mentions || 0;
      const maxHeight = 60; // Max building height
      const importance = Math.min(100, Math.round((building.height / maxHeight) * 100));
      const importanceLabel = importance >= 80 ? 'â­ Landmark' : 
                              importance >= 50 ? 'ğŸ¢ Major' :
                              importance >= 25 ? 'ğŸ  Standard' : 'ğŸšï¸ Minor';
      infoPanelDimensionsEl.textContent = `${importanceLabel} (${importance}% importance)`;
      
      // Actual memory sources from building data
      const sources = building.sources || [];
      if (sources.length > 0) {
        infoPanelSourcesEl.innerHTML = sources.slice(0, 5).map(s => 
          `<span class="info-panel-source">${s}</span>`
        ).join('') + (sources.length > 5 ? `<span class="info-panel-source">+${sources.length - 5} more</span>` : '');
      } else {
        infoPanelSourcesEl.innerHTML = '<span class="info-panel-source">No sources</span>';
      }
      
      infoPanelEl.classList.add('visible');
      console.log('[showInfoPanel] Panel should now be visible, classList:', infoPanelEl.classList.toString());
    }
    
    function hideInfoPanel() {
      infoPanelEl.classList.remove('visible');
      if (interaction.selectedBuilding) {
        unhighlightBuilding(interaction.selectedBuilding);
        interaction.selectedBuilding = null;
      }
    }
    
    // Close button handler (click + touch for better mobile support)
    infoPanelCloseEl.addEventListener('click', hideInfoPanel);
    infoPanelCloseEl.addEventListener('touchend', (e) => {
      e.preventDefault();
      hideInfoPanel();
    });
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DISTRICT FOCUS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function focusDistrict(districtKey) {
      if (interaction.isAnimatingCamera) return;
      
      const districtData = DISTRICTS[districtKey];
      if (!districtData) return;
      
      // Store original camera state if not already stored
      if (!interaction.originalCameraPosition) {
        interaction.originalCameraPosition = camera.position.clone();
        interaction.originalControlsTarget = controls.target.clone();
      }
      
      interaction.focusedDistrict = districtKey;
      
      // Calculate target camera position
      const targetPos = districtData.position.clone();
      const cameraOffset = new THREE.Vector3(15, 20, 15);
      const targetCameraPos = targetPos.clone().add(cameraOffset);
      const targetLookAt = targetPos.clone().add(new THREE.Vector3(0, 8, 0));
      
      // Animate camera
      animateCamera(targetCameraPos, targetLookAt);
      
      // Fade other districts
      fadeOtherDistricts(districtKey, 0.3);
      
      // Show focus indicator
      focusDistrictNameEl.textContent = districtData.name;
      focusIndicatorEl.classList.add('visible');
      
      // Update controls hint
      if (controlsHintEl) {
        controlsHintEl.style.opacity = '0';
      }
    }
    
    function resetView() {
      if (interaction.isAnimatingCamera) return;
      if (!interaction.originalCameraPosition) return;
      
      interaction.focusedDistrict = null;
      
      // Animate back to original position
      animateCamera(
        interaction.originalCameraPosition.clone(),
        interaction.originalControlsTarget.clone()
      );
      
      // Restore all district visibility
      fadeOtherDistricts(null, 1);
      
      // Hide focus indicator
      focusIndicatorEl.classList.remove('visible');
      
      // Restore controls hint
      if (controlsHintEl) {
        controlsHintEl.style.opacity = '1';
      }
      
      // Clear stored positions
      interaction.originalCameraPosition = null;
      interaction.originalControlsTarget = null;
    }
    
    function animateCamera(targetPosition, targetLookAt) {
      interaction.isAnimatingCamera = true;
      
      const startPosition = camera.position.clone();
      const startTarget = controls.target.clone();
      const duration = 1000; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease out cubic
        const eased = 1 - Math.pow(1 - progress, 3);
        
        camera.position.lerpVectors(startPosition, targetPosition, eased);
        controls.target.lerpVectors(startTarget, targetLookAt, eased);
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          interaction.isAnimatingCamera = false;
        }
      }
      
      animate();
    }
    
    function fadeOtherDistricts(focusedKey, targetOpacity) {
      city.buildings.forEach(building => {
        if (!building.mesh || !building.mesh.material) return;
        
        const material = building.mesh.material;
        
        if (focusedKey && building.district !== focusedKey) {
          // Fade out non-focused buildings
          if (material.transparent === undefined || material.transparent === false) {
            material.transparent = true;
          }
          material.opacity = targetOpacity;
        } else {
          // Restore focused or all buildings
          material.opacity = 1;
        }
      });
      
      // Fade district labels
      city.districtLabels.forEach((label, index) => {
        const key = DISTRICT_KEYS[index];
        if (focusedKey && key !== focusedKey) {
          label.material.opacity = targetOpacity;
        } else {
          label.material.opacity = 0.8;
        }
      });
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // PAUSE/RESUME
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    function togglePause() {
      interaction.isPaused = !interaction.isPaused;
      pauseIndicatorEl.classList.toggle('visible', interaction.isPaused);
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MOUSE EVENTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    let mouseDownTime = 0;
    let mouseDownPos = { x: 0, y: 0 };
    
    canvas.addEventListener('mousemove', (event) => {
      updateMousePosition(event);
      
      // Raycast for hover
      const hoveredBuilding = raycastBuildings();
      const hoveredDistrict = raycastDistrictLabels();
      
      if (hoveredBuilding) {
        setHoveredBuilding(hoveredBuilding);
        showTooltip(hoveredBuilding, event.clientX, event.clientY);
      } else if (hoveredDistrict) {
        canvas.classList.add('interactive-hover');
        hideTooltip();
        setHoveredBuilding(null);
      } else {
        setHoveredBuilding(null);
      }
    });
    
    let lastClickHandled = 0;
    
    canvas.addEventListener('mousedown', (event) => {
      mouseDownTime = Date.now();
      mouseDownPos = { x: event.clientX, y: event.clientY };
    });
    
    canvas.addEventListener('mouseup', (event) => {
      const elapsed = Date.now() - mouseDownTime;
      const distance = Math.hypot(event.clientX - mouseDownPos.x, event.clientY - mouseDownPos.y);
      
      // Only count as click if short duration and minimal movement
      if (elapsed < 300 && distance < 10) {
        if (Date.now() - lastClickHandled > 100) {
          lastClickHandled = Date.now();
          handleClick(event);
        }
      }
    });
    
    // Backup click handler - always fires, use simple click detection
    canvas.addEventListener('click', (event) => {
      // If mouseDownTime wasn't set (OrbitControls intercepted), just handle the click
      const elapsed = mouseDownTime ? (Date.now() - mouseDownTime) : 0;
      const distance = mouseDownPos ? Math.hypot(event.clientX - mouseDownPos.x, event.clientY - mouseDownPos.y) : 0;
      
      console.log('[ClickEvent] elapsed:', elapsed, 'distance:', distance.toFixed(1), 'hasDownTime:', !!mouseDownTime);
      
      // Accept click if: short duration, minimal movement, OR no mousedown recorded (OrbitControls ate it)
      const isValidClick = (elapsed < 400 && distance < 15) || !mouseDownTime;
      
      if (isValidClick) {
        if (Date.now() - lastClickHandled > 100) {
          lastClickHandled = Date.now();
          handleClick(event);
        } else {
          console.log('[ClickEvent] Debounced');
        }
      } else {
        console.log('[ClickEvent] Rejected as drag');
      }
    });
    
    canvas.addEventListener('dblclick', (event) => {
      updateMousePosition(event);
      
      const hoveredDistrict = raycastDistrictLabels();
      if (hoveredDistrict) {
        focusDistrict(hoveredDistrict);
      } else if (interaction.focusedDistrict) {
        resetView();
      }
    });
    
    function handleClick(event) {
      updateMousePosition(event);
      
      const clickedBuilding = raycastBuildings();
      const clickedDistrict = raycastDistrictLabels();
      
      console.log('[Click] mouse:', interaction.mouse.x.toFixed(2), interaction.mouse.y.toFixed(2), 
                  'building:', clickedBuilding?.label || 'none', 
                  'district:', clickedDistrict || 'none');
      
      if (clickedBuilding) {
        console.log('[Click] Selecting building:', clickedBuilding.label);
        selectBuilding(clickedBuilding);
      } else if (clickedDistrict) {
        focusDistrict(clickedDistrict);
      } else {
        // Clicked on empty space - close info panel if open
        if (interaction.selectedBuilding) {
          hideInfoPanel();
        }
      }
    }
    
    // Hide tooltip when leaving canvas
    canvas.addEventListener('mouseleave', () => {
      hideTooltip();
      setHoveredBuilding(null);
    });
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TOUCH EVENTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    canvas.addEventListener('touchstart', (event) => {
      if (event.touches.length !== 1) return;
      
      const touch = event.touches[0];
      interaction.touchStartTime = Date.now();
      interaction.touchStartPos = { x: touch.clientX, y: touch.clientY };
      
      // Setup long press detection
      interaction.longPressTimer = setTimeout(() => {
        // Long press - show info panel
        updateMousePosition(touch);
        const building = raycastBuildings();
        if (building) {
          selectBuilding(building);
        }
      }, 500);
    });
    
    canvas.addEventListener('touchmove', (event) => {
      // Cancel long press if finger moves
      if (interaction.longPressTimer) {
        const touch = event.touches[0];
        const distance = Math.hypot(
          touch.clientX - interaction.touchStartPos.x,
          touch.clientY - interaction.touchStartPos.y
        );
        if (distance > 10) {
          clearTimeout(interaction.longPressTimer);
          interaction.longPressTimer = null;
        }
      }
    });
    
    canvas.addEventListener('touchend', (event) => {
      clearTimeout(interaction.longPressTimer);
      interaction.longPressTimer = null;
      
      const elapsed = Date.now() - interaction.touchStartTime;
      const touch = event.changedTouches[0];
      const distance = Math.hypot(
        touch.clientX - interaction.touchStartPos.x,
        touch.clientY - interaction.touchStartPos.y
      );
      
      // Tap detection
      if (elapsed < 300 && distance < 15) {
        const now = Date.now();
        
        // Double tap detection
        if (now - interaction.lastTapTime < 300) {
          // Double tap - zoom to district or reset view
          updateMousePosition(touch);
          const district = raycastDistrictLabels();
          if (district) {
            focusDistrict(district);
          } else if (interaction.focusedDistrict) {
            resetView();
          }
        } else {
          // Single tap
          updateMousePosition(touch);
          const building = raycastBuildings();
          if (building) {
            selectBuilding(building);
          } else {
            hideInfoPanel();
          }
        }
        
        interaction.lastTapTime = now;
      }
    });
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // KEYBOARD CONTROLS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    document.addEventListener('keydown', (event) => {
      // Ignore if typing in an input
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
      
      const key = event.key.toLowerCase();
      
      // Number keys 1-5 for district focus
      if (key >= '1' && key <= '5') {
        const index = parseInt(key) - 1;
        if (DISTRICT_KEYS[index]) {
          focusDistrict(DISTRICT_KEYS[index]);
        }
        return;
      }
      
      // 0 or Escape to reset view
      if (key === '0' || key === 'escape') {
        if (interaction.focusedDistrict) {
          resetView();
        } else if (interaction.selectedBuilding) {
          hideInfoPanel();
        }
        return;
      }
      
      // Space to pause/resume animations
      if (key === ' ') {
        event.preventDefault();
        togglePause();
        return;
      }
      
      // Weather controls (consolidated from separate handler)
      if (key === 'r') {
        setWeather('rain');
        return;
      }
      if (key === 'f') {
        setWeather('fog');
        return;
      }
      // 'a' for aurora (but not if it conflicts with other shortcuts)
      if (key === 'a' && !event.ctrlKey && !event.metaKey) {
        setWeather('aurora');
        return;
      }
      if (key === 'c' && !event.ctrlKey && !event.metaKey) {
        setWeather('clear');
        return;
      }
      // 'w' to toggle auto weather cycling
      if (key === 'w') {
        city.weatherCycleEnabled = !city.weatherCycleEnabled;
        console.log(`[Weather] Auto-cycling: ${city.weatherCycleEnabled ? 'ON' : 'OFF'}`);
        return;
      }
      // 'l' to trigger manual lightning (for testing/fun)
      if (key === 'l') {
        if (city.weather !== 'rain') setWeather('rain');
        setTimeout(() => triggerLightningFlash(), 500);
        return;
      }
      // 'm' to trigger meteor shower
      if (key === 'm') {
        triggerMeteorShower(30);
        return;
      }
      
      // Arrow keys for slow camera rotation
      const rotationSpeed = 0.02;
      if (key === 'arrowleft') {
        controls.autoRotate = false;
        const angle = rotationSpeed;
        const x = camera.position.x - controls.target.x;
        const z = camera.position.z - controls.target.z;
        camera.position.x = controls.target.x + x * Math.cos(angle) - z * Math.sin(angle);
        camera.position.z = controls.target.z + x * Math.sin(angle) + z * Math.cos(angle);
        return;
      }
      if (key === 'arrowright') {
        controls.autoRotate = false;
        const angle = -rotationSpeed;
        const x = camera.position.x - controls.target.x;
        const z = camera.position.z - controls.target.z;
        camera.position.x = controls.target.x + x * Math.cos(angle) - z * Math.sin(angle);
        camera.position.z = controls.target.z + x * Math.sin(angle) + z * Math.cos(angle);
        return;
      }
      if (key === 'arrowup') {
        const distance = camera.position.distanceTo(controls.target);
        if (distance > controls.minDistance + 5) {
          camera.position.lerp(controls.target, 0.05);
        }
        return;
      }
      if (key === 'arrowdown') {
        const distance = camera.position.distanceTo(controls.target);
        if (distance < controls.maxDistance - 5) {
          const direction = camera.position.clone().sub(controls.target).normalize();
          camera.position.add(direction.multiplyScalar(2));
        }
        return;
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANIMATION LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let frameCount = 0;
    let lastFpsTime = 0;
    let pausedTime = 0;
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      // Handle pause - freeze animation time but keep rendering
      let dt;
      if (interaction.isPaused) {
        if (pausedTime === 0) pausedTime = time;
        dt = pausedTime * 0.001;
      } else {
        if (pausedTime > 0) pausedTime = 0;
        dt = time * 0.001;
      }
      
      // FPS
      frameCount++;
      if (time - lastFpsTime > 1000) {
        fpsEl.textContent = `${frameCount} fps${interaction.isPaused ? ' (paused)' : ''}`;
        frameCount = 0;
        lastFpsTime = time;
        updateStats(); // Update HUD stats including agent count
      }
      
      controls.update();
      updateLighting();
      updateWeather(dt);
      updateLightning(dt);
      updateWeatherCycle(dt);
      
      // Sound system updates
      if (soundManager.enabled) {
        const now = new Date();
        const hours = now.getHours() + now.getMinutes() / 60;
        soundManager.updateTimePhase(hours, city.nightIntensity);
        soundManager.updateCameraDistance(camera.position.distanceTo(controls.target));
      }
      
      // Core animations - more vibrant at night
      if (city.coreRings) {
        const coreNightBoost = 1 + city.nightIntensity * 0.5;
        city.coreRings.forEach(ring => {
          if (ring.userData.rotationAxis === 'z') {
            ring.rotation.z += ring.userData.rotationSpeed * 0.01;
            ring.rotation.x = Math.PI / 2 + Math.sin(dt + ring.userData.wobble) * 0.1;
            ring.material.opacity = (0.5 + city.nightIntensity * 0.3) * coreNightBoost;
          } else if (ring.userData.rotationAxis === 'y') {
            ring.rotation.y += ring.userData.rotationSpeed * 0.01;
            ring.material.opacity = (0.4 + city.nightIntensity * 0.4) * coreNightBoost;
          } else if (ring.userData.beamPhase !== undefined) {
            const beamPulse = Math.sin(dt * 2 + ring.userData.beamPhase) * 0.15;
            ring.material.opacity = (0.15 + beamPulse + city.nightIntensity * 0.2) * coreNightBoost;
          } else if (ring.userData.pulseRing) {
            const scale = 1 + Math.sin(dt * 1.5 + ring.userData.pulsePhase) * 0.1;
            ring.scale.set(scale, scale, 1);
            ring.material.opacity = (0.25 + city.nightIntensity * 0.2) * coreNightBoost;
          }
        });
      }
      
      // Core glow pulse - heart of the city
      if (city.coreGlow) {
        const nightIntensity = 1 + city.nightIntensity * 0.4;
        const pulse = 1 + Math.sin(dt * 2) * 0.2 * nightIntensity;
        city.coreGlow.scale.set(pulse, pulse, pulse);
        city.coreGlow.material.opacity = (0.5 + Math.sin(dt * 3) * 0.2) * nightIntensity;
        
        // Color shifts slightly with time
        if (lighting.goldenHourIntensity > 0) {
          city.coreGlow.material.color.setHex(0x44ffcc); // Warm cyan
        } else if (city.nightIntensity > 0.5) {
          city.coreGlow.material.color.setHex(0x00ddff); // Cool cyan
        } else {
          city.coreGlow.material.color.setHex(0x00ffff); // Neutral cyan
        }
      }
      
      // Building effects with cinematic lighting response
      if (Math.floor(time) % 100 < 16) {
        // Golden hour surface glow factor
        const goldenGlow = lighting.goldenHourIntensity;
        const rimFactor = lighting.rimLightIntensity;
        const windowProgress = lighting.windowLightProgress;
        
        city.buildings.forEach((b, buildingIndex) => {
          if (b.mesh.material && b.mesh.material.emissive) {
            // Base emissive from district
            const districtData = DISTRICTS[b.district] || DISTRICTS.core;
            
            // Night boost for emissives
            const nightBoost = 0.5 + city.nightIntensity * 1.5;
            
            // Golden hour warm tint on surfaces
            if (goldenGlow > 0) {
              const warmTint = new THREE.Color(0xff9944).multiplyScalar(goldenGlow * 0.3);
              b.mesh.material.emissive.copy(districtData.emissive).add(warmTint);
            } else {
              b.mesh.material.emissive.copy(districtData.emissive);
            }
            
            // Buildings glow more at night - city comes alive!
            b.mesh.material.emissiveIntensity = 0.4 + city.nightIntensity * 0.8;
            
            // Moonlight blue tint at night
            if (city.nightIntensity > 0.3) {
              const moonTint = new THREE.Color(0x2244aa).multiplyScalar(city.nightIntensity * 0.15);
              b.mesh.material.emissive.add(moonTint);
              
              // Additional warm window glow to simulate interior lights
              const windowGlow = new THREE.Color(0xffaa66).multiplyScalar(city.nightIntensity * 0.1);
              b.mesh.material.emissive.add(windowGlow);
            }
          }
          
          // Animate child elements (windows, antennas, holograms)
          b.mesh.children.forEach((child, childIndex) => {
            // Antenna blink lights
            if (child.userData.blink) {
              const blinkSpeed = 3 + (buildingIndex % 3); // Varied speeds
              child.material.opacity = Math.sin(dt * blinkSpeed + child.userData.blinkPhase) > 0.7 ? 1 : 0.2;
            }
            
            // Beacon pulse
            if (child.userData.pulse) {
              const pulseIntensity = 0.2 + city.nightIntensity * 0.3;
              const p = 1 + Math.sin(dt * 2 + child.userData.pulsePhase) * pulseIntensity;
              child.scale.set(p, p, p);
            }
            
            // Window strips - gradual lighting response
            if (child.geometry && (child.geometry.type === 'BoxGeometry' || child.geometry.type === 'TorusGeometry')) {
              // Some windows are "always on" (odd indices), others respond to time
              const alwaysOn = childIndex % 3 === 0;
              const baseOpacity = alwaysOn ? 0.4 : 0.1;
              const nightOpacity = alwaysOn ? 0.8 : windowProgress * 0.7;
              
              // Slight flicker for realism
              const flicker = Math.random() > 0.98 ? 0.1 : 0;
              child.material.opacity = baseOpacity + nightOpacity + flicker;
              
              // Windows get warmer at night (interior glow)
              if (city.nightIntensity > 0.2 && child.material.color) {
                const warmth = city.nightIntensity * 0.2;
                child.material.color.setRGB(
                  1, 
                  0.9 - warmth * 0.1, 
                  0.7 - warmth * 0.3
                );
              }
            }
            
            // Holographic ads - much brighter at night
            if (child.userData.hologram) {
              const nightMultiplier = 1 + city.nightIntensity * 1.5;
              const baseFlicker = Math.sin(dt * 5 + child.userData.flickerPhase) * 0.15;
              const glitchChance = Math.random() > 0.97 ? -0.3 : 0;
              child.material.opacity = (0.25 + baseFlicker + glitchChance) * nightMultiplier;
              
              // Scanline children also brighten
              child.children.forEach(scanline => {
                if (scanline.material) {
                  scanline.material.opacity = 0.2 + city.nightIntensity * 0.4;
                }
              });
            }
          });
        });
      }
      
      // Connection pulse - brighter energy flow at night
      city.connections.forEach((conn, i) => {
        const baseSpeed = 2 + (i % 3) * 0.3; // Varied speeds
        const pulse = Math.sin(dt * baseSpeed + i * 0.5) * 0.12 + 0.2;
        const nightBoost = 1 + city.nightIntensity * 1.2;
        conn.line.material.opacity = pulse * nightBoost;
        
        // Shift connection color slightly warmer during golden hour
        if (lighting.goldenHourIntensity > 0) {
          const warmShift = lighting.goldenHourIntensity * 0.2;
          conn.line.material.color.setRGB(0 + warmShift, 1, 1 - warmShift * 0.5);
        } else {
          conn.line.material.color.setHex(0x00ffff);
        }
      });
      
      // District labels float - more visible at night, subtle during day
      city.districtLabels.forEach(label => {
        label.position.y = label.userData.baseY + Math.sin(dt * 0.5 + label.userData.floatPhase) * 1;
        // Fade based on time: subtle during bright day, prominent at night
        const dayFade = Math.max(0, 1 - city.nightIntensity * 0.5 - (1 - city.nightIntensity) * 0.4);
        label.material.opacity = 0.3 + dayFade * 0.2 + city.nightIntensity * 0.5;
      });
      
      // Drones
      updateDrones(dt);
      
      // Thought bubbles
      updateThoughts(dt);
      
      // Particles
      updateParticles();
      
      // Environment animations
      updateEnvironment(dt);
      
      // Volumetric god rays (light shafts)
      updateGodRays(dt);
      
      // Neon ground accent rings
      updateNeonAccentRings(dt);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ACTIVITY VISUALIZATION UPDATES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Update district glow intensities (smooth transitions + heat map)
      updateDistrictGlows(dt);
      
      // Update core spire activity response
      updateCoreActivity(dt);
      
      // Update connection line activity (brightness + color)
      updateConnectionActivity(dt);
      
      // Update ripple effects
      updateActivityRipples();
      
      // Update data packets traveling on connections
      updateDataPackets(dt);
      
      // Update brain-like activation effects (energy particles, beams, road glows)
      updateBrainActivation(dt);
      
      // Update individual building activations (fMRI-style)
      updateBuildingActivations(dt);
      
      // Update agent entities
      updateAgents(dt);
      
      // Update City Planner patrol
      updateCityPlanner(dt);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AMBIENT LIFE UPDATES - The city never sleeps (NYC vibes)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Traffic lights moving along roads
      updateTrafficLights(dt);
      
      // Elevators in tall buildings
      updateElevators(dt);
      
      // Fireflies (night) and dust motes (day)
      updateFirefliesAndDust(dt);
      
      // Energy motes (AAA holographic particles)
      updateEnergyMotes(dt);
      
      // Data streams between connected buildings
      updateDataStreams(dt);
      
      // Aircraft and satellites
      updateAircraft(dt);
      
      // Shooting stars (occasional, night only)
      updateShootingStars();
      
      // Window activity (on/off, TV flicker)
      updateWindowActivity(dt);
      
      // District-specific building pulses
      updateDistrictPulses(dt);
      
      // Energy pulse lines traveling up buildings
      city.buildings.forEach(building => {
        building.mesh.children.forEach(child => {
          if (child.userData && child.userData.energyPulse) {
            const data = child.userData;
            data.progress += data.speed;
            if (data.progress > 1) data.progress = 0;
            
            // Move pulse up the building
            const pulseY = data.progress * data.height;
            if (data.pulseElement) {
              data.pulseElement.position.y = pulseY;
              
              // Fade at top and bottom
              const edgeFade = Math.sin(data.progress * Math.PI);
              data.pulseElement.material.opacity = 0.7 * edgeFade * (0.7 + city.nightIntensity * 0.3);
              
              // Glow child also fades
              if (data.pulseElement.children[0]) {
                data.pulseElement.children[0].material.opacity = 0.2 * edgeFade * (0.7 + city.nightIntensity * 0.3);
              }
            }
          }
        });
      });
      
      // Subtle camera micro-movements for cinematic feel (AAA polish)
      if (!interaction.isPaused && !interaction.isAnimatingCamera && !isMobile) {
        const microSway = 0.0003;
        const breathe = Math.sin(dt * 0.3) * microSway;
        const drift = Math.cos(dt * 0.2) * microSway * 0.5;
        camera.position.x += breathe;
        camera.position.y += drift * 0.3;
      }
      
      // Update building edge glow effects (cyberpunk neon)
      if (!isMobile) {
        city.buildings.forEach(building => {
          if (!building.mesh) return;
          building.mesh.children.forEach(child => {
            if (child.userData && child.userData.edgeGlow) {
              // Gentle pulse based on night intensity
              const pulse = 0.25 + Math.sin(dt * 1.5 + child.userData.glowPhase) * 0.1;
              const nightBoost = city.nightIntensity * 0.4;
              child.material.opacity = pulse + nightBoost;
            }
          });
        });
      }
      
      // City growth
      growCity();
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // POST-PROCESSING UPDATES - Dynamic cinematic effects
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Film grain animation (time-based noise)
      if (postProcessing.filmGrainPass) {
        postProcessing.filmGrainPass.uniforms.time.value = time;
        // More grain at night for that noir feel
        postProcessing.filmGrainPass.uniforms.intensity.value = 0.025 + city.nightIntensity * 0.015;
      }
      
      // Chromatic aberration - stronger at night and during action
      if (postProcessing.chromaPass) {
        const baseChroma = 0.001;
        const nightBoost = city.nightIntensity * 0.0015;
        const actionBoost = activityState.mode !== 'idle' ? 0.001 : 0;
        postProcessing.chromaPass.uniforms.amount.value = baseChroma + nightBoost + actionBoost;
        // Rotate aberration angle slowly
        postProcessing.chromaPass.uniforms.angle.value = dt * 0.1;
      }
      
      // Vignette - darker at night, lighter during day
      if (postProcessing.vignettePass) {
        const baseDarkness = 0.5;
        const nightDarkness = city.nightIntensity * 0.2;
        postProcessing.vignettePass.uniforms.darkness.value = baseDarkness + nightDarkness;
      }
      
      // Render with full post-processing pipeline
      composer.render();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RESIZE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEBSOCKET (Live Knowledge Connection)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // WebSocket URL derived from API_URL
    const WS_URL = API_URL.replace('https://', 'wss://').replace('http://', 'ws://');
    let cityWebSocket = null;
    let districtGlowIntensities = {};
    let cityLoadedFromServer = false;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ACTIVITY VISUALIZATION STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const activityState = {
      mode: 'idle',                    // 'idle', 'thinking', 'responding'
      activeDistrict: null,            // Currently active district key
      activityStartTime: 0,            // When current activity started
      
      // Per-district activity tracking
      districtActivity: {},            // { district: { intensity: 0-1, lastActive: timestamp } }
      
      // Visual effect pools
      ripples: [],                     // Active ripple effects
      dataPackets: [],                 // Data packets traveling on connections
      
      // Core spire state
      corePulseRate: 1.0,              // Multiplier for core pulse speed
      coreEnergyDirection: 0,          // -1 inward, 0 neutral, 1 outward
      
      // Color themes by mode
      modeColors: {
        idle: { primary: 0x00ffff, secondary: 0x0088aa, glow: 0.3 },
        thinking: { primary: 0x00ddff, secondary: 0x0066cc, glow: 0.8 },
        responding: { primary: 0xffdd44, secondary: 0xffaa00, glow: 1.0 }
      }
    };
    
    // Initialize district activity tracking
    Object.keys(DISTRICTS).forEach(key => {
      activityState.districtActivity[key] = {
        intensity: 0.3,
        targetIntensity: 0.3,
        lastActive: 0,
        heatLevel: 0,          // Accumulates over time for "warmth map"
        pulsePhase: Math.random() * Math.PI * 2
      };
    });
    
    // API URL - same origin (knowledge engine serves both API and static files)
    const API_URL = window.location.origin;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BRAIN-LIKE ACTIVATION SYSTEM - Energy flows, district glows, cognitive visuals
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const brainActivation = {
      // Energy flow particles
      energyParticles: null,
      particleCount: isMobile ? 150 : 400,
      particleVelocities: [],
      particleTargets: [],    // Where each particle is flowing to
      particleSources: [],    // Where each particle came from
      
      // State
      energyDirection: 0,     // -1 = inward (thinking), 0 = neutral, 1 = outward (responding)
      breathPhase: 0,         // For idle breathing effect
      pulseWave: 0,           // Expanding pulse wave from core during state changes
      
      // District activation beams (light pillars)
      districtBeams: new Map(),
      
      // Active connection highlighting
      activeConnections: new Set(),
      
      // Color palettes
      colors: {
        idle: {
          energy: new THREE.Color(0x00ffff),
          glow: new THREE.Color(0x003344),
          intensity: 0.3
        },
        thinking: {
          energy: new THREE.Color(0x00aaff),
          glow: new THREE.Color(0x001155),
          intensity: 0.9
        },
        responding: {
          energy: new THREE.Color(0xffdd00),
          glow: new THREE.Color(0x443300),
          intensity: 1.0
        }
      }
    };
    
    /**
     * Initialize the brain activation energy particle system
     */
    function initBrainActivationSystem() {
      const count = brainActivation.particleCount;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      
      // Initialize particles distributed across the city
      for (let i = 0; i < count; i++) {
        // Start at random positions
        const angle = Math.random() * Math.PI * 2;
        const radius = 5 + Math.random() * 60;
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = 1 + Math.random() * 20;
        positions[i * 3 + 2] = Math.sin(angle) * radius;
        
        // Initial cyan color
        colors[i * 3] = 0;
        colors[i * 3 + 1] = 1;
        colors[i * 3 + 2] = 1;
        
        sizes[i] = 0.3 + Math.random() * 0.4;
        
        // Initialize velocity and target data
        brainActivation.particleVelocities.push({
          x: (Math.random() - 0.5) * 0.1,
          y: (Math.random() - 0.5) * 0.05,
          z: (Math.random() - 0.5) * 0.1,
          speed: 0.02 + Math.random() * 0.03
        });
        brainActivation.particleTargets.push(null);
        brainActivation.particleSources.push(null);
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      // Custom shader for size attenuation and glow
      const material = new THREE.PointsMaterial({
        size: 0.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
        depthWrite: false
      });
      
      brainActivation.energyParticles = new THREE.Points(geometry, material);
      scene.add(brainActivation.energyParticles);
      
      console.log('[BrainActivation] Energy particle system initialized with', count, 'particles');
    }
    
    /**
     * Create a light beam pillar for an active district
     */
    function createDistrictBeam(districtKey) {
      if (brainActivation.districtBeams.has(districtKey)) return;
      
      const district = DISTRICTS[districtKey];
      if (!district) return;
      
      const beamGroup = new THREE.Group();
      beamGroup.position.set(district.position.x, 0, district.position.z);
      
      // Main beam cylinder
      const beamHeight = 80;
      const beamGeo = new THREE.CylinderGeometry(0.5, 2, beamHeight, 8, 1, true);
      const beamMat = new THREE.MeshBasicMaterial({
        color: district.color,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.y = beamHeight / 2;
      beamGroup.add(beam);
      
      // Ground ring
      const ringGeo = new THREE.RingGeometry(1, 4, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: district.color,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = 0.1;
      beamGroup.add(ring);
      
      // Inner glow core
      const glowGeo = new THREE.SphereGeometry(2, 16, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: district.color,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 2;
      beamGroup.add(glow);
      
      scene.add(beamGroup);
      
      brainActivation.districtBeams.set(districtKey, {
        group: beamGroup,
        beam: beam,
        ring: ring,
        glow: glow,
        targetOpacity: 0,
        currentOpacity: 0
      });
    }
    
    /**
     * Update the brain activation system - called every frame
     */
    function updateBrainActivation(dt) {
      const mode = activityState.mode;
      const activeDistrict = activityState.activeDistrict;
      const palette = brainActivation.colors[mode] || brainActivation.colors.idle;
      
      // Update energy direction based on mode
      let targetDirection = 0;
      if (mode === 'thinking') targetDirection = -1;      // Inward
      else if (mode === 'responding') targetDirection = 1; // Outward
      
      brainActivation.energyDirection += (targetDirection - brainActivation.energyDirection) * 0.02;
      
      // Update breathing phase (always runs, more pronounced when idle)
      const breathSpeed = mode === 'idle' ? 0.5 : 1.5;
      brainActivation.breathPhase += breathSpeed * 0.016;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // UPDATE ENERGY PARTICLES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      if (brainActivation.energyParticles) {
        const positions = brainActivation.energyParticles.geometry.attributes.position.array;
        const colors = brainActivation.energyParticles.geometry.attributes.color.array;
        const velocities = brainActivation.particleVelocities;
        const targets = brainActivation.particleTargets;
        
        const corePos = DISTRICTS.core.position;
        const activeDistrictPos = activeDistrict ? DISTRICTS[activeDistrict]?.position : null;
        
        for (let i = 0; i < velocities.length; i++) {
          const v = velocities[i];
          let px = positions[i * 3];
          let py = positions[i * 3 + 1];
          let pz = positions[i * 3 + 2];
          
          if (mode === 'idle') {
            // IDLE: Gentle ambient drift with breathing
            const breathEffect = Math.sin(brainActivation.breathPhase + i * 0.1) * 0.02;
            px += v.x * 0.3 + breathEffect;
            py += v.y * 0.3 + Math.sin(dt * 0.5 + i) * 0.01;
            pz += v.z * 0.3;
            
            // Slow color fade to calm cyan
            colors[i * 3] = colors[i * 3] * 0.99 + 0 * 0.01;
            colors[i * 3 + 1] = colors[i * 3 + 1] * 0.99 + 0.8 * 0.01;
            colors[i * 3 + 2] = colors[i * 3 + 2] * 0.99 + 0.9 * 0.01;
            
          } else if (mode === 'thinking') {
            // THINKING: Blue energy gathering toward cognition center (core or active district)
            const targetPos = activeDistrictPos || corePos;
            const dx = targetPos.x - px;
            const dy = 8 - py; // Converge at height 8
            const dz = targetPos.z - pz;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (dist > 1) {
              // Accelerate toward target
              const strength = 0.02 + (1 - dist / 80) * 0.03;
              px += dx / dist * v.speed * 2 + v.x * 0.2;
              py += dy / dist * v.speed * 1.5;
              pz += dz / dist * v.speed * 2 + v.z * 0.2;
              
              // Spiral inward effect
              const angle = Math.atan2(pz - targetPos.z, px - targetPos.x);
              px += Math.cos(angle + Math.PI/2) * 0.05;
              pz += Math.sin(angle + Math.PI/2) * 0.05;
            } else {
              // Respawn at edge when reaching center
              const spawnAngle = Math.random() * Math.PI * 2;
              const spawnRadius = 40 + Math.random() * 30;
              px = corePos.x + Math.cos(spawnAngle) * spawnRadius;
              py = 2 + Math.random() * 25;
              pz = corePos.z + Math.sin(spawnAngle) * spawnRadius;
            }
            
            // Blue color with pulse
            const pulse = 0.7 + Math.sin(dt * 4 + i * 0.3) * 0.3;
            colors[i * 3] = 0 * pulse;
            colors[i * 3 + 1] = 0.6 * pulse;
            colors[i * 3 + 2] = 1.0 * pulse;
            
          } else if (mode === 'responding') {
            // RESPONDING: Golden energy radiating outward from core
            const dx = px - corePos.x;
            const dz = pz - corePos.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist < 70) {
              // Radiate outward
              const angle = Math.atan2(dz, dx);
              const outwardSpeed = v.speed * 2.5;
              px += Math.cos(angle) * outwardSpeed + v.x * 0.3;
              py += Math.sin(dt * 2 + i) * 0.02; // Gentle wave
              pz += Math.sin(angle) * outwardSpeed + v.z * 0.3;
              
              // Rise slightly as they spread
              py += 0.01;
            } else {
              // Respawn at core when reaching edge
              const spawnAngle = Math.random() * Math.PI * 2;
              px = corePos.x + Math.cos(spawnAngle) * 3;
              py = 5 + Math.random() * 10;
              pz = corePos.z + Math.sin(spawnAngle) * 3;
            }
            
            // Golden color with warm pulse
            const pulse = 0.8 + Math.sin(dt * 3 + i * 0.2) * 0.2;
            colors[i * 3] = 1.0 * pulse;
            colors[i * 3 + 1] = 0.85 * pulse;
            colors[i * 3 + 2] = 0.2 * pulse;
          }
          
          // Boundary enforcement
          if (py < 0.5) py = 0.5 + Math.random() * 2;
          if (py > 50) py = 5 + Math.random() * 10;
          if (Math.abs(px) > 80 || Math.abs(pz) > 80) {
            px = (Math.random() - 0.5) * 60;
            pz = (Math.random() - 0.5) * 60;
          }
          
          positions[i * 3] = px;
          positions[i * 3 + 1] = py;
          positions[i * 3 + 2] = pz;
          
          // Occasionally change drift direction
          if (Math.random() < 0.002) {
            v.x = (Math.random() - 0.5) * 0.1;
            v.z = (Math.random() - 0.5) * 0.1;
          }
        }
        
        brainActivation.energyParticles.geometry.attributes.position.needsUpdate = true;
        brainActivation.energyParticles.geometry.attributes.color.needsUpdate = true;
        
        // Adjust overall opacity based on mode
        const targetOpacity = mode === 'idle' ? 0.3 : 0.85;
        brainActivation.energyParticles.material.opacity += 
          (targetOpacity - brainActivation.energyParticles.material.opacity) * 0.05;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // UPDATE DISTRICT BEAMS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Ensure beams exist for all districts
      Object.keys(DISTRICTS).forEach(key => {
        if (!brainActivation.districtBeams.has(key)) {
          createDistrictBeam(key);
        }
      });
      
      // Update beam opacities
      brainActivation.districtBeams.forEach((beamData, districtKey) => {
        const activity = activityState.districtActivity[districtKey];
        const isActive = activity && activity.intensity > 0.5;
        const isPrimary = districtKey === activeDistrict;
        
        // Target opacity based on activity
        let targetOpacity = 0;
        if (mode !== 'idle') {
          if (isPrimary) targetOpacity = 0.6;
          else if (isActive) targetOpacity = 0.25;
        }
        
        // Smooth transition
        beamData.currentOpacity += (targetOpacity - beamData.currentOpacity) * 0.05;
        
        // Apply with pulse
        const pulse = 1 + Math.sin(dt * 3 + districtKey.length) * 0.15;
        const opacity = beamData.currentOpacity * pulse;
        
        beamData.beam.material.opacity = opacity * 0.5;
        beamData.ring.material.opacity = opacity * 0.8;
        beamData.glow.material.opacity = opacity * 0.6;
        
        // Scale ring pulse
        const ringScale = 1 + beamData.currentOpacity * Math.sin(dt * 2) * 0.2;
        beamData.ring.scale.set(ringScale, ringScale, 1);
        
        // Glow pulse
        const glowScale = 1 + beamData.currentOpacity * 0.5 + Math.sin(dt * 4) * 0.1;
        beamData.glow.scale.setScalar(glowScale);
        
        // Color shift based on mode
        if (mode === 'thinking') {
          beamData.beam.material.color.lerp(new THREE.Color(0x00aaff), 0.02);
          beamData.glow.material.color.lerp(new THREE.Color(0x0066ff), 0.02);
        } else if (mode === 'responding') {
          beamData.beam.material.color.lerp(new THREE.Color(0xffdd00), 0.02);
          beamData.glow.material.color.lerp(new THREE.Color(0xffaa00), 0.02);
        } else {
          // Return to district color
          const districtColor = DISTRICTS[districtKey].color;
          beamData.beam.material.color.lerp(districtColor, 0.02);
          beamData.glow.material.color.lerp(districtColor, 0.02);
        }
      });
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // UPDATE CONNECTION ROAD GLOWS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      city.connections.forEach((conn, i) => {
        const fromActivity = activityState.districtActivity[conn.from.district];
        const toActivity = activityState.districtActivity[conn.to.district];
        
        const fromActive = fromActivity && fromActivity.intensity > 0.5;
        const toActive = toActivity && toActivity.intensity > 0.5;
        const bothActive = fromActive && toActive;
        const eitherActive = fromActive || toActive;
        
        // Base pulse
        const baseSpeed = 2 + (i % 3) * 0.3;
        let basePulse = Math.sin(dt * baseSpeed + i * 0.5) * 0.1;
        
        let targetOpacity = 0.15; // Idle base
        let targetColor = new THREE.Color(0x00ffff);
        
        if (mode !== 'idle') {
          if (bothActive) {
            // Both endpoints active - BRIGHT glowing road
            targetOpacity = 0.7 + basePulse;
            // Color based on mode
            if (mode === 'thinking') {
              targetColor = new THREE.Color(0x00aaff);
            } else if (mode === 'responding') {
              targetColor = new THREE.Color(0xffdd00);
            }
            // Add traveling pulse effect
            const travelPulse = Math.sin(dt * 5 - i * 0.8) * 0.15;
            targetOpacity += travelPulse;
          } else if (eitherActive) {
            // One endpoint active - moderate glow
            targetOpacity = 0.35 + basePulse * 0.5;
            const activeDistrict = fromActive ? conn.from.district : conn.to.district;
            targetColor = DISTRICTS[activeDistrict]?.color || new THREE.Color(0x00ffff);
          }
        }
        
        // Smooth transition
        const currentOpacity = conn.line.material.opacity;
        conn.line.material.opacity += (targetOpacity - currentOpacity) * 0.08;
        conn.line.material.color.lerp(targetColor, 0.05);
        
        // Night boost
        conn.line.material.opacity *= (1 + city.nightIntensity * 0.5);
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BUILDING-SPECIFIC ACTIVATION SYSTEM (fMRI-like individual building glow)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const buildingActivation = {
      activeBuildings: new Map(),  // buildingId -> { aura, intensity, startTime }
      auraPool: [],                // Reusable aura meshes
      maxAuras: 30,
    };
    
    /**
     * Activate a specific building with a glowing aura
     * @param {string} buildingIdOrLabel - Building ID or label to match
     * @param {object} options - { duration, color, intensity }
     */
    function activateBuilding(buildingIdOrLabel, options = {}) {
      const {
        duration = 5000,
        color = null,
        intensity = 1.0
      } = options;
      
      // Find the building
      const building = city.buildings.find(b => 
        b.label === buildingIdOrLabel || 
        (b.sources && b.sources.some(s => s.includes(buildingIdOrLabel)))
      );
      
      if (!building) {
        console.log('[BuildingActivation] Building not found:', buildingIdOrLabel);
        return false;
      }
      
      const key = building.label || `${building.x},${building.z}`;
      
      // Check if already active
      if (buildingActivation.activeBuildings.has(key)) {
        const existing = buildingActivation.activeBuildings.get(key);
        existing.intensity = Math.max(existing.intensity, intensity);
        existing.endTime = Date.now() + duration;
        return true;
      }
      
      // Create or reuse aura
      let auraGroup;
      if (buildingActivation.auraPool.length > 0) {
        auraGroup = buildingActivation.auraPool.pop();
        auraGroup.visible = true;
      } else if (buildingActivation.activeBuildings.size >= buildingActivation.maxAuras) {
        console.log('[BuildingActivation] Max auras reached');
        return false;
      } else {
        auraGroup = createBuildingAura();
      }
      
      // Position and configure aura
      const districtColor = color || DISTRICTS[building.district]?.color || new THREE.Color(0x00ffff);
      auraGroup.position.set(building.x, 0, building.z);
      
      // Scale to building size
      const auraScale = Math.max(building.width, building.depth) * 1.5;
      auraGroup.scale.set(auraScale, building.height * 1.2, auraScale);
      
      // Set color
      auraGroup.children.forEach(child => {
        if (child.material) {
          child.material.color.copy(districtColor);
        }
      });
      
      buildingActivation.activeBuildings.set(key, {
        building,
        auraGroup,
        intensity,
        startTime: Date.now(),
        endTime: Date.now() + duration,
        districtColor
      });
      
      console.log('[BuildingActivation] Activated:', building.label, 'in', building.district);
      return true;
    }
    
    /**
     * Create a reusable building aura mesh
     */
    function createBuildingAura() {
      const group = new THREE.Group();
      
      // Outer glow cylinder (soft edge)
      const outerGeo = new THREE.CylinderGeometry(1, 1, 1, 16, 1, true);
      const outerMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const outer = new THREE.Mesh(outerGeo, outerMat);
      outer.userData.isOuter = true;
      group.add(outer);
      
      // Inner glow (brighter core)
      const innerGeo = new THREE.CylinderGeometry(0.6, 0.6, 1, 16, 1, true);
      const innerMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const inner = new THREE.Mesh(innerGeo, innerMat);
      inner.userData.isInner = true;
      group.add(inner);
      
      // Ground ring
      const ringGeo = new THREE.RingGeometry(0.8, 1.2, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = 0.1;
      ring.userData.isRing = true;
      group.add(ring);
      
      scene.add(group);
      return group;
    }
    
    /**
     * Update building activations (called every frame)
     */
    function updateBuildingActivations(dt) {
      const now = Date.now();
      const mode = activityState.mode;
      
      buildingActivation.activeBuildings.forEach((data, key) => {
        const { building, auraGroup, intensity, startTime, endTime, districtColor } = data;
        
        // Check if expired
        if (now > endTime) {
          // Fade out
          data.fadingOut = true;
        }
        
        // Calculate opacity
        let targetOpacity = intensity * 0.4;
        
        if (data.fadingOut) {
          targetOpacity = 0;
        }
        
        // Pulse effect
        const elapsed = (now - startTime) / 1000;
        const pulse = 1 + Math.sin(elapsed * 4) * 0.2;
        
        // Update aura children
        auraGroup.children.forEach(child => {
          if (child.userData.isOuter) {
            const currentOpacity = child.material.opacity;
            child.material.opacity += (targetOpacity * 0.5 * pulse - currentOpacity) * 0.1;
          } else if (child.userData.isInner) {
            const currentOpacity = child.material.opacity;
            child.material.opacity += (targetOpacity * 0.8 * pulse - currentOpacity) * 0.1;
          } else if (child.userData.isRing) {
            const currentOpacity = child.material.opacity;
            child.material.opacity += (targetOpacity * pulse - currentOpacity) * 0.1;
            // Pulse ring scale
            const ringPulse = 1 + Math.sin(elapsed * 3) * 0.15;
            child.scale.set(ringPulse, ringPulse, 1);
          }
          
          // Color shift based on mode
          if (mode === 'thinking') {
            child.material.color.lerp(new THREE.Color(0x00aaff), 0.02);
          } else if (mode === 'responding') {
            child.material.color.lerp(new THREE.Color(0xffdd00), 0.02);
          } else {
            child.material.color.lerp(districtColor, 0.02);
          }
        });
        
        // Remove if fully faded
        if (data.fadingOut && auraGroup.children[0].material.opacity < 0.01) {
          auraGroup.visible = false;
          buildingActivation.auraPool.push(auraGroup);
          buildingActivation.activeBuildings.delete(key);
        }
        
        // Also boost the actual building's emissive
        if (building.mesh && building.mesh.material) {
          const boost = intensity * pulse * 0.5;
          building.mesh.material.emissiveIntensity = Math.min(2, 
            building.mesh.material.emissiveIntensity + boost * 0.05);
        }
      });
    }
    
    /**
     * Activate buildings by topic (matches keywords in label/sources)
     * @param {string} topic - Topic to match
     */
    function activateBuildingsByTopic(topic, options = {}) {
      const lowerTopic = topic.toLowerCase();
      let activated = 0;
      
      city.buildings.forEach(building => {
        const labelMatch = building.label?.toLowerCase().includes(lowerTopic);
        const sourceMatch = building.sources?.some(s => s.toLowerCase().includes(lowerTopic));
        
        if (labelMatch || sourceMatch) {
          if (activateBuilding(building.label, options)) {
            activated++;
          }
        }
      });
      
      console.log('[BuildingActivation] Activated', activated, 'buildings for topic:', topic);
      return activated;
    }
    
    /**
     * Activate all buildings in a district with staggered timing
     */
    function activateDistrictBuildings(districtKey, options = {}) {
      const { stagger = 100, duration = 3000, intensity = 0.8 } = options;
      const districtBuildings = city.districts.get(districtKey) || [];
      
      districtBuildings.forEach((building, i) => {
        setTimeout(() => {
          activateBuilding(building.label, { duration, intensity });
        }, i * stagger);
      });
      
      console.log('[BuildingActivation] Activating', districtBuildings.length, 'buildings in', districtKey);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ACTIVITY RIPPLE EFFECTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createActivityRipple(districtKey) {
      const district = DISTRICTS[districtKey];
      if (!district) return;
      
      // Limit maximum concurrent ripples to prevent memory issues
      if (activityState.ripples.length > 15) return;
      
      const rippleCount = 3;
      for (let i = 0; i < rippleCount; i++) {
        setTimeout(() => {
          // Create ring with fixed geometry - animate via scale
          const rippleGeo = new THREE.RingGeometry(0.8, 1, 32);
          const rippleMat = new THREE.MeshBasicMaterial({
            color: district.color.clone(),
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
          });
          const ripple = new THREE.Mesh(rippleGeo, rippleMat);
          ripple.rotation.x = -Math.PI / 2;
          ripple.position.set(district.position.x, 0.2, district.position.z);
          ripple.scale.set(0.5, 0.5, 1); // Start small
          
          ripple.userData = {
            startTime: performance.now(),
            duration: 2000,
            maxScale: 25,
            districtColor: district.color.clone()
          };
          
          scene.add(ripple);
          activityState.ripples.push(ripple);
        }, i * 300);
      }
    }
    
    function updateActivityRipples() {
      const now = performance.now();
      
      for (let i = activityState.ripples.length - 1; i >= 0; i--) {
        const ripple = activityState.ripples[i];
        const elapsed = now - ripple.userData.startTime;
        const progress = elapsed / ripple.userData.duration;
        
        if (progress >= 1) {
          scene.remove(ripple);
          ripple.geometry.dispose();
          ripple.material.dispose();
          activityState.ripples.splice(i, 1);
          continue;
        }
        
        // Expand ring using scale (no geometry recreation)
        const scale = ripple.userData.maxScale * progress;
        
        // Add pulse effect
        const pulse = 1 + Math.sin(elapsed * 0.01) * 0.1;
        ripple.scale.set(scale * pulse, scale * pulse, 1);
        
        // Fade out with eased curve
        ripple.material.opacity = 0.8 * (1 - progress * progress);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA PACKETS ON CONNECTION LINES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createDataPacket(fromBuilding, toBuilding, color) {
      // Limit max data packets to prevent memory issues
      if (activityState.dataPackets.length > 50) return;
      
      const packetGeo = new THREE.SphereGeometry(0.15, 6, 6);
      const packetMat = new THREE.MeshBasicMaterial({
        color: color || 0x00ffff,
        transparent: true,
        opacity: 0.9
      });
      const packet = new THREE.Mesh(packetGeo, packetMat);
      
      // Glow layer
      const glowGeo = new THREE.SphereGeometry(0.3, 6, 6);
      const glowMat = new THREE.MeshBasicMaterial({
        color: color || 0x00ffff,
        transparent: true,
        opacity: 0.4
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      packet.add(glow);
      
      packet.userData = {
        fromPos: new THREE.Vector3(fromBuilding.x, 1, fromBuilding.z),
        toPos: new THREE.Vector3(toBuilding.x, 1, toBuilding.z),
        progress: 0,
        speed: 0.5 + Math.random() * 0.3,
        startTime: performance.now()
      };
      
      // Calculate control point for curve
      const midX = (fromBuilding.x + toBuilding.x) / 2;
      const midZ = (fromBuilding.z + toBuilding.z) / 2;
      packet.userData.controlPoint = new THREE.Vector3(midX, 4 + Math.random() * 3, midZ);
      
      scene.add(packet);
      activityState.dataPackets.push(packet);
    }
    
    function spawnDataPacketsToDistrict(targetDistrict) {
      // Send packets from other districts toward the active one
      const targetPos = DISTRICTS[targetDistrict]?.position;
      if (!targetPos) return;
      
      city.connections.forEach(conn => {
        const fromDistrict = conn.from.district;
        const toDistrict = conn.to.district;
        
        // If connection involves target district, send packets toward it
        if (toDistrict === targetDistrict || fromDistrict === targetDistrict) {
          const color = DISTRICTS[targetDistrict].color.clone();
          
          // Direction toward target
          if (toDistrict === targetDistrict) {
            createDataPacket(conn.from, conn.to, color);
          } else {
            createDataPacket(conn.to, conn.from, color);
          }
        }
      });
    }
    
    function updateDataPackets(dt) {
      for (let i = activityState.dataPackets.length - 1; i >= 0; i--) {
        const packet = activityState.dataPackets[i];
        packet.userData.progress += 0.015 * packet.userData.speed;
        
        if (packet.userData.progress >= 1) {
          scene.remove(packet);
          packet.geometry.dispose();
          packet.material.dispose();
          activityState.dataPackets.splice(i, 1);
          continue;
        }
        
        // Quadratic bezier interpolation
        const t = packet.userData.progress;
        const t1 = 1 - t;
        const fromPos = packet.userData.fromPos;
        const toPos = packet.userData.toPos;
        const ctrlPos = packet.userData.controlPoint;
        
        packet.position.x = t1 * t1 * fromPos.x + 2 * t1 * t * ctrlPos.x + t * t * toPos.x;
        packet.position.y = t1 * t1 * fromPos.y + 2 * t1 * t * ctrlPos.y + t * t * toPos.y;
        packet.position.z = t1 * t1 * fromPos.z + 2 * t1 * t * ctrlPos.z + t * t * toPos.z;
        
        // Pulse effect
        const pulse = 1 + Math.sin(dt * 10 + i) * 0.2;
        packet.scale.setScalar(pulse);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DISTRICT GLOW SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateDistrictGlows(dt) {
      const now = Date.now();
      const mode = activityState.mode;
      const isPrimary = (key) => key === activityState.activeDistrict;
      
      Object.entries(activityState.districtActivity).forEach(([key, activity]) => {
        // Smooth intensity transitions - FASTER when activating, slower when deactivating
        const diff = activity.targetIntensity - activity.intensity;
        const transitionSpeed = diff > 0 ? 0.1 : 0.03; // Fast on, slow off
        activity.intensity += diff * transitionSpeed;
        
        // Decay heat level over time (warmth map)
        const timeSinceActive = (now - activity.lastActive) / 1000;
        if (timeSinceActive > 5) {
          activity.heatLevel = Math.max(0, activity.heatLevel - 0.001);
        }
        
        // Calculate effective glow with MODE-BASED BOOST
        const baseGlow = mode === 'idle' ? 0.2 : 0.3;
        const activityGlow = activity.intensity * (mode === 'idle' ? 0.5 : 1.0);
        const heatGlow = activity.heatLevel * 0.3;
        let effectiveGlow = baseGlow + activityGlow + heatGlow;
        
        // PRIMARY DISTRICT gets extra dramatic boost
        if (isPrimary(key) && mode !== 'idle') {
          effectiveGlow *= 1.5;
        }
        
        // Update buildings in this district
        const districtBuildings = city.districts.get(key) || [];
        districtBuildings.forEach((building, idx) => {
          if (!building.mesh.material) return;
          
          const districtData = DISTRICTS[key];
          
          // ENHANCED PULSING - More dramatic when active
          let pulseMultiplier = 1;
          if (activity.intensity > 0.4) {
            const pulseSpeed = mode === 'idle' ? 1.5 : (3 + activity.intensity * 3);
            const pulseAmplitude = mode === 'idle' ? 0.08 : (0.2 + activity.intensity * 0.15);
            pulseMultiplier = 1 + Math.sin(dt * pulseSpeed + activity.pulsePhase + idx * 0.3) * pulseAmplitude;
            
            // Staggered ripple effect through buildings when highly active
            if (activity.intensity > 0.7) {
              const rippleDelay = idx * 0.15;
              const ripple = Math.sin(dt * 6 - rippleDelay) * 0.1;
              pulseMultiplier += Math.max(0, ripple);
            }
          }
          
          // Apply emissive intensity with night boost
          const nightBoost = 1 + city.nightIntensity * 0.7;
          building.mesh.material.emissiveIntensity = effectiveGlow * pulseMultiplier * nightBoost;
          
          // COLOR SHIFT based on cognitive mode
          let targetEmissive = districtData.emissive.clone();
          if (mode === 'thinking' && activity.intensity > 0.5) {
            // Shift toward blue when thinking
            targetEmissive.lerp(new THREE.Color(0x002266), 0.3 * activity.intensity);
          } else if (mode === 'responding' && activity.intensity > 0.5) {
            // Shift toward gold when responding
            targetEmissive.lerp(new THREE.Color(0x443300), 0.3 * activity.intensity);
          }
          
          // Color saturation boost when highly active
          if (activity.intensity > 0.6) {
            const satBoost = (activity.intensity - 0.6) * 2.5;
            targetEmissive.multiplyScalar(1 + satBoost);
          }
          building.mesh.material.emissive.lerp(targetEmissive, 0.05);
          
          // WINDOW ACTIVATION - More windows light up when district is active
          building.mesh.children.forEach((child, childIdx) => {
            if (child.material && child.material.opacity !== undefined) {
              if (!child.userData.hologram && !child.userData.blink) {
                // Base window brightness
                let windowBrightness = 0.3;
                
                if (activity.intensity > 0.4) {
                  // Windows progressively light up based on activity
                  const activationThreshold = childIdx / building.mesh.children.length;
                  if (activity.intensity > activationThreshold) {
                    windowBrightness = 0.6 + activity.intensity * 0.4;
                    
                    // Individual window flicker
                    const flicker = Math.sin(dt * (5 + childIdx % 3) + childIdx) * 0.1;
                    windowBrightness += flicker;
                  }
                }
                
                // Pulse windows with building
                windowBrightness *= pulseMultiplier;
                
                // Mode-based window color tint
                if (child.material.color && mode !== 'idle' && activity.intensity > 0.5) {
                  const tintStrength = activity.intensity * 0.3;
                  if (mode === 'thinking') {
                    child.material.color.lerp(new THREE.Color(0x88ccff), tintStrength * 0.1);
                  } else if (mode === 'responding') {
                    child.material.color.lerp(new THREE.Color(0xffffaa), tintStrength * 0.1);
                  }
                }
                
                child.material.opacity = Math.min(1, windowBrightness);
              }
            }
          });
        });
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CORE SPIRE ACTIVITY RESPONSE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateCoreActivity(dt) {
      const mode = activityState.mode;
      const modeColor = activityState.modeColors[mode] || activityState.modeColors.idle;
      
      // Target states based on mode
      let targetPulseRate, targetEnergyDirection;
      
      switch (mode) {
        case 'thinking':
          targetPulseRate = 2.5;       // Faster pulse
          targetEnergyDirection = -1;  // Energy gathering inward
          break;
        case 'responding':
          targetPulseRate = 1.5;
          targetEnergyDirection = 1;   // Energy radiating outward
          break;
        default: // idle
          targetPulseRate = 1.0;
          targetEnergyDirection = 0;   // Neutral breathing
      }
      
      // Smooth transitions
      activityState.corePulseRate += (targetPulseRate - activityState.corePulseRate) * 0.02;
      activityState.coreEnergyDirection += (targetEnergyDirection - activityState.coreEnergyDirection) * 0.03;
      
      // Update core glow
      if (city.coreGlow) {
        const basePulse = 1 + Math.sin(dt * 2 * activityState.corePulseRate) * 0.3;
        const modeBoost = mode !== 'idle' ? 0.3 : 0;
        
        city.coreGlow.scale.setScalar(basePulse * (1 + modeBoost));
        city.coreGlow.material.opacity = 0.5 + modeBoost + Math.sin(dt * 3 * activityState.corePulseRate) * 0.2;
        
        // Color based on mode
        const targetColor = new THREE.Color(modeColor.primary);
        city.coreGlow.material.color.lerp(targetColor, 0.05);
      }
      
      // Update core rings
      city.coreRings.forEach((ring, i) => {
        if (ring.userData.rotationAxis) {
          // Rotation rings spin faster when active
          const speedMult = activityState.corePulseRate;
          if (ring.userData.rotationAxis === 'z') {
            ring.rotation.z += ring.userData.rotationSpeed * 0.01 * speedMult;
          } else if (ring.userData.rotationAxis === 'y') {
            ring.rotation.y += ring.userData.rotationSpeed * 0.01 * speedMult;
          }
          
          // Opacity based on activity
          const baseOpacity = 0.4 + (mode !== 'idle' ? 0.3 : 0);
          ring.material.opacity = baseOpacity + city.nightIntensity * 0.2;
          
          // Color shift
          ring.material.color.lerp(new THREE.Color(modeColor.primary), 0.03);
        }
        
        // Energy beams respond to direction
        if (ring.userData.beamPhase !== undefined) {
          const beamSpeed = 2 * activityState.corePulseRate;
          const directionOffset = activityState.coreEnergyDirection * dt * 2;
          const beamPulse = Math.sin(dt * beamSpeed + ring.userData.beamPhase + directionOffset) * 0.2;
          
          ring.material.opacity = 0.2 + beamPulse + (mode !== 'idle' ? 0.2 : 0);
          ring.material.color.lerp(new THREE.Color(modeColor.primary), 0.03);
          
          // Scale beams based on energy direction
          const scaleY = 1 + activityState.coreEnergyDirection * 0.3;
          ring.scale.y = scaleY;
        }
        
        // Floor pulse rings
        if (ring.userData.pulseRing) {
          const pulseSpeed = 1.5 * activityState.corePulseRate;
          const scale = 1 + Math.sin(dt * pulseSpeed + ring.userData.pulsePhase) * 0.15;
          
          // Expand outward when responding, contract when thinking
          const directionScale = 1 + activityState.coreEnergyDirection * 0.1 * Math.sin(dt * 2);
          ring.scale.set(scale * directionScale, scale * directionScale, 1);
          
          ring.material.opacity = 0.25 + (mode !== 'idle' ? 0.15 : 0);
          ring.material.color.lerp(new THREE.Color(modeColor.primary), 0.03);
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION LINE ACTIVITY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateConnectionActivity(dt) {
      const activeDistrict = activityState.activeDistrict;
      const mode = activityState.mode;
      
      city.connections.forEach((conn, i) => {
        const involvesActive = activeDistrict && 
          (conn.from.district === activeDistrict || conn.to.district === activeDistrict);
        
        // Base pulse
        const baseSpeed = 2 + (i % 3) * 0.3;
        let basePulse = Math.sin(dt * baseSpeed + i * 0.5) * 0.1 + 0.2;
        
        if (involvesActive && mode !== 'idle') {
          // Bright active connection
          basePulse += 0.4;
          
          // Color matches active district
          const districtColor = DISTRICTS[activeDistrict]?.color || new THREE.Color(0x00ffff);
          conn.line.material.color.lerp(districtColor, 0.1);
        } else {
          // Return to default cyan
          conn.line.material.color.lerp(new THREE.Color(0x00ffff), 0.02);
        }
        
        const nightBoost = 1 + city.nightIntensity * 0.8;
        conn.line.material.opacity = basePulse * nightBoost;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AGENT VISUALIZATION SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const agentSystem = {
      agents: new Map(),           // sessionId -> agent object
      maxAgents: 20,               // Performance limit
      minDisplayTime: 3000,        // Minimum ms to show agent (even if task completes faster)
      
      // Visual configuration
      config: {
        mainAgent: {
          coreRadius: 1.5,         // Bigger for visibility
          eyeRadius: 0.5,
          color: 0x00ffff,         // Cyan for main
          trailLength: 40,
          glowIntensity: 1.2
        },
        subAgent: {
          coreRadius: 0.8,
          eyeRadius: 0.3,
          color: 0xff00ff,         // Magenta for sub-agents
          trailLength: 25,
          glowIntensity: 1.0
        },
        planner: {
          coreRadius: 2.0,         // Larger, more prominent
          eyeRadius: 0.6,
          color: 0xffd700,         // Golden - the guardian
          trailLength: 60,
          glowIntensity: 1.5
        }
      }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CITY PLANNER - Permanent guardian that patrols and optimizes memory
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const cityPlanner = {
      entity: null,                // The visual entity
      active: false,
      
      // Patrol state
      currentDistrict: 0,          // Index into DISTRICT_KEYS
      targetBuilding: null,        // Building being examined
      patrolProgress: 0,           // 0-1 progress to next waypoint
      scanProgress: 0,             // 0-1 when scanning a building
      isScanning: false,
      lastScanTime: 0,
      
      // Patrol config
      patrolSpeed: 0.002,          // How fast it moves between waypoints
      scanDuration: 3000,          // ms to scan each building
      scanInterval: 8000,          // ms between scans
      patrolHeight: 30,            // Altitude
      
      // Visual elements (created on init)
      scanBeam: null,              // Beam projected during scanning
      scanRing: null,              // Ring around scanned building
    };
    
    /**
     * Initialize the City Planner - call after city loads
     */
    function initCityPlanner() {
      if (cityPlanner.active) return;
      
      console.log('[Planner] Initializing City Planner...');
      
      const config = agentSystem.config.planner;
      const baseColor = new THREE.Color(config.color);
      
      // Start above Core district
      const startPos = new THREE.Vector3(
        DISTRICTS.core.position.x,
        cityPlanner.patrolHeight,
        DISTRICTS.core.position.z
      );
      
      const group = new THREE.Group();
      group.position.copy(startPos);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PLANNER VISUAL: Golden ethereal figure with halo rings
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const scale = config.coreRadius * 1.5;
      
      // Core: Glowing golden octahedron (diamond shape)
      const coreGeo = new THREE.OctahedronGeometry(config.coreRadius, 0);
      const coreMat = new THREE.MeshBasicMaterial({
        color: baseColor,
        transparent: true,
        opacity: 0.8
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      group.add(core);
      
      // Outer glow
      const glowGeo = new THREE.OctahedronGeometry(config.coreRadius * 1.5, 0);
      const glowMat = new THREE.MeshBasicMaterial({
        color: baseColor,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);
      
      // Orbiting halo rings (3 rings at different angles)
      const rings = [];
      for (let i = 0; i < 3; i++) {
        const ringGeo = new THREE.TorusGeometry(config.coreRadius * 2, 0.08, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({
          color: i === 0 ? 0xffffff : baseColor,
          transparent: true,
          opacity: 0.5
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2 + (i * Math.PI / 6);
        ring.rotation.z = i * Math.PI / 4;
        ring.userData = { orbitSpeed: 0.5 + i * 0.3, orbitAxis: i };
        rings.push(ring);
        group.add(ring);
      }
      
      // Central eye (all-seeing)
      const eyeGeo = new THREE.SphereGeometry(config.eyeRadius, 16, 16);
      const eyeMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1
      });
      const eye = new THREE.Mesh(eyeGeo, eyeMat);
      group.add(eye);
      
      // Trail
      const trailPositions = new Float32Array(config.trailLength * 3);
      const trailColors = new Float32Array(config.trailLength * 3);
      for (let i = 0; i < config.trailLength; i++) {
        trailPositions[i * 3] = startPos.x;
        trailPositions[i * 3 + 1] = startPos.y;
        trailPositions[i * 3 + 2] = startPos.z;
        const fade = 1 - i / config.trailLength;
        trailColors[i * 3] = baseColor.r * fade;
        trailColors[i * 3 + 1] = baseColor.g * fade;
        trailColors[i * 3 + 2] = baseColor.b * fade;
      }
      
      const trailGeo = new THREE.BufferGeometry();
      trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
      
      const trailMat = new THREE.PointsMaterial({
        size: 0.4,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
      });
      const trail = new THREE.Points(trailGeo, trailMat);
      scene.add(trail);
      
      // Scan beam (initially hidden)
      const beamGeo = new THREE.CylinderGeometry(0.1, 1.5, 30, 8);
      const beamMat = new THREE.MeshBasicMaterial({
        color: baseColor,
        transparent: true,
        opacity: 0
      });
      const scanBeam = new THREE.Mesh(beamGeo, beamMat);
      scanBeam.rotation.x = Math.PI; // Point downward
      group.add(scanBeam);
      
      scene.add(group);
      
      // Store references
      cityPlanner.entity = {
        group,
        core,
        glow,
        rings,
        eye,
        trail,
        scanBeam,
        baseColor
      };
      
      cityPlanner.active = true;
      console.log('[Planner] City Planner activated - patrolling districts');
    }
    
    /**
     * Update City Planner patrol and scanning
     */
    function updateCityPlanner(dt) {
      if (!cityPlanner.active || !cityPlanner.entity) return;
      
      const { group, core, glow, rings, eye, trail, scanBeam, baseColor } = cityPlanner.entity;
      const now = Date.now();
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PATROL MOVEMENT - Drift between district centers
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      if (!cityPlanner.isScanning) {
        cityPlanner.patrolProgress += cityPlanner.patrolSpeed;
        
        if (cityPlanner.patrolProgress >= 1) {
          // Arrived at district - maybe scan a building
          cityPlanner.patrolProgress = 0;
          cityPlanner.currentDistrict = (cityPlanner.currentDistrict + 1) % DISTRICT_KEYS.length;
          
          // Chance to scan a random building in this district
          if (now - cityPlanner.lastScanTime > cityPlanner.scanInterval) {
            const districtKey = DISTRICT_KEYS[cityPlanner.currentDistrict];
            const districtBuildings = city.districts.get(districtKey) || [];
            if (districtBuildings.length > 0) {
              cityPlanner.targetBuilding = districtBuildings[Math.floor(Math.random() * districtBuildings.length)];
              cityPlanner.isScanning = true;
              cityPlanner.scanProgress = 0;
              cityPlanner.lastScanTime = now;
              
              const building = cityPlanner.targetBuilding;
              console.log('[Planner] Scanning building:', building.label || 'unknown');
              
              // Report scan to Knowledge Engine
              fetch(`${API_URL}/planner/scan`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  buildingId: building.id || 'unknown',
                  district: building.district || districtKey,
                  label: building.label || 'unnamed'
                })
              }).then(r => r.json()).then(data => {
                if (data.finding) {
                  console.log('[Planner] Finding:', data.finding.message);
                  showPlannerFinding(data.finding);
                }
              }).catch(e => console.warn('[Planner] Scan report failed:', e.message));
            }
          }
          
          // Track patrol cycles - trigger optimization after visiting all districts
          if (cityPlanner.currentDistrict === 0 && cityPlanner.patrolProgress < 0.01) {
            if (!cityPlanner.patrolCycleReported) {
              cityPlanner.patrolCycleReported = true;
              cityPlanner.patrolCycles = (cityPlanner.patrolCycles || 0) + 1;
              
              console.log('[Planner] Patrol cycle', cityPlanner.patrolCycles, 'complete - running optimization');
              
              // Trigger optimization on Knowledge Engine
              fetch(`${API_URL}/planner/patrol-complete`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ cycle: cityPlanner.patrolCycles })
              }).then(r => r.json()).then(data => {
                console.log('[Planner] Optimization result:', data.result?.actions?.length || 0, 'actions');
                if (data.result?.actions) {
                  data.result.actions.forEach(a => {
                    if (a.type === 'warning') showPlannerFinding({ type: 'warning', message: a.message });
                  });
                }
              }).catch(e => console.warn('[Planner] Optimization failed:', e.message));
            }
          } else {
            cityPlanner.patrolCycleReported = false;
          }
        }
        
        // Interpolate position between current and next district
        const currentKey = DISTRICT_KEYS[cityPlanner.currentDistrict];
        const nextKey = DISTRICT_KEYS[(cityPlanner.currentDistrict + 1) % DISTRICT_KEYS.length];
        const currentDist = DISTRICTS[currentKey];
        const nextDist = DISTRICTS[nextKey];
        
        // Smooth easing
        const t = cityPlanner.patrolProgress;
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        
        group.position.x = currentDist.position.x + (nextDist.position.x - currentDist.position.x) * eased;
        group.position.z = currentDist.position.z + (nextDist.position.z - currentDist.position.z) * eased;
        group.position.y = cityPlanner.patrolHeight + Math.sin(dt * 0.5) * 2; // Gentle bob
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SCANNING BEHAVIOR - Examine a building
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      if (cityPlanner.isScanning && cityPlanner.targetBuilding) {
        cityPlanner.scanProgress += 1000 / 60 / cityPlanner.scanDuration; // ~60fps
        
        // Move toward building
        const targetPos = cityPlanner.targetBuilding.mesh.position;
        group.position.x += (targetPos.x - group.position.x) * 0.02;
        group.position.z += (targetPos.z - group.position.z) * 0.02;
        group.position.y = cityPlanner.patrolHeight * 0.7; // Lower when scanning
        
        // Show scan beam
        scanBeam.material.opacity = 0.4 * Math.sin(cityPlanner.scanProgress * Math.PI);
        scanBeam.position.y = -15;
        
        // Pulse the target building
        if (cityPlanner.targetBuilding.mesh.material) {
          const pulse = 1 + Math.sin(dt * 8) * 0.3;
          cityPlanner.targetBuilding.mesh.material.emissiveIntensity = pulse;
        }
        
        if (cityPlanner.scanProgress >= 1) {
          // Scan complete
          cityPlanner.isScanning = false;
          cityPlanner.targetBuilding = null;
          scanBeam.material.opacity = 0;
          console.log('[Planner] Scan complete');
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // VISUAL ANIMATION - Always running
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Core rotation
      core.rotation.y += 0.01;
      core.rotation.x = Math.sin(dt * 0.3) * 0.2;
      
      // Glow pulse
      const glowPulse = 1 + Math.sin(dt * 2) * 0.2;
      glow.scale.setScalar(glowPulse);
      
      // Orbiting rings
      rings.forEach((ring, i) => {
        ring.rotation.z += ring.userData.orbitSpeed * 0.01;
        ring.rotation.y += ring.userData.orbitSpeed * 0.005;
      });
      
      // Eye looks around
      eye.rotation.y = Math.sin(dt * 0.5) * 0.5;
      eye.rotation.x = Math.cos(dt * 0.3) * 0.3;
      
      // Brightness boost when scanning
      const scanBoost = cityPlanner.isScanning ? 0.3 : 0;
      core.material.opacity = 0.8 + scanBoost;
      eye.material.opacity = 1;
      
      // Update trail
      const positions = trail.geometry.attributes.position.array;
      for (let i = positions.length - 3; i >= 3; i -= 3) {
        positions[i] = positions[i - 3];
        positions[i + 1] = positions[i - 2];
        positions[i + 2] = positions[i - 1];
      }
      positions[0] = group.position.x;
      positions[1] = group.position.y;
      positions[2] = group.position.z;
      trail.geometry.attributes.position.needsUpdate = true;
    }
    
    /**
     * Display a Planner finding as floating text/effect
     */
    function showPlannerFinding(finding) {
      // Create floating notification in 3D space near the planner
      if (!cityPlanner.entity) return;
      
      const colors = {
        stale: 0xff6600,      // Orange
        warning: 0xffaa00,    // Yellow  
        actionable: 0x00aaff, // Blue
        cleanup: 0xff00aa,    // Pink
        info: 0x00ff88        // Green
      };
      
      const color = colors[finding.type] || 0xffffff;
      const pos = cityPlanner.entity.group.position.clone();
      
      // Create pulsing ring at planner position
      const ringGeo = new THREE.RingGeometry(2, 3, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.copy(pos);
      ring.userData = { startTime: Date.now(), duration: 2000 };
      scene.add(ring);
      
      // Animate and remove
      function animateRing() {
        const elapsed = Date.now() - ring.userData.startTime;
        const progress = elapsed / ring.userData.duration;
        
        if (progress >= 1) {
          scene.remove(ring);
          ring.geometry.dispose();
          ring.material.dispose();
          return;
        }
        
        ring.scale.setScalar(1 + progress * 3);
        ring.material.opacity = 0.8 * (1 - progress);
        ring.position.y += 0.05;
        requestAnimationFrame(animateRing);
      }
      animateRing();
      
      // Also show in HUD/console
      console.log(`[Planner Finding] ${finding.type.toUpperCase()}: ${finding.message}`);
    }
    
    /**
     * Create a new agent entity in the city
     */
    function createAgent(sessionId, options = {}) {
      if (agentSystem.agents.has(sessionId)) {
        console.log('[Agents] Agent already exists:', sessionId);
        return agentSystem.agents.get(sessionId);
      }
      
      if (agentSystem.agents.size >= agentSystem.maxAgents) {
        console.warn('[Agents] Max agents reached, skipping:', sessionId);
        return null;
      }
      
      const isMain = !options.parentId;
      const config = isMain ? agentSystem.config.mainAgent : agentSystem.config.subAgent;
      const baseColor = new THREE.Color(options.color || config.color);
      
      // Determine target district from task keywords
      const targetDistrict = options.district || classifyTaskToDistrict(options.task || '');
      const districtData = DISTRICTS[targetDistrict] || DISTRICTS.core;
      
      // Spawn position: HIGH above Core for visibility
      let spawnPos;
      if (options.parentId && agentSystem.agents.has(options.parentId)) {
        const parent = agentSystem.agents.get(options.parentId);
        spawnPos = parent.group.position.clone();
        spawnPos.y += 5; // Spawn above parent
      } else {
        spawnPos = new THREE.Vector3(
          DISTRICTS.core.position.x + (Math.random() - 0.5) * 8,
          35 + Math.random() * 10,  // HIGH spawn (35-45 units up)
          DISTRICTS.core.position.z + (Math.random() - 0.5) * 8
        );
      }
      
      // Target position: HIGH above district for visibility
      const targetPos = new THREE.Vector3(
        districtData.position.x + (Math.random() - 0.5) * 20,
        25 + Math.random() * 10,  // HIGH flight (25-35 units up)
        districtData.position.z + (Math.random() - 0.5) * 20
      );
      
      // Create agent group
      const group = new THREE.Group();
      group.position.copy(spawnPos);
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CONSTELLATION SHEPHERD - Humanoid silhouette made of floating star points
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const scale = config.coreRadius * 2; // Overall size multiplier
      
      // Define humanoid skeleton points (local coordinates)
      const skeletonPoints = [
        // Head (5 points)
        [0, 2.2, 0], [0.15, 2.1, 0.1], [-0.15, 2.1, 0.1], [0.1, 2.0, -0.1], [-0.1, 2.0, -0.1],
        // Neck/shoulders (4 points)  
        [0, 1.8, 0], [0.5, 1.6, 0], [-0.5, 1.6, 0], [0, 1.6, 0.1],
        // Torso (8 points)
        [0.3, 1.3, 0.1], [-0.3, 1.3, 0.1], [0.25, 1.0, 0], [-0.25, 1.0, 0],
        [0.2, 0.7, 0.05], [-0.2, 0.7, 0.05], [0.15, 0.5, 0], [-0.15, 0.5, 0],
        // Arms (8 points)
        [0.7, 1.4, 0], [0.9, 1.1, 0.1], [1.0, 0.8, 0], [1.1, 0.5, 0.1],
        [-0.7, 1.4, 0], [-0.9, 1.1, 0.1], [-1.0, 0.8, 0], [-1.1, 0.5, 0.1],
        // Legs (8 points)
        [0.2, 0.3, 0], [0.25, 0, 0.05], [0.3, -0.4, 0], [0.25, -0.8, 0],
        [-0.2, 0.3, 0], [-0.25, 0, 0.05], [-0.3, -0.4, 0], [-0.25, -0.8, 0],
        // Extra detail points (scattered)
        [0, 1.4, 0.15], [0.4, 1.5, -0.05], [-0.4, 1.5, -0.05], [0, 0.9, 0.1],
      ];
      
      // Create points geometry
      const starCount = skeletonPoints.length;
      const starPositions = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      const starOriginal = []; // Store original positions for drift animation
      
      for (let i = 0; i < starCount; i++) {
        const [x, y, z] = skeletonPoints[i];
        starPositions[i * 3] = x * scale;
        starPositions[i * 3 + 1] = y * scale;
        starPositions[i * 3 + 2] = z * scale;
        starOriginal.push({ x: x * scale, y: y * scale, z: z * scale });
        // Core points (head, chest) are bigger
        starSizes[i] = (i < 5 || (i >= 9 && i < 13)) ? 0.4 : 0.25;
      }
      
      const starsGeo = new THREE.BufferGeometry();
      starsGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starsGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      
      const starsMat = new THREE.PointsMaterial({
        color: baseColor,
        size: 0.5,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
      });
      const core = new THREE.Points(starsGeo, starsMat);
      core.userData.starOriginal = starOriginal;
      core.userData.isConstellation = true;
      group.add(core);
      
      // Create connecting lines between nearby points
      const linePositions = [];
      const connectionThreshold = 0.8 * scale; // Connect points within this distance
      
      for (let i = 0; i < starCount; i++) {
        for (let j = i + 1; j < starCount; j++) {
          const dx = starPositions[i * 3] - starPositions[j * 3];
          const dy = starPositions[i * 3 + 1] - starPositions[j * 3 + 1];
          const dz = starPositions[i * 3 + 2] - starPositions[j * 3 + 2];
          const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
          
          if (dist < connectionThreshold) {
            linePositions.push(
              starPositions[i * 3], starPositions[i * 3 + 1], starPositions[i * 3 + 2],
              starPositions[j * 3], starPositions[j * 3 + 1], starPositions[j * 3 + 2]
            );
          }
        }
      }
      
      const linesGeo = new THREE.BufferGeometry();
      linesGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
      
      const linesMat = new THREE.LineBasicMaterial({
        color: baseColor,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.LineSegments(linesGeo, linesMat); // Using 'glow' var for compatibility
      glow.userData.isConstellationLines = true;
      group.add(glow);
      
      // Bright "heart" star at chest center
      const heartGeo = new THREE.SphereGeometry(0.15, 8, 8);
      const heartMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1
      });
      const eye = new THREE.Mesh(heartGeo, heartMat); // Using 'eye' var for compatibility
      eye.position.set(0, 1.4 * scale, 0.1 * scale);
      group.add(eye);
      
      // Trail particles (GPU-friendly point system)
      const trailPositions = new Float32Array(config.trailLength * 3);
      const trailColors = new Float32Array(config.trailLength * 3);
      const trailSizes = new Float32Array(config.trailLength);
      
      for (let i = 0; i < config.trailLength; i++) {
        trailPositions[i * 3] = spawnPos.x;
        trailPositions[i * 3 + 1] = spawnPos.y;
        trailPositions[i * 3 + 2] = spawnPos.z;
        trailColors[i * 3] = baseColor.r;
        trailColors[i * 3 + 1] = baseColor.g;
        trailColors[i * 3 + 2] = baseColor.b;
        trailSizes[i] = config.coreRadius * 0.3 * (1 - i / config.trailLength);
      }
      
      const trailGeo = new THREE.BufferGeometry();
      trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
      trailGeo.setAttribute('size', new THREE.BufferAttribute(trailSizes, 1));
      
      const trailMat = new THREE.PointsMaterial({
        size: config.coreRadius * 0.4,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
      });
      const trail = new THREE.Points(trailGeo, trailMat);
      scene.add(trail); // Trail is in world space
      
      scene.add(group);
      
      const agent = {
        sessionId,
        isMain,
        group,
        core,
        glow,
        eye,
        trail,
        baseColor: baseColor.clone(),
        
        // State
        state: 'spawning',           // spawning, working, completing, despawning
        spawnProgress: 0,            // 0-1 for spawn animation
        
        // Movement
        position: spawnPos.clone(),
        targetPosition: targetPos.clone(),
        velocity: new THREE.Vector3(),
        
        // Task info
        task: options.task || '',
        label: options.label || sessionId,
        district: targetDistrict,
        parentId: options.parentId || null,
        
        // Timing
        createdAt: Date.now(),
        lastActivity: Date.now(),
        
        // Visual state
        pulsePhase: Math.random() * Math.PI * 2,
        rotationSpeed: 0.5 + Math.random() * 0.5,
        bobOffset: Math.random() * Math.PI * 2
      };
      
      agentSystem.agents.set(sessionId, agent);
      console.log('[Agents] Created:', sessionId, 'district:', targetDistrict, 'isMain:', isMain);
      
      // Trigger spawn effect
      createAgentSpawnEffect(agent);
      
      return agent;
    }
    
    /**
     * Spawn effect: DRAMATIC materialization animation
     */
    function createAgentSpawnEffect(agent) {
      const spawnPos = agent.position.clone();
      
      // 1. LARGE EXPANDING FLASH SPHERE
      const flashGeo = new THREE.SphereGeometry(1, 16, 16);
      const flashMat = new THREE.MeshBasicMaterial({
        color: agent.baseColor,
        transparent: true,
        opacity: 1
      });
      const flash = new THREE.Mesh(flashGeo, flashMat);
      flash.position.copy(spawnPos);
      flash.userData = { startTime: Date.now(), duration: 800 };
      scene.add(flash);
      
      function animateFlash() {
        const elapsed = Date.now() - flash.userData.startTime;
        const progress = elapsed / flash.userData.duration;
        
        if (progress >= 1) {
          scene.remove(flash);
          flash.geometry.dispose();
          flash.material.dispose();
          return;
        }
        
        // Expand dramatically
        flash.scale.setScalar(1 + progress * 8);
        flash.material.opacity = (1 - progress) * 0.8;
        requestAnimationFrame(animateFlash);
      }
      animateFlash();
      
      // 2. VERTICAL BEAM (descending from sky)
      const beamGeo = new THREE.CylinderGeometry(0.3, 0.8, 50, 8);
      const beamMat = new THREE.MeshBasicMaterial({
        color: agent.baseColor,
        transparent: true,
        opacity: 0.6
      });
      const beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.set(spawnPos.x, spawnPos.y + 25, spawnPos.z);
      beam.userData = { startTime: Date.now(), duration: 1200 };
      scene.add(beam);
      
      function animateBeam() {
        const elapsed = Date.now() - beam.userData.startTime;
        const progress = elapsed / beam.userData.duration;
        
        if (progress >= 1) {
          scene.remove(beam);
          beam.geometry.dispose();
          beam.material.dispose();
          return;
        }
        
        // Shrink from top
        const scaleY = 1 - progress;
        beam.scale.set(1 - progress * 0.5, scaleY, 1 - progress * 0.5);
        beam.position.y = spawnPos.y + 25 * scaleY;
        beam.material.opacity = 0.6 * (1 - progress);
        requestAnimationFrame(animateBeam);
      }
      animateBeam();
      
      // 3. MULTIPLE EXPANDING RINGS (ground level)
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          const ringGeo = new THREE.RingGeometry(0.5, 1.5, 32);
          const ringMat = new THREE.MeshBasicMaterial({
            color: agent.baseColor,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
          });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.rotation.x = -Math.PI / 2;
          ring.position.set(spawnPos.x, 0.3, spawnPos.z);
          ring.userData = { startTime: Date.now(), duration: 1500 };
          scene.add(ring);
          
          function animateRing() {
            const elapsed = Date.now() - ring.userData.startTime;
            const progress = elapsed / ring.userData.duration;
            
            if (progress >= 1) {
              scene.remove(ring);
              ring.geometry.dispose();
              ring.material.dispose();
              return;
            }
            
            const scale = 1 + progress * 20;
            ring.scale.set(scale, scale, 1);
            ring.material.opacity = 0.9 * (1 - progress * progress);
            requestAnimationFrame(animateRing);
          }
          animateRing();
        }, i * 200);
      }
      
      // 4. PARTICLE BURST (scattered sparks)
      const sparkCount = 20;
      for (let i = 0; i < sparkCount; i++) {
        const sparkGeo = new THREE.SphereGeometry(0.15, 4, 4);
        const sparkMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1
        });
        const spark = new THREE.Mesh(sparkGeo, sparkMat);
        spark.position.copy(spawnPos);
        
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.4,
          Math.random() * 0.3 + 0.2,
          (Math.random() - 0.5) * 0.4
        );
        
        spark.userData = { velocity, startTime: Date.now(), duration: 1000 };
        scene.add(spark);
        
        function animateSpark() {
          const elapsed = Date.now() - spark.userData.startTime;
          const progress = elapsed / spark.userData.duration;
          
          if (progress >= 1) {
            scene.remove(spark);
            spark.geometry.dispose();
            spark.material.dispose();
            return;
          }
          
          spark.position.add(velocity);
          velocity.y -= 0.01; // Gravity
          spark.material.opacity = 1 - progress;
          spark.scale.setScalar(1 - progress * 0.5);
          requestAnimationFrame(animateSpark);
        }
        animateSpark();
      }
      
      // 5. District ripples
      createActivityRipple(agent.district);
      setTimeout(() => createActivityRipple(agent.district), 300);
    }
    
    /**
     * Classify task text to a district
     */
    function classifyTaskToDistrict(task) {
      const lower = task.toLowerCase();
      
      const districtKeywords = {
        trading: ['stock', 'market', 'trade', 'price', 'ticker', 'scanner', 'options', 'portfolio'],
        infrastructure: ['server', 'deploy', 'docker', 'api', 'tunnel', 'cloudflare', 'pm2', 'cron'],
        projects: ['build', 'create', 'app', 'visualization', 'code', 'implement', 'design'],
        memory: ['memory', 'remember', 'recall', 'note', 'log', 'history', 'context']
      };
      
      for (const [district, keywords] of Object.entries(districtKeywords)) {
        if (keywords.some(kw => lower.includes(kw))) {
          return district;
        }
      }
      
      return 'core'; // Default to core
    }
    
    /**
     * Update agent activity state
     */
    function updateAgentState(sessionId, state, context = {}) {
      const agent = agentSystem.agents.get(sessionId);
      if (!agent) return;
      
      agent.lastActivity = Date.now();
      
      if (state === 'thinking' || state === 'working') {
        agent.state = 'working';
      } else if (state === 'complete' || state === 'done') {
        agent.state = 'completing';
        setTimeout(() => removeAgent(sessionId), 3000); // Remove after completion effect
      }
      
      console.log('[Agents] State update:', sessionId, state);
    }
    
    /**
     * Remove an agent with despawn animation
     * Enforces minimum display time for visibility
     */
    function removeAgent(sessionId) {
      const agent = agentSystem.agents.get(sessionId);
      if (!agent) return;
      
      // Already despawning? Skip
      if (agent.state === 'despawning') return;
      
      // Enforce minimum display time
      const timeAlive = Date.now() - agent.createdAt;
      if (timeAlive < agentSystem.minDisplayTime) {
        const remaining = agentSystem.minDisplayTime - timeAlive;
        console.log('[Agents] Delaying removal by', remaining, 'ms for visibility');
        setTimeout(() => removeAgent(sessionId), remaining);
        return;
      }
      
      agent.state = 'despawning';
      
      // Completion effect
      createAgentCompletionEffect(agent);
      
      // Cleanup after animation
      setTimeout(() => {
        if (agent.group.parent) scene.remove(agent.group);
        if (agent.trail.parent) scene.remove(agent.trail);
        
        // Dispose geometries
        agent.core.geometry.dispose();
        agent.core.material.dispose();
        agent.glow.geometry.dispose();
        agent.glow.material.dispose();
        agent.eye.geometry.dispose();
        agent.eye.material.dispose();
        agent.trail.geometry.dispose();
        agent.trail.material.dispose();
        
        agentSystem.agents.delete(sessionId);
        console.log('[Agents] Removed:', sessionId);
      }, 1500);
    }
    
    /**
     * Completion effect: DRAMATIC particle burst + golden flash + ascend beam
     */
    function createAgentCompletionEffect(agent) {
      const pos = agent.group.position.clone();
      
      // 1. GOLDEN FLASH SPHERE
      const flashGeo = new THREE.SphereGeometry(1.5, 16, 16);
      const flashMat = new THREE.MeshBasicMaterial({
        color: 0xffd700,
        transparent: true,
        opacity: 0.9
      });
      const flash = new THREE.Mesh(flashGeo, flashMat);
      flash.position.copy(pos);
      flash.userData = { startTime: Date.now(), duration: 600 };
      scene.add(flash);
      
      function animateFlash() {
        const elapsed = Date.now() - flash.userData.startTime;
        const progress = elapsed / flash.userData.duration;
        if (progress >= 1) {
          scene.remove(flash);
          flash.geometry.dispose();
          flash.material.dispose();
          return;
        }
        flash.scale.setScalar(1 + progress * 5);
        flash.material.opacity = 0.9 * (1 - progress);
        requestAnimationFrame(animateFlash);
      }
      animateFlash();
      
      // 2. ASCENDING BEAM (agent rises into light)
      const beamGeo = new THREE.CylinderGeometry(0.5, 0.2, 40, 8);
      const beamMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.5
      });
      const beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.set(pos.x, pos.y + 20, pos.z);
      beam.userData = { startTime: Date.now(), duration: 1500 };
      scene.add(beam);
      
      function animateBeam() {
        const elapsed = Date.now() - beam.userData.startTime;
        const progress = elapsed / beam.userData.duration;
        if (progress >= 1) {
          scene.remove(beam);
          beam.geometry.dispose();
          beam.material.dispose();
          return;
        }
        beam.position.y = pos.y + 20 + progress * 30;
        beam.material.opacity = 0.5 * (1 - progress);
        requestAnimationFrame(animateBeam);
      }
      animateBeam();
      
      // 3. GOLDEN PARTICLE BURST
      const burstCount = 30;
      for (let i = 0; i < burstCount; i++) {
        const particleGeo = new THREE.SphereGeometry(0.2, 4, 4);
        const particleMat = new THREE.MeshBasicMaterial({
          color: i % 3 === 0 ? 0xffffff : 0xffd700,
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(particleGeo, particleMat);
        particle.position.copy(pos);
        
        const angle = (i / burstCount) * Math.PI * 2;
        const speed = 0.2 + Math.random() * 0.3;
        const velocity = new THREE.Vector3(
          Math.cos(angle) * speed,
          Math.random() * 0.4 + 0.2,
          Math.sin(angle) * speed
        );
        
        particle.userData = { velocity, startTime: Date.now(), duration: 1200 };
        scene.add(particle);
        
        function animateParticle() {
          const elapsed = Date.now() - particle.userData.startTime;
          const progress = elapsed / particle.userData.duration;
          
          if (progress >= 1) {
            scene.remove(particle);
            particle.geometry.dispose();
            particle.material.dispose();
            return;
          }
          
          particle.position.add(velocity);
          velocity.y -= 0.008;
          particle.material.opacity = 1 - progress;
          particle.scale.setScalar(1 + progress);
          requestAnimationFrame(animateParticle);
        }
        animateParticle();
      }
      
      // 4. SUCCESS RIPPLE
      const ringGeo = new THREE.RingGeometry(1, 2, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: 0xffd700,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.set(pos.x, 0.3, pos.z);
      ring.userData = { startTime: Date.now(), duration: 1500 };
      scene.add(ring);
      
      function animateRing() {
        const elapsed = Date.now() - ring.userData.startTime;
        const progress = elapsed / ring.userData.duration;
        if (progress >= 1) {
          scene.remove(ring);
          ring.geometry.dispose();
          ring.material.dispose();
          return;
        }
        const scale = 1 + progress * 15;
        ring.scale.set(scale, scale, 1);
        ring.material.opacity = 0.8 * (1 - progress);
        requestAnimationFrame(animateRing);
      }
      animateRing();
    }
    
    /**
     * Update all agents (called in animation loop)
     */
    function updateAgents(dt) {
      agentSystem.agents.forEach(agent => {
        const timeAlive = Date.now() - agent.createdAt;
        
        // Spawn animation (first second)
        if (agent.state === 'spawning') {
          agent.spawnProgress = Math.min(1, timeAlive / 1000);
          
          // Fade in
          agent.core.material.opacity = agent.spawnProgress * 0.9;
          agent.glow.material.opacity = agent.spawnProgress * 0.3;
          agent.eye.material.opacity = agent.spawnProgress * 0.9;
          
          // Scale up
          const scale = agent.spawnProgress;
          agent.group.scale.setScalar(scale);
          
          if (agent.spawnProgress >= 1) {
            agent.state = 'working';
          }
        }
        
        // Movement toward target district
        if (agent.state === 'working' || agent.state === 'spawning') {
          const direction = agent.targetPosition.clone().sub(agent.position);
          const distance = direction.length();
          
          if (distance > 1) {
            direction.normalize();
            // Smooth acceleration
            agent.velocity.lerp(direction.multiplyScalar(0.08), 0.02);
            agent.position.add(agent.velocity);
          }
          
          // Bob up and down
          const bob = Math.sin(dt * 2 + agent.bobOffset) * 0.3;
          agent.group.position.copy(agent.position);
          agent.group.position.y += bob;
        }
        
        // Despawn animation
        if (agent.state === 'despawning') {
          agent.group.position.y += 0.05; // Rise up
          agent.core.material.opacity *= 0.95;
          agent.glow.material.opacity *= 0.95;
          agent.eye.material.opacity *= 0.95;
          agent.trail.material.opacity *= 0.95;
        }
        
        // Visual updates (always)
        
        // CONSTELLATION ANIMATION - Stars drift slightly but maintain form
        if (agent.core.userData.isConstellation) {
          const positions = agent.core.geometry.attributes.position.array;
          const original = agent.core.userData.starOriginal;
          
          for (let i = 0; i < original.length; i++) {
            // Each star drifts with unique phase
            const phase = agent.pulsePhase + i * 0.5;
            const drift = 0.08; // Drift amount
            
            positions[i * 3] = original[i].x + Math.sin(dt * 1.5 + phase) * drift;
            positions[i * 3 + 1] = original[i].y + Math.cos(dt * 1.2 + phase * 0.7) * drift;
            positions[i * 3 + 2] = original[i].z + Math.sin(dt * 0.9 + phase * 1.3) * drift;
          }
          agent.core.geometry.attributes.position.needsUpdate = true;
          
          // Gentle overall rotation
          agent.group.rotation.y += agent.rotationSpeed * 0.005;
        } else {
          // Fallback for non-constellation agents
          agent.core.rotation.y += agent.rotationSpeed * 0.01;
          agent.core.rotation.x = Math.sin(dt * 0.5) * 0.2;
        }
        
        // Heart star pulses
        const heartPulse = 1 + Math.sin(dt * 3) * 0.3;
        agent.eye.scale.setScalar(heartPulse);
        
        // Pulse effect when working - brighten everything
        if (agent.state === 'working') {
          const intensity = 0.7 + Math.sin(dt * 4 + agent.pulsePhase) * 0.3;
          agent.core.material.opacity = intensity;
          agent.glow.material.opacity = 0.2 + Math.sin(dt * 2) * 0.15;
          agent.eye.material.opacity = 1;
        }
        
        // Update trail
        const positions = agent.trail.geometry.attributes.position.array;
        // Shift all positions back
        for (let i = positions.length - 3; i >= 3; i -= 3) {
          positions[i] = positions[i - 3];
          positions[i + 1] = positions[i - 2];
          positions[i + 2] = positions[i - 1];
        }
        // Set newest position
        positions[0] = agent.group.position.x;
        positions[1] = agent.group.position.y;
        positions[2] = agent.group.position.z;
        agent.trail.geometry.attributes.position.needsUpdate = true;
      });
    }
    
    /**
     * Handle agent events from WebSocket
     */
    function handleAgentEvent(event) {
      console.log('[Agents] Event:', event.type, event);
      
      switch (event.type) {
        case 'agent:spawn':
          createAgent(event.sessionId, {
            parentId: event.parentId,
            task: event.task,
            label: event.label,
            district: event.district
          });
          break;
          
        case 'agent:work':
          updateAgentState(event.sessionId, event.state);
          break;
          
        case 'agent:complete':
          updateAgentState(event.sessionId, 'complete');
          break;
          
        case 'agent:heartbeat':
          // Sync all agent states
          if (event.agents) {
            event.agents.forEach(a => {
              if (!agentSystem.agents.has(a.sessionId)) {
                createAgent(a.sessionId, a);
              }
            });
            // Remove agents not in heartbeat
            agentSystem.agents.forEach((agent, id) => {
              if (!event.agents.find(a => a.sessionId === id)) {
                removeAgent(id);
              }
            });
          }
          break;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEBSOCKET & API
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Try HTTP first (more reliable), then WebSocket for live updates
    async function loadCityFromAPI() {
      try {
        console.log('[API] Fetching city state from:', `${API_URL}/city-state`);
        const res = await fetch(`${API_URL}/city-state`);
        console.log('[API] Response status:', res.status);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const cityState = await res.json();
        console.log('[API] Parsed JSON, buildings:', cityState.buildings?.length);
        console.log('[API] First building:', JSON.stringify(cityState.buildings?.[0]));
        if (cityState.buildings && cityState.buildings.length > 0) {
          loadCityFromState(cityState);
          return true;
        } else {
          console.error('[API] No buildings in response');
          return false;
        }
      } catch (err) {
        console.error('[API] Failed:', err.message, err);
        return false;
      }
    }
    
    function connectKnowledge() {
      cityWebSocket = new WebSocket(WS_URL);
      
      cityWebSocket.onopen = () => {
        console.log('[WS] Connected to knowledge engine');
        // Don't request city state - we already loaded via HTTP
      };
      
      cityWebSocket.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          
          // Live updates if city changes
          if (msg.type === 'city:state' && msg.city) {
            console.log('[WS] City update:', msg.city.buildings?.length, 'buildings');
            loadCityFromState(msg.city);
          }
          
          if (msg.type === 'state') {
            handleCognitiveState(msg.mode, msg.message);
            
            // Also trigger main agent visualization based on cognitive state
            if (msg.mode === 'thinking' || msg.mode === 'responding') {
              // Ensure main agent exists
              if (!agentSystem.agents.has('main')) {
                createAgent('main', { 
                  task: msg.message || 'Processing...',
                  district: activityState.activeDistrict || 'core'
                });
              } else {
                // Cancel any pending removal and restore working state
                const agent = agentSystem.agents.get('main');
                if (agent && agent.state === 'despawning') {
                  agent.state = 'working';
                  // Restore opacity
                  agent.core.material.opacity = 0.9;
                  agent.glow.material.opacity = 0.3;
                  agent.eye.material.opacity = 0.9;
                  agent.trail.material.opacity = 0.6;
                }
              }
              updateAgentState('main', 'working');
            } else if (msg.mode === 'idle') {
              // Remove main agent when idle (respects minDisplayTime)
              if (agentSystem.agents.has('main')) {
                removeAgent('main');
              }
            }
          }
          
          // Agent-specific events
          if (msg.type && msg.type.startsWith('agent:')) {
            handleAgentEvent(msg);
          }
          
          // Thought injection from API
          if (msg.type === 'thought' && msg.text) {
            console.log('[WS] Thought received:', msg.text);
            addThought(msg.text);
          }
          
          if (msg.type === 'graph:full') {
            console.log('[WS] Received knowledge graph:', msg.graph?.nodes?.length, 'nodes');
          }
          
          // Building activation commands (brain-scan effects)
          if (msg.type === 'activate:building') {
            console.log('[WS] Building activation:', msg.building);
            activateBuilding(msg.building, {
              duration: msg.duration || 5000,
              intensity: msg.intensity || 1.0
            });
          }
          
          if (msg.type === 'activate:district') {
            console.log('[WS] District activation:', msg.district);
            activateDistrictBuildings(msg.district, {
              stagger: msg.stagger || 100,
              duration: msg.duration || 4000,
              intensity: msg.intensity || 0.8
            });
            createActivityRipple(msg.district);
          }
          
          if (msg.type === 'activate:topic') {
            console.log('[WS] Topic activation:', msg.topic);
            activateBuildingsByTopic(msg.topic, {
              duration: msg.duration || 4000,
              intensity: msg.intensity || 0.7
            });
          }
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };
      
      cityWebSocket.onclose = () => {
        console.log('[WS] Disconnected, reconnecting...');
        setTimeout(connectKnowledge, 5000);
      };
      cityWebSocket.onerror = () => cityWebSocket.close();
    }
    
    /**
     * Load city buildings from server state
     */
    let isLoadingCity = false; // Prevent race conditions
    
    function loadCityFromState(cityState) {
      // Prevent concurrent loads (race condition fix)
      if (isLoadingCity) {
        console.log('[LoadCity] Already loading, skipping');
        return;
      }
      
      console.log('[LoadCity] Called with', cityState?.buildings?.length, 'buildings');
      if (!cityState.buildings || cityState.buildings.length === 0) {
        console.log('[City] No buildings in state');
        return;
      }
      
      isLoadingCity = true;
      cityLoadedFromServer = true;
      console.log('[LoadCity] Creating buildings...');
      
      // Clean up memory before removing buildings (memory leak fix)
      while (city.buildings.length > 1) {
        const b = city.buildings.pop();
        
        // Clean up windowStates for this building
        if (city.windowStates.has(b)) {
          city.windowStates.delete(b);
        }
        
        // Clean up elevators attached to this building
        if (b.mesh) {
          b.mesh.children.forEach(child => {
            if (child.userData && child.userData.isElevator) {
              const idx = city.elevators.indexOf(child);
              if (idx > -1) city.elevators.splice(idx, 1);
            }
          });
        }
        
        // Dispose geometry and materials
        if (b.mesh) {
          if (b.mesh.geometry) b.mesh.geometry.dispose();
          if (b.mesh.material) {
            if (Array.isArray(b.mesh.material)) {
              b.mesh.material.forEach(m => m.dispose());
            } else {
              b.mesh.material.dispose();
            }
          }
          scene.remove(b.mesh);
        }
      }
      
      // Clean up connections and their data streams
      city.connections.forEach(c => {
        scene.remove(c.line);
        if (c.line.geometry) c.line.geometry.dispose();
        if (c.line.material) c.line.material.dispose();
      });
      city.connections = [];
      
      // Clean up data streams
      city.dataStreams.forEach(stream => {
        scene.remove(stream);
        if (stream.geometry) stream.geometry.dispose();
        if (stream.material) stream.material.dispose();
      });
      city.dataStreams = [];
      
      // Reset districts, keep core
      city.districts.clear();
      if (city.buildings.length > 0) {
        city.districts.set('core', [city.buildings[0]]);
      }
      
      // Create buildings from state
      console.log('[LoadCity] Iterating', cityState.buildings.length, 'building specs');
      let created = 0;
      for (const spec of cityState.buildings) {
        try {
          createBuilding({
            x: spec.x,
            z: spec.z,
            width: spec.width || 2.5,
            depth: spec.depth || 2.5,
            height: spec.height,
            district: spec.district,
            label: spec.label,
            sources: spec.sources || []
          });
          created++;
        } catch (err) {
          console.error('[LoadCity] Failed to create building:', spec.label, err);
        }
      }
      console.log('[LoadCity] Created', created, 'buildings');
      
      // Create connections from state (O(n) instead of O(nÂ²))
      if (cityState.connections) {
        // Build position-based lookup map once
        const posKey = (x, z) => `${Math.round(x * 2)},${Math.round(z * 2)}`;
        const posToBuilding = new Map();
        city.buildings.forEach(b => {
          posToBuilding.set(posKey(b.x, b.z), b);
        });
        
        const idToBuilding = new Map();
        cityState.buildings.forEach((spec) => {
          const b = posToBuilding.get(posKey(spec.x, spec.z));
          if (b) idToBuilding.set(spec.id, b);
        });
        
        for (const conn of cityState.connections) {
          const fromB = idToBuilding.get(conn.from);
          const toB = idToBuilding.get(conn.to);
          if (fromB && toB) {
            createConnection(fromB, toB);
          }
        }
      }
      
      // Set district activity
      if (cityState.districtActivity) {
        districtGlowIntensities = { ...cityState.districtActivity };
      }
      
      console.log(`[City] Loaded ${city.buildings.length} buildings from knowledge`);
      updateStats();
      isLoadingCity = false;
      
      // Initialize the City Planner after city loads
      setTimeout(() => initCityPlanner(), 1000);
    }
    
    // Pre-compiled keyword regexes for performance (avoid creating in tight loop)
    const districtKeywords = {
      trading: ['stock', 'trading', 'market', 'ticker', 'price', 'portfolio', 'scan', 'asymmetry', 'options', 'calls', 'puts'],
      infrastructure: ['server', 'deploy', 'api', 'docker', 'tunnel', 'pm2', 'cloudflare', 'coolify', 'tailscale', 'ssh'],
      projects: ['project', 'build', 'app', 'visualization', 'face', 'city', 'mind', 'code', 'create', 'develop'],
      memory: ['memory', 'remember', 'decision', 'note', 'log', 'history', 'learned', 'preference'],
      core: ['self', 'absalom', 'knowledge', 'engine', 'think', 'process', 'identity', 'soul']
    };
    
    // Pre-compile regex patterns for exact word matching
    const districtKeywordRegexes = {};
    for (const [district, keywords] of Object.entries(districtKeywords)) {
      districtKeywordRegexes[district] = keywords.map(kw => ({
        keyword: kw,
        regex: new RegExp(`\\b${kw}\\b`, 'i')
      }));
    }
    
    /**
     * Handle cognitive state changes - district glow mapping with full visual feedback
     */
    function handleCognitiveState(mode, message = '') {
      const prevMode = activityState.mode;
      const prevDistrict = activityState.activeDistrict;
      
      // Update mode
      activityState.mode = mode || 'idle';
      activityState.activityStartTime = Date.now();
      
      const lower = (message || '').toLowerCase();
      let detectedDistrict = null;
      let highestScore = 0;
      
      // Score each district based on keyword matches (using pre-compiled regexes)
      for (const [district, keywordData] of Object.entries(districtKeywordRegexes)) {
        let score = 0;
        for (const { keyword, regex } of keywordData) {
          if (lower.includes(keyword)) {
            score += 1;
            // Bonus for exact word match (using pre-compiled regex)
            if (regex.test(lower)) score += 0.5;
          }
        }
        if (score > highestScore) {
          highestScore = score;
          detectedDistrict = district;
        }
      }
      
      // Default to core if thinking/responding with no clear district
      if (!detectedDistrict && (mode === 'thinking' || mode === 'responding')) {
        detectedDistrict = 'core';
      }
      
      activityState.activeDistrict = detectedDistrict;
      
      // Reset target intensities
      Object.keys(activityState.districtActivity).forEach(key => {
        activityState.districtActivity[key].targetIntensity = 0.3;
      });
      
      // Set activity levels based on mode
      if (mode === 'thinking' || mode === 'responding') {
        // Core always active when processing
        activityState.districtActivity['core'].targetIntensity = 0.8;
        activityState.districtActivity['core'].lastActive = Date.now();
        activityState.districtActivity['core'].heatLevel = Math.min(1, 
          activityState.districtActivity['core'].heatLevel + 0.1);
        
        // Primary active district gets full intensity
        if (detectedDistrict) {
          activityState.districtActivity[detectedDistrict].targetIntensity = 1.0;
          activityState.districtActivity[detectedDistrict].lastActive = Date.now();
          activityState.districtActivity[detectedDistrict].heatLevel = Math.min(1,
            activityState.districtActivity[detectedDistrict].heatLevel + 0.15);
          
          // Secondary districts get partial boost based on keyword matches
          for (const [district, keywords] of Object.entries(districtKeywords)) {
            if (district === detectedDistrict) continue;
            for (const kw of keywords) {
              if (lower.includes(kw)) {
                activityState.districtActivity[district].targetIntensity = 
                  Math.max(activityState.districtActivity[district].targetIntensity, 0.5);
                activityState.districtActivity[district].heatLevel = Math.min(1,
                  activityState.districtActivity[district].heatLevel + 0.05);
                break;
              }
            }
          }
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TRIGGER VISUAL EFFECTS ON STATE CHANGE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Ripple effect when entering active state
      if (mode !== 'idle' && (prevMode === 'idle' || detectedDistrict !== prevDistrict)) {
        if (detectedDistrict) {
          createActivityRipple(detectedDistrict);
        }
        // Always ripple from core when becoming active
        if (detectedDistrict !== 'core') {
          createActivityRipple('core');
        }
      }
      
      // Spawn data packets flowing toward active district
      if (mode !== 'idle' && detectedDistrict) {
        spawnDataPacketsToDistrict(detectedDistrict);
        
        // Periodic packet spawning during activity
        if (!activityState.packetInterval) {
          activityState.packetInterval = setInterval(() => {
            if (activityState.mode !== 'idle' && activityState.activeDistrict) {
              spawnDataPacketsToDistrict(activityState.activeDistrict);
            }
          }, 1500);
        }
      }
      
      // Clear packet interval when going idle
      if (mode === 'idle' && activityState.packetInterval) {
        clearInterval(activityState.packetInterval);
        activityState.packetInterval = null;
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BUILDING-SPECIFIC ACTIVATION (fMRI-like individual building glow)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      if (mode !== 'idle' && message) {
        // Activate district buildings with stagger effect
        if (detectedDistrict) {
          activateDistrictBuildings(detectedDistrict, {
            stagger: 80,
            duration: 4000,
            intensity: mode === 'thinking' ? 0.7 : 0.9
          });
        }
        
        // Also activate buildings matching specific keywords in the message
        const buildingKeywords = [
          'trading', 'scanner', 'portfolio', 'memory', 'decision', 'analysis',
          'execution', 'tool', 'skill', 'perception', 'growth', 'learning',
          'emotion', 'relationship', 'identity', 'core'
        ];
        
        buildingKeywords.forEach(keyword => {
          if (lower.includes(keyword)) {
            activateBuildingsByTopic(keyword, {
              duration: 3000,
              intensity: 0.6
            });
          }
        });
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SOUND INTEGRATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      soundManager.updateCognitiveState(mode, message);
      
      // Play district activation sound when district changes
      if (detectedDistrict && detectedDistrict !== prevDistrict && mode !== 'idle') {
        soundManager.playDistrictActivation(detectedDistrict);
      }
      
      // Log state change for debugging
      console.log(`[Cognitive] Mode: ${mode} | District: ${detectedDistrict || 'none'} | Message preview: "${(message || '').slice(0, 50)}..."`);
      
      // Legacy compatibility - update old districtGlowIntensities
      Object.keys(DISTRICTS).forEach(key => {
        districtGlowIntensities[key] = activityState.districtActivity[key].targetIntensity;
      });
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // UPDATE HUD INDICATOR
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const indicatorEl = document.getElementById('cognitiveIndicator');
      const modeEl = document.getElementById('cognitiveMode');
      const districtEl = document.getElementById('cognitiveDistrict');
      const dotEl = document.getElementById('activityDot');
      
      if (indicatorEl && modeEl && districtEl && dotEl) {
        // Update indicator class
        indicatorEl.className = 'cognitive-indicator ' + mode;
        
        // Update mode text and styling
        modeEl.className = 'cognitive-mode ' + mode;
        modeEl.innerHTML = `<span class="activity-dot ${mode} ${mode !== 'idle' ? 'active' : ''}" id="activityDot"></span>${mode}`;
        
        // Update district display
        if (detectedDistrict && DISTRICTS[detectedDistrict]) {
          districtEl.textContent = DISTRICTS[detectedDistrict].name;
          districtEl.style.color = '#' + DISTRICTS[detectedDistrict].color.getHexString();
        } else {
          districtEl.textContent = 'â€”';
          districtEl.style.color = 'rgba(255,255,255,0.5)';
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    createSkyDome();
    createCelestialBodies();
    createStarfield();
    createGround();
    createEnvironment();
    createGodRays(); // Volumetric light shafts
    createNeonAccentRings(); // Pulsing ground neon effects
    createLighting();
    createDistrictLabels();
    createDrones();
    createParticles();
    initThoughtBubbles();
    
    // Ambient life systems
    createTrafficLights();
    createFirefliesAndDust();
    createEnergyMotes(); // AAA holographic particles
    createAircraft();
    
    // Brain-like activation system (energy flows, district beams)
    initBrainActivationSystem();
    
    // Create core spire first (always present)
    createCoreSpire();
    city.districts.set('core', [city.buildings[0]]);
    
    // Load city from HTTP API first (reliable), then connect WebSocket for live updates
    loadCityFromAPI().then(success => {
      if (!success) {
        console.log('[City] API failed, using seed fallback');
        seedCityFallback();
      }
      // Connect WebSocket for live cognitive state updates
      connectKnowledge();
    });
    
    animate(0);
    
    console.log('Absalom City â€” A Mind Made Manifest (Knowledge-Powered Edition)');
    console.log(`Quality: ${qualityLevel} | Mobile: ${isMobile}`);
    
    /**
     * Fallback seeding when WebSocket unavailable
     */
    function seedCityFallback() {
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        if (key === 'core') return;
        const pos = district.position;
        
        createBuilding({
          x: pos.x,
          z: pos.z,
          height: 18 + Math.random() * 12,
          width: 4 + Math.random() * 2,
          depth: 4 + Math.random() * 2,
          district: key,
          label: `${district.name} Hub`,
          type: Math.random() > 0.5 ? 'tapered' : 'tower',
        });
        
        const buildingCount = isMobile ? 4 : 6;
        for (let i = 0; i < buildingCount; i++) {
          const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.5;
          const radius = 6 + Math.random() * 8;
          createBuilding({
            x: pos.x + Math.cos(angle) * radius,
            z: pos.z + Math.sin(angle) * radius,
            height: 5 + Math.random() * 15,
            district: key,
          });
        }
      });
      
      // Connect districts to core
      const districtKeys = Object.keys(DISTRICTS).filter(k => k !== 'core');
      districtKeys.forEach(key => {
        const districtBuildings = city.districts.get(key) || [];
        if (districtBuildings.length > 0) {
          createConnection(city.buildings[0], districtBuildings[0]);
        }
      });
      
      updateStats();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GLOBAL API FOR TESTING BRAIN-SCAN EFFECTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    window.AbsalomCity = {
      // Cognitive state control
      setState: (mode, message) => handleCognitiveState(mode, message),
      think: (message) => handleCognitiveState('thinking', message),
      respond: (message) => handleCognitiveState('responding', message),
      idle: () => handleCognitiveState('idle'),
      
      // Building activation (fMRI-style)
      activateBuilding,
      activateBuildingsByTopic,
      activateDistrictBuildings,
      
      // District effects
      activateDistrict: (districtKey) => {
        activityState.districtActivity[districtKey].targetIntensity = 1.0;
        activityState.districtActivity[districtKey].lastActive = Date.now();
        createActivityRipple(districtKey);
        activateDistrictBuildings(districtKey);
      },
      
      // Weather
      setWeather,
      triggerLightning: triggerLightningFlash,
      meteorShower: triggerMeteorShower,
      
      // City data access
      getBuildings: () => city.buildings,
      getDistricts: () => DISTRICTS,
      getActivityState: () => activityState,
      
      // Test demos
      demo: {
        // Simulate thinking about trading
        thinkTrading: () => {
          handleCognitiveState('thinking', 'Analyzing AAPL stock price movement and portfolio allocation');
        },
        // Simulate responding about memory
        respondMemory: () => {
          handleCognitiveState('responding', 'Here is what I remember about your preferences and past decisions');
        },
        // Activate all districts in sequence
        brainScan: async () => {
          const districts = ['core', 'memory', 'cognition', 'trading', 'execution', 'perception', 'growth', 'relationship', 'emotion'];
          for (const d of districts) {
            window.AbsalomCity.activateDistrict(d);
            await new Promise(r => setTimeout(r, 800));
          }
        },
        // Quick pulse from core
        corePulse: () => {
          handleCognitiveState('thinking', 'Core processing...');
          setTimeout(() => handleCognitiveState('responding', 'Output ready'), 2000);
          setTimeout(() => handleCognitiveState('idle'), 4000);
        }
      }
    };
    
    console.log('ğŸ§  Brain-scan API available: window.AbsalomCity');
    console.log('   Try: AbsalomCity.demo.brainScan() or AbsalomCity.think("analyzing stock data")');
  </script>
</body>
</html>
