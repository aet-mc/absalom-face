<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
  <title>Absalom — City of Mind</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; height: 100%; 
      overflow: hidden; 
      background: #0a0a12;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif;
    }
    #canvas { display: block; }
    
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      pointer-events: none;
    }
    .city-stats {
      background: rgba(10, 10, 20, 0.8);
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(100, 200, 255, 0.2);
      backdrop-filter: blur(10px);
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-bottom: 4px;
    }
    .stat-label { color: rgba(100, 200, 255, 0.6); }
    .stat-value { color: rgba(100, 200, 255, 1); font-weight: 500; }
    #fps { opacity: 0.5; font-size: 10px; margin-top: 8px; }
    
    .time-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      color: rgba(255,255,255,0.5);
      font-size: 11px;
      text-align: right;
    }
    
    .controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      color: rgba(255,255,255,0.3);
      font-size: 11px;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="hud">
    <div class="city-stats">
      <div class="stat-row">
        <span class="stat-label">structures</span>
        <span class="stat-value" id="buildingCount">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">districts</span>
        <span class="stat-value" id="districtCount">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">connections</span>
        <span class="stat-value" id="connectionCount">0</span>
      </div>
      <div id="fps"></div>
    </div>
  </div>
  
  <div class="time-indicator">
    <div id="timeDisplay">--:--</div>
    <div id="cyclePhase">dawn</div>
  </div>
  
  <div class="controls-hint">
    drag to orbit · scroll to zoom · shift+drag to pan
  </div>

  <!-- Three.js with post-processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  
  <script>
    // ═══════════════════════════════════════════════════════════════════════
    // ABSALOM CITY — A Mind Made Manifest (Cyberpunk Utopia Edition)
    // ═══════════════════════════════════════════════════════════════════════
    
    const canvas = document.getElementById('canvas');
    const buildingCountEl = document.getElementById('buildingCount');
    const districtCountEl = document.getElementById('districtCount');
    const connectionCountEl = document.getElementById('connectionCount');
    const fpsEl = document.getElementById('fps');
    const timeDisplayEl = document.getElementById('timeDisplay');
    const cyclePhaseEl = document.getElementById('cyclePhase');
    
    // Performance detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const qualityLevel = isMobile ? 'low' : 'high';
    
    // ═══════════════════════════════════════════════════════════════════════
    // SCENE SETUP
    // ═══════════════════════════════════════════════════════════════════════
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a15, 0.006);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(30, 40, 50);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: !isMobile,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    renderer.shadowMap.enabled = !isMobile;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    
    // Post-processing: Bloom
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      isMobile ? 0.8 : 1.2,  // strength
      0.4,                    // radius
      0.85                    // threshold
    );
    composer.addPass(bloomPass);
    
    // Orbit controls
    const controls = new THREE.OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 10;
    controls.maxDistance = 150;
    controls.target.set(0, 5, 0);
    
    // ═══════════════════════════════════════════════════════════════════════
    // DISTRICT DEFINITIONS
    // ═══════════════════════════════════════════════════════════════════════
    
    const DISTRICTS = {
      core: { 
        name: 'NEXUS CORE', 
        color: new THREE.Color(0x00ffff),
        emissive: new THREE.Color(0x003344),
        position: new THREE.Vector3(0, 0, 0),
        keywords: ['self', 'identity', 'soul', 'absalom']
      },
      trading: { 
        name: 'MARKET SPIRES', 
        color: new THREE.Color(0xffd700),
        emissive: new THREE.Color(0x332200),
        position: new THREE.Vector3(25, 0, 10),
        keywords: ['stock', 'trading', 'market', 'options', 'scanner', 'asymmetry']
      },
      infrastructure: { 
        name: 'DATAFORGE', 
        color: new THREE.Color(0xff6b9d),
        emissive: new THREE.Color(0x331122),
        position: new THREE.Vector3(-20, 0, 15),
        keywords: ['server', 'deploy', 'docker', 'tailscale', 'coolify', 'pm2']
      },
      projects: { 
        name: 'CREATION LABS', 
        color: new THREE.Color(0x9d6bff),
        emissive: new THREE.Color(0x220033),
        position: new THREE.Vector3(10, 0, -25),
        keywords: ['project', 'build', 'create', 'app', 'visualization']
      },
      memory: { 
        name: 'MEMORY BANKS', 
        color: new THREE.Color(0x6bff9d),
        emissive: new THREE.Color(0x113322),
        position: new THREE.Vector3(-15, 0, -20),
        keywords: ['memory', 'remember', 'decision', 'learned', 'preference']
      },
    };
    
    // ═══════════════════════════════════════════════════════════════════════
    // CITY STATE
    // ═══════════════════════════════════════════════════════════════════════
    
    const city = {
      buildings: [],
      connections: [],
      districts: new Map(),
      drones: [],
      particles: null,
      districtLabels: [],
      stars: null,
      coreRings: [],
      time: 0,
      realTime: new Date(),
      sunPosition: new THREE.Vector3(),
      nightIntensity: 0,
    };
    
    // ═══════════════════════════════════════════════════════════════════════
    // SKY DOME WITH DYNAMIC GRADIENT
    // ═══════════════════════════════════════════════════════════════════════
    
    function createSkyDome() {
      // Sky dome shader for beautiful time-based gradients
      const skyVertexShader = `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      
      const skyFragmentShader = `
        uniform vec3 topColor;
        uniform vec3 middleColor;
        uniform vec3 horizonColor;
        uniform vec3 horizonGlow;
        uniform float horizonSharpness;
        uniform float glowIntensity;
        uniform float sunY;
        varying vec3 vWorldPosition;
        
        void main() {
          float height = normalize(vWorldPosition).y;
          float heightClamped = max(0.0, height);
          
          // Three-zone gradient: horizon -> middle -> top
          vec3 color;
          if (heightClamped < 0.3) {
            // Horizon to middle
            float t = heightClamped / 0.3;
            t = smoothstep(0.0, 1.0, t);
            color = mix(horizonColor, middleColor, t);
            // Add horizon glow (concentrated at very bottom)
            float glowFactor = (1.0 - t) * (1.0 - t) * glowIntensity;
            color = mix(color, horizonGlow, glowFactor);
          } else {
            // Middle to top
            float t = (heightClamped - 0.3) / 0.7;
            t = smoothstep(0.0, 1.0, t);
            color = mix(middleColor, topColor, t);
          }
          
          // Add subtle atmospheric scattering near horizon
          float scatter = exp(-heightClamped * horizonSharpness) * 0.15;
          color += horizonGlow * scatter;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      
      const skyUniforms = {
        topColor: { value: new THREE.Color(0x0a0a20) },
        middleColor: { value: new THREE.Color(0x1a1a40) },
        horizonColor: { value: new THREE.Color(0x2a2a50) },
        horizonGlow: { value: new THREE.Color(0x4a3060) },
        horizonSharpness: { value: 3.0 },
        glowIntensity: { value: 0.3 },
        sunY: { value: 0.0 }
      };
      
      const skyGeo = new THREE.SphereGeometry(450, 32, 24);
      const skyMat = new THREE.ShaderMaterial({
        vertexShader: skyVertexShader,
        fragmentShader: skyFragmentShader,
        uniforms: skyUniforms,
        side: THREE.BackSide,
        depthWrite: false
      });
      
      city.skyDome = new THREE.Mesh(skyGeo, skyMat);
      city.skyUniforms = skyUniforms;
      scene.add(city.skyDome);
      
      // Disable default background
      scene.background = null;
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // SUN & MOON CELESTIAL BODIES
    // ═══════════════════════════════════════════════════════════════════════
    
    function createCelestialBodies() {
      // === SUN ===
      const sunGroup = new THREE.Group();
      
      // Sun core (bright center)
      const sunCoreGeo = new THREE.SphereGeometry(8, 24, 24);
      const sunCoreMat = new THREE.MeshBasicMaterial({
        color: 0xffffcc,
        transparent: true,
        opacity: 1.0
      });
      const sunCore = new THREE.Mesh(sunCoreGeo, sunCoreMat);
      sunGroup.add(sunCore);
      
      // Sun glow layer 1 (inner glow)
      const sunGlow1Geo = new THREE.SphereGeometry(12, 24, 24);
      const sunGlow1Mat = new THREE.MeshBasicMaterial({
        color: 0xffdd88,
        transparent: true,
        opacity: 0.4
      });
      const sunGlow1 = new THREE.Mesh(sunGlow1Geo, sunGlow1Mat);
      sunGroup.add(sunGlow1);
      
      // Sun glow layer 2 (outer glow)
      const sunGlow2Geo = new THREE.SphereGeometry(18, 24, 24);
      const sunGlow2Mat = new THREE.MeshBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.2
      });
      const sunGlow2 = new THREE.Mesh(sunGlow2Geo, sunGlow2Mat);
      sunGroup.add(sunGlow2);
      
      // Sun corona (large faint glow)
      const coronaGeo = new THREE.SphereGeometry(30, 16, 16);
      const coronaMat = new THREE.MeshBasicMaterial({
        color: 0xff8844,
        transparent: true,
        opacity: 0.1
      });
      const corona = new THREE.Mesh(coronaGeo, coronaMat);
      sunGroup.add(corona);
      
      city.sun = sunGroup;
      city.sunCore = sunCore;
      city.sunGlows = [sunGlow1, sunGlow2, corona];
      scene.add(sunGroup);
      
      // === MOON ===
      const moonGroup = new THREE.Group();
      
      // Moon surface
      const moonGeo = new THREE.SphereGeometry(5, 24, 24);
      const moonMat = new THREE.MeshBasicMaterial({
        color: 0xddeeff,
        transparent: true,
        opacity: 0.95
      });
      const moon = new THREE.Mesh(moonGeo, moonMat);
      moonGroup.add(moon);
      
      // Moon glow
      const moonGlowGeo = new THREE.SphereGeometry(8, 16, 16);
      const moonGlowMat = new THREE.MeshBasicMaterial({
        color: 0x8899bb,
        transparent: true,
        opacity: 0.25
      });
      const moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
      moonGroup.add(moonGlow);
      
      // Outer moon halo
      const moonHaloGeo = new THREE.SphereGeometry(12, 16, 16);
      const moonHaloMat = new THREE.MeshBasicMaterial({
        color: 0x6677aa,
        transparent: true,
        opacity: 0.1
      });
      const moonHalo = new THREE.Mesh(moonHaloGeo, moonHaloMat);
      moonGroup.add(moonHalo);
      
      city.moon = moonGroup;
      city.moonCore = moon;
      city.moonGlows = [moonGlow, moonHalo];
      scene.add(moonGroup);
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // STARFIELD SKYBOX
    // ═══════════════════════════════════════════════════════════════════════
    
    function createStarfield() {
      const starCount = isMobile ? 1000 : 3000;
      const starGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const sizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        // Distribute on a large sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 380 + Math.random() * 40;
        
        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = Math.abs(radius * Math.cos(phi)); // Only upper hemisphere
        positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        
        // Slight color variation (warm to cool white)
        const temp = 0.8 + Math.random() * 0.4;
        colors[i * 3] = temp;
        colors[i * 3 + 1] = temp * 0.95;
        colors[i * 3 + 2] = temp * (0.8 + Math.random() * 0.2);
        
        sizes[i] = 0.5 + Math.random() * 1.5;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      const starMaterial = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0,
        sizeAttenuation: false,
      });
      
      city.stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(city.stars);
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // HEX GRID GROUND WITH GLOWING ROADS
    // ═══════════════════════════════════════════════════════════════════════
    
    function createGround() {
      // Dark base plane
      const groundGeo = new THREE.PlaneGeometry(250, 250);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x050510,
        roughness: 0.95,
        metalness: 0.1,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Hex grid
      createHexGrid();
      
      // Glowing road network
      createRoadNetwork();
    }
    
    function createHexGrid() {
      const hexRadius = 3;
      const hexHeight = hexRadius * Math.sqrt(3);
      const gridSize = 15;
      
      const hexShape = new THREE.Shape();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
        const x = Math.cos(angle) * hexRadius * 0.95;
        const y = Math.sin(angle) * hexRadius * 0.95;
        if (i === 0) hexShape.moveTo(x, y);
        else hexShape.lineTo(x, y);
      }
      hexShape.closePath();
      
      const hexLineGeo = new THREE.EdgesGeometry(new THREE.ShapeGeometry(hexShape));
      const hexLineMat = new THREE.LineBasicMaterial({
        color: 0x1a2a3a,
        transparent: true,
        opacity: 0.4,
      });
      
      // Instanced hex outlines
      for (let q = -gridSize; q <= gridSize; q++) {
        for (let r = -gridSize; r <= gridSize; r++) {
          if (Math.abs(q + r) > gridSize) continue;
          
          const x = hexRadius * 1.5 * q;
          const z = hexHeight * (r + q / 2);
          
          // Skip center area for core
          if (Math.abs(x) < 8 && Math.abs(z) < 8) continue;
          
          const hexLine = new THREE.LineSegments(hexLineGeo, hexLineMat);
          hexLine.rotation.x = -Math.PI / 2;
          hexLine.position.set(x, 0.05, z);
          scene.add(hexLine);
        }
      }
    }
    
    function createRoadNetwork() {
      const roadMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.15,
      });
      
      const roadGlowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.6,
      });
      
      // Main roads connecting districts
      const districtPositions = Object.values(DISTRICTS).map(d => d.position);
      
      districtPositions.forEach((pos, i) => {
        // Road to center
        createRoadSegment(pos.x, pos.z, 0, 0, roadMaterial, roadGlowMaterial);
        
        // Connect to next district
        const next = districtPositions[(i + 1) % districtPositions.length];
        createRoadSegment(pos.x, pos.z, next.x, next.z, roadMaterial, roadGlowMaterial);
      });
    }
    
    function createRoadSegment(x1, z1, x2, z2, baseMat, glowMat) {
      const length = Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);
      const angle = Math.atan2(z2 - z1, x2 - x1);
      
      // Base road
      const roadGeo = new THREE.PlaneGeometry(length, 1.5);
      const road = new THREE.Mesh(roadGeo, baseMat);
      road.rotation.x = -Math.PI / 2;
      road.rotation.z = -angle;
      road.position.set((x1 + x2) / 2, 0.06, (z1 + z2) / 2);
      scene.add(road);
      
      // Center glow line
      const lineGeo = new THREE.PlaneGeometry(length, 0.15);
      const line = new THREE.Mesh(lineGeo, glowMat);
      line.rotation.x = -Math.PI / 2;
      line.rotation.z = -angle;
      line.position.set((x1 + x2) / 2, 0.08, (z1 + z2) / 2);
      scene.add(line);
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // ENVIRONMENT — Island, Clouds, Horizon
    // ═══════════════════════════════════════════════════════════════════════
    
    function createEnvironment() {
      // Floating island platform with glowing edge
      const islandRadius = 140;
      const islandGeo = new THREE.CylinderGeometry(islandRadius, islandRadius * 0.85, 8, 64);
      const islandMat = new THREE.MeshStandardMaterial({
        color: 0x0a0a15,
        roughness: 0.9,
        metalness: 0.2,
      });
      const island = new THREE.Mesh(islandGeo, islandMat);
      island.position.y = -4;
      island.receiveShadow = true;
      scene.add(island);
      
      // Glowing edge ring
      const edgeGeo = new THREE.TorusGeometry(islandRadius * 0.92, 0.5, 8, 128);
      const edgeMat = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.4,
      });
      const edge = new THREE.Mesh(edgeGeo, edgeMat);
      edge.rotation.x = Math.PI / 2;
      edge.position.y = -0.5;
      scene.add(edge);
      city.islandEdge = edge;
      
      // Second inner edge
      const edge2Geo = new THREE.TorusGeometry(islandRadius * 0.7, 0.3, 8, 96);
      const edge2 = new THREE.Mesh(edge2Geo, edgeMat.clone());
      edge2.material.opacity = 0.2;
      edge2.rotation.x = Math.PI / 2;
      edge2.position.y = -0.3;
      scene.add(edge2);
      
      // Cloud layer below
      createCloudLayer();
      
      // Horizon glow ring
      createHorizonGlow();
      
      // Distant floating rocks
      createFloatingRocks();
    }
    
    function createCloudLayer() {
      const cloudCount = isMobile ? 30 : 60;
      city.clouds = [];
      
      for (let i = 0; i < cloudCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 80 + Math.random() * 200;
        const size = 15 + Math.random() * 40;
        
        const cloudGeo = new THREE.SphereGeometry(size, 8, 6);
        const cloudMat = new THREE.MeshBasicMaterial({
          color: 0x334455,
          transparent: true,
          opacity: 0.15 + Math.random() * 0.15,
        });
        
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        cloud.position.set(
          Math.cos(angle) * radius,
          -20 - Math.random() * 60,
          Math.sin(angle) * radius
        );
        cloud.scale.set(1, 0.3, 1); // Flatten
        cloud.userData.angle = angle;
        cloud.userData.radius = radius;
        cloud.userData.speed = 0.0001 + Math.random() * 0.0002;
        cloud.userData.baseY = cloud.position.y;
        
        scene.add(cloud);
        city.clouds.push(cloud);
      }
    }
    
    function createHorizonGlow() {
      // Large glowing ring at horizon
      const horizonGeo = new THREE.TorusGeometry(300, 2, 8, 128);
      const horizonMat = new THREE.MeshBasicMaterial({
        color: 0x003355,
        transparent: true,
        opacity: 0.3,
      });
      const horizon = new THREE.Mesh(horizonGeo, horizonMat);
      horizon.rotation.x = Math.PI / 2;
      horizon.position.y = -10;
      scene.add(horizon);
      city.horizonRing = horizon;
      
      // Fog plane at horizon
      const fogGeo = new THREE.RingGeometry(150, 400, 64);
      const fogMat = new THREE.MeshBasicMaterial({
        color: 0x0a1525,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
      });
      const fog = new THREE.Mesh(fogGeo, fogMat);
      fog.rotation.x = -Math.PI / 2;
      fog.position.y = -15;
      scene.add(fog);
    }
    
    function createFloatingRocks() {
      const rockCount = isMobile ? 8 : 15;
      city.floatingRocks = [];
      
      for (let i = 0; i < rockCount; i++) {
        const angle = (i / rockCount) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 180 + Math.random() * 100;
        const size = 3 + Math.random() * 8;
        
        const rockGeo = new THREE.DodecahedronGeometry(size, 0);
        const rockMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a2a,
          roughness: 0.9,
          metalness: 0.1,
          emissive: 0x001122,
          emissiveIntensity: 0.3,
        });
        
        const rock = new THREE.Mesh(rockGeo, rockMat);
        rock.position.set(
          Math.cos(angle) * radius,
          -5 + Math.random() * 30,
          Math.sin(angle) * radius
        );
        rock.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        rock.userData.baseY = rock.position.y;
        rock.userData.floatSpeed = 0.5 + Math.random() * 0.5;
        rock.userData.floatPhase = Math.random() * Math.PI * 2;
        
        scene.add(rock);
        city.floatingRocks.push(rock);
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // CINEMATIC LIGHTING SYSTEM
    // ═══════════════════════════════════════════════════════════════════════
    
    let sunLight, moonLight, ambientLight, hemiLight;
    
    // Lighting state for smooth transitions
    const lighting = {
      targetSunColor: new THREE.Color(),
      targetAmbientColor: new THREE.Color(),
      targetFogColor: new THREE.Color(),
      currentSunColor: new THREE.Color(0xffeedd),
      currentAmbientColor: new THREE.Color(0x111122),
      currentFogColor: new THREE.Color(0x0a0a15),
      goldenHourIntensity: 0,
      rimLightIntensity: 0,
      windowLightProgress: 0, // 0 = day, 1 = fully lit windows
    };
    
    // Color presets for different times of day
    const LIGHT_PRESETS = {
      dawn: {
        sun: new THREE.Color(0xff6633), // Deep orange-red
        ambient: new THREE.Color(0x332244), // Purple-blue
        fog: new THREE.Color(0x1a1525),
        skyHue: 0.05, skySat: 0.7, skyLight: 0.08,
      },
      sunrise: {
        sun: new THREE.Color(0xffaa55), // Warm orange
        ambient: new THREE.Color(0x443322), // Warm brown
        fog: new THREE.Color(0x2a1a15),
        skyHue: 0.08, skySat: 0.6, skyLight: 0.15,
      },
      morning: {
        sun: new THREE.Color(0xffeebb), // Warm white
        ambient: new THREE.Color(0x334455), // Slight cool
        fog: new THREE.Color(0x151820),
        skyHue: 0.58, skySat: 0.4, skyLight: 0.12,
      },
      noon: {
        sun: new THREE.Color(0xffffff), // Neutral white
        ambient: new THREE.Color(0x445566), // Slight blue
        fog: new THREE.Color(0x0f1520),
        skyHue: 0.6, skySat: 0.35, skyLight: 0.1,
      },
      afternoon: {
        sun: new THREE.Color(0xfff5e0), // Slightly warm
        ambient: new THREE.Color(0x3a4455), // Neutral
        fog: new THREE.Color(0x121825),
        skyHue: 0.58, skySat: 0.4, skyLight: 0.09,
      },
      goldenHour: {
        sun: new THREE.Color(0xffcc66), // Golden
        ambient: new THREE.Color(0x553322), // Warm
        fog: new THREE.Color(0x251a10),
        skyHue: 0.07, skySat: 0.65, skyLight: 0.12,
      },
      sunset: {
        sun: new THREE.Color(0xff7744), // Deep orange
        ambient: new THREE.Color(0x442233), // Purple warm
        fog: new THREE.Color(0x201515),
        skyHue: 0.02, skySat: 0.7, skyLight: 0.08,
      },
      dusk: {
        sun: new THREE.Color(0x663355), // Purple
        ambient: new THREE.Color(0x221133), // Deep purple
        fog: new THREE.Color(0x0f0a15),
        skyHue: 0.75, skySat: 0.6, skyLight: 0.04,
      },
      night: {
        sun: new THREE.Color(0x000000), // Off
        ambient: new THREE.Color(0x0a1525), // Cool blue
        fog: new THREE.Color(0x050810),
        skyHue: 0.65, skySat: 0.7, skyLight: 0.01,
      },
    };
    
    function createLighting() {
      // Main sun light with shadows
      sunLight = new THREE.DirectionalLight(0xffeedd, 1);
      if (!isMobile) {
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -60;
        sunLight.shadow.camera.right = 60;
        sunLight.shadow.camera.top = 60;
        sunLight.shadow.camera.bottom = -60;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.normalBias = 0.02;
      }
      scene.add(sunLight);
      
      // Moon light - cooler, softer
      moonLight = new THREE.DirectionalLight(0x3355aa, 0.3);
      moonLight.position.set(30, 50, -40);
      scene.add(moonLight);
      
      // Ambient light - fills shadows
      ambientLight = new THREE.AmbientLight(0x111122, 0.5);
      scene.add(ambientLight);
      
      // Hemisphere light - sky/ground color influence
      hemiLight = new THREE.HemisphereLight(0x2244aa, 0x221100, 0.2);
      scene.add(hemiLight);
    }
    
    // Smooth interpolation helper
    function smoothstep(x) {
      return x * x * (3 - 2 * x);
    }
    
    // Get lighting preset blend based on hour
    function getLightingBlend(hours) {
      // Define time ranges for each phase
      const phases = [
        { start: 0, end: 5, preset: 'night' },
        { start: 5, end: 6, preset: 'dawn', nextPreset: 'sunrise' },
        { start: 6, end: 7.5, preset: 'sunrise', nextPreset: 'morning' },
        { start: 7.5, end: 11, preset: 'morning', nextPreset: 'noon' },
        { start: 11, end: 14, preset: 'noon' },
        { start: 14, end: 17, preset: 'afternoon', nextPreset: 'goldenHour' },
        { start: 17, end: 18.5, preset: 'goldenHour', nextPreset: 'sunset' },
        { start: 18.5, end: 20, preset: 'sunset', nextPreset: 'dusk' },
        { start: 20, end: 21.5, preset: 'dusk', nextPreset: 'night' },
        { start: 21.5, end: 24, preset: 'night' },
      ];
      
      for (const phase of phases) {
        if (hours >= phase.start && hours < phase.end) {
          if (phase.nextPreset) {
            const t = (hours - phase.start) / (phase.end - phase.start);
            return { from: phase.preset, to: phase.nextPreset, blend: smoothstep(t) };
          }
          return { from: phase.preset, to: phase.preset, blend: 0 };
        }
      }
      return { from: 'night', to: 'night', blend: 0 };
    }
    
    // Blend two colors
    function blendColors(color1, color2, t) {
      const result = new THREE.Color();
      result.r = color1.r + (color2.r - color1.r) * t;
      result.g = color1.g + (color2.g - color1.g) * t;
      result.b = color1.b + (color2.b - color1.b) * t;
      return result;
    }
    
    function updateLighting() {
      const now = new Date();
      const hours = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
      
      timeDisplayEl.textContent = now.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
      });
      
      // Calculate sun position (rises at 6, sets at 18)
      const sunAngle = ((hours - 6) / 24) * Math.PI * 2;
      const sunHeight = Math.sin(sunAngle);
      const sunAzimuth = Math.cos(sunAngle);
      
      // Sun position in world space
      const sunDistance = 80;
      const sunX = sunAzimuth * sunDistance * 0.8;
      const sunY = Math.max(sunHeight * sunDistance, -30);
      const sunZ = 40;
      sunLight.position.set(sunX, sunY, sunZ);
      
      // Moon opposite to sun, slightly offset
      moonLight.position.set(-sunX * 0.8, -sunY + 60, -sunZ * 0.7);
      
      // Get current lighting preset blend
      const { from, to, blend } = getLightingBlend(hours);
      const fromPreset = LIGHT_PRESETS[from];
      const toPreset = LIGHT_PRESETS[to];
      
      // Blend target colors
      lighting.targetSunColor = blendColors(fromPreset.sun, toPreset.sun, blend);
      lighting.targetAmbientColor = blendColors(fromPreset.ambient, toPreset.ambient, blend);
      lighting.targetFogColor = blendColors(fromPreset.fog, toPreset.fog, blend);
      
      // Smooth transition (lerp current toward target)
      const colorLerpSpeed = 0.02;
      lighting.currentSunColor.lerp(lighting.targetSunColor, colorLerpSpeed);
      lighting.currentAmbientColor.lerp(lighting.targetAmbientColor, colorLerpSpeed);
      lighting.currentFogColor.lerp(lighting.targetFogColor, colorLerpSpeed);
      
      // Apply colors to lights
      sunLight.color.copy(lighting.currentSunColor);
      ambientLight.color.copy(lighting.currentAmbientColor);
      
      // Calculate intensities
      const dayProgress = Math.max(0, sunHeight); // 0 at horizon, 1 at noon
      const horizonFactor = Math.abs(sunHeight); // Low at horizon
      
      // Sun intensity: parabolic curve, brightest at noon
      const sunIntensityBase = Math.pow(dayProgress, 0.6); // Softer falloff
      sunLight.intensity = sunIntensityBase * 1.4;
      
      // Night intensity for other systems
      city.nightIntensity = Math.max(0, -sunHeight);
      const twilightIntensity = (1 - Math.abs(sunHeight)) * (sunHeight < 0.3 ? 1 : 0);
      
      // Moon intensity - stronger when sun is down
      moonLight.intensity = city.nightIntensity * 0.5;
      moonLight.color.setHSL(0.6, 0.5, 0.5 + city.nightIntensity * 0.2);
      
      // Ambient intensity - never fully dark
      ambientLight.intensity = 0.15 + dayProgress * 0.25 + city.nightIntensity * 0.1;
      
      // Hemisphere light adapts to time
      const skyBlend = blend;
      const skyHue = fromPreset.skyHue + (toPreset.skyHue - fromPreset.skyHue) * skyBlend;
      const skySat = fromPreset.skySat + (toPreset.skySat - fromPreset.skySat) * skyBlend;
      const skyLight_l = fromPreset.skyLight + (toPreset.skyLight - fromPreset.skyLight) * skyBlend;
      
      hemiLight.color.setHSL(skyHue, skySat, skyLight_l + 0.1);
      hemiLight.groundColor.setHSL(0.08, 0.4, 0.02 + dayProgress * 0.03);
      hemiLight.intensity = 0.15 + dayProgress * 0.15;
      
      // Shadow softness varies with sun angle (lower sun = softer shadows)
      if (!isMobile && sunLight.shadow) {
        const shadowRadius = 1 + (1 - horizonFactor) * 3; // 1-4 range
        sunLight.shadow.radius = shadowRadius;
      }
      
      // Sky color
      scene.background = new THREE.Color().setHSL(skyHue, skySat, skyLight_l);
      
      // Fog color and density
      scene.fog.color.copy(lighting.currentFogColor);
      // Denser fog at night (mystery), lighter during day
      scene.fog.density = 0.004 + city.nightIntensity * 0.003 + twilightIntensity * 0.001;
      
      // Stars visibility - fade in during dusk, full at night
      if (city.stars) {
        const starVisibility = Math.max(0, city.nightIntensity * 1.2 - 0.1);
        city.stars.material.opacity = Math.min(0.9, starVisibility);
      }
      
      // Golden hour detection (1 hour before/after sunset/sunrise)
      const isGoldenHour = (hours >= 6 && hours <= 7.5) || (hours >= 17 && hours <= 19);
      lighting.goldenHourIntensity = isGoldenHour ? 
        (1 - Math.abs((hours > 12 ? hours - 18 : hours - 6.75)) / 1.5) : 0;
      lighting.goldenHourIntensity = Math.max(0, Math.min(1, lighting.goldenHourIntensity));
      
      // Rim lighting intensity (strong at sunrise/sunset when sun is low)
      lighting.rimLightIntensity = (sunHeight > -0.1 && sunHeight < 0.3) ? 
        (1 - Math.abs(sunHeight - 0.1) / 0.4) : 0;
      
      // Window light progress - gradual transition
      const targetWindowLight = city.nightIntensity > 0.1 ? 
        Math.min(1, (city.nightIntensity - 0.1) / 0.5) : 0;
      lighting.windowLightProgress += (targetWindowLight - lighting.windowLightProgress) * 0.01;
      
      // Bloom: stronger at night for neon pop, softer during day
      const baseBloom = isMobile ? 0.5 : 0.7;
      const nightBloom = city.nightIntensity * (isMobile ? 0.8 : 1.2);
      const goldenBloom = lighting.goldenHourIntensity * 0.3;
      bloomPass.strength = baseBloom + nightBloom + goldenBloom;
      bloomPass.threshold = 0.9 - city.nightIntensity * 0.2; // Lower threshold at night
      
      // Tone mapping exposure - brighter during day
      renderer.toneMappingExposure = 0.8 + dayProgress * 0.4 - city.nightIntensity * 0.2;
      
      // ═══════════════════════════════════════════════════════════════════════
      // SKY DOME UPDATE - Dynamic gradient based on time of day
      // ═══════════════════════════════════════════════════════════════════════
      if (city.skyUniforms) {
        // Calculate sky colors based on time
        let topColor, middleColor, horizonColor, horizonGlow, glowIntensity;
        
        if (hours >= 5 && hours < 7) {
          // SUNRISE - purple → orange → pink
          const t = (hours - 5) / 2;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x0a0520), new THREE.Color(0x2244aa), t
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2a1050), new THREE.Color(0x5588cc), t
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x883355), new THREE.Color(0xffaa77), t
          );
          horizonGlow = new THREE.Color().lerpColors(
            new THREE.Color(0xcc6655), new THREE.Color(0xffcc99), t
          );
          glowIntensity = 0.7 - t * 0.3;
        } else if (hours >= 7 && hours < 17) {
          // DAYTIME - deep blue → lighter blue
          const morningT = Math.min(1, (hours - 7) / 3);
          topColor = new THREE.Color(0x1155bb);
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x4488dd), new THREE.Color(0x3377cc), morningT
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x99ccff), new THREE.Color(0x88bbee), morningT
          );
          horizonGlow = new THREE.Color(0xaaddff);
          glowIntensity = 0.2;
        } else if (hours >= 17 && hours < 20) {
          // SUNSET - blue → orange → red → purple
          const t = (hours - 17) / 3;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2244aa), new THREE.Color(0x1a1040), t
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x6677aa), new THREE.Color(0x552255), t
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0xffaa66), new THREE.Color(0xff5533), t
          );
          horizonGlow = new THREE.Color().lerpColors(
            new THREE.Color(0xffcc88), new THREE.Color(0xff7744), t
          );
          glowIntensity = 0.5 + t * 0.3;
        } else {
          // NIGHT - dark blue/purple
          const nightT = hours >= 20 ? Math.min(1, (hours - 20) / 2) : 1;
          topColor = new THREE.Color().lerpColors(
            new THREE.Color(0x0a0820), new THREE.Color(0x050510), nightT
          );
          middleColor = new THREE.Color().lerpColors(
            new THREE.Color(0x151230), new THREE.Color(0x080815), nightT
          );
          horizonColor = new THREE.Color().lerpColors(
            new THREE.Color(0x2a2040), new THREE.Color(0x101020), nightT
          );
          horizonGlow = new THREE.Color(0x1a1530);
          glowIntensity = 0.15;
        }
        
        // Apply to sky dome shader
        city.skyUniforms.topColor.value.copy(topColor);
        city.skyUniforms.middleColor.value.copy(middleColor);
        city.skyUniforms.horizonColor.value.copy(horizonColor);
        city.skyUniforms.horizonGlow.value.copy(horizonGlow);
        city.skyUniforms.glowIntensity.value = glowIntensity;
        city.skyUniforms.horizonSharpness.value = isGoldenHour ? 2.0 : 4.0;
        city.skyUniforms.sunY.value = sunHeight;
      }
      
      // ═══════════════════════════════════════════════════════════════════════
      // SUN MESH UPDATE - Position and visibility
      // ═══════════════════════════════════════════════════════════════════════
      if (city.sun) {
        const celestialRadius = 350;
        const sunMeshX = sunAzimuth * celestialRadius * 0.7;
        const sunMeshY = Math.max(sunHeight * celestialRadius * 0.8, -100);
        const sunMeshZ = 100;
        
        city.sun.position.set(sunMeshX, sunMeshY, sunMeshZ);
        
        // Larger sun at horizon (atmospheric lensing effect)
        const horizonScale = 1 + (1 - Math.abs(sunHeight)) * 0.4;
        const visibility = Math.max(0, sunHeight + 0.15);
        city.sun.scale.setScalar(horizonScale * Math.max(0.01, visibility));
        
        // Update sun colors based on time
        if (city.sunCore) {
          let sunCoreColor;
          if (hours >= 5 && hours < 7) {
            sunCoreColor = new THREE.Color(0xffaa55); // Orange sunrise
          } else if (hours >= 7 && hours < 17) {
            sunCoreColor = new THREE.Color(0xffffee); // Bright white day
          } else if (hours >= 17 && hours < 20) {
            const t = (hours - 17) / 3;
            sunCoreColor = new THREE.Color().lerpColors(
              new THREE.Color(0xffdd77), new THREE.Color(0xff5522), t
            );
          } else {
            sunCoreColor = new THREE.Color(0x000000);
          }
          city.sunCore.material.color.copy(sunCoreColor);
          city.sunCore.material.opacity = visibility;
          
          // Update glow colors too
          city.sunGlows.forEach((glow, i) => {
            glow.material.color.copy(sunCoreColor);
            glow.material.opacity = [0.4, 0.2, 0.1][i] * visibility;
          });
        }
      }
      
      // ═══════════════════════════════════════════════════════════════════════
      // MOON MESH UPDATE - Position and visibility  
      // ═══════════════════════════════════════════════════════════════════════
      if (city.moon) {
        const moonAngle = sunAngle + Math.PI;
        const moonHeight = Math.sin(moonAngle);
        const moonAzimuth = Math.cos(moonAngle);
        const celestialRadius = 320;
        
        const moonMeshX = moonAzimuth * celestialRadius * 0.7;
        const moonMeshY = Math.max(moonHeight * celestialRadius * 0.6, -80);
        const moonMeshZ = -80;
        
        city.moon.position.set(moonMeshX, moonMeshY, moonMeshZ);
        
        const moonVisibility = Math.max(0, moonHeight + 0.1);
        city.moon.scale.setScalar(Math.max(0.01, moonVisibility));
        
        if (city.moonCore) {
          city.moonCore.material.opacity = moonVisibility * 0.95;
          city.moonGlows.forEach((glow, i) => {
            glow.material.opacity = [0.25, 0.1][i] * moonVisibility;
          });
        }
      }
      
      // ═══════════════════════════════════════════════════════════════════════
      // CLOUD COLOR UPDATE - Based on time of day
      // ═══════════════════════════════════════════════════════════════════════
      if (city.clouds) {
        let cloudColor;
        if (hours >= 5 && hours < 7) {
          // Sunrise - pink/orange clouds
          const t = (hours - 5) / 2;
          cloudColor = new THREE.Color().lerpColors(
            new THREE.Color(0x332233), new THREE.Color(0xff8866), t
          );
        } else if (hours >= 7 && hours < 17) {
          // Day - white/light gray
          cloudColor = new THREE.Color(0xccddee);
        } else if (hours >= 17 && hours < 20) {
          // Sunset - dramatic oranges/pinks
          const t = (hours - 17) / 3;
          cloudColor = new THREE.Color().lerpColors(
            new THREE.Color(0xffaa77), new THREE.Color(0xff6644), t
          );
        } else {
          // Night - dark
          cloudColor = new THREE.Color(0x1a1a25);
        }
        
        city.clouds.forEach(cloud => {
          cloud.material.color.copy(cloudColor);
          // Vary opacity
          const baseOpacity = 0.12;
          const goldenBoost = isGoldenHour ? 0.15 : 0;
          cloud.material.opacity = baseOpacity + goldenBoost - city.nightIntensity * 0.04;
        });
      }
      
      // Disable scene.background since we have sky dome
      scene.background = null;
      
      // Cycle phase display
      let phase = 'night';
      if (hours >= 5 && hours < 6) phase = 'dawn';
      else if (hours >= 6 && hours < 7.5) phase = 'sunrise';
      else if (hours >= 7.5 && hours < 11) phase = 'morning';
      else if (hours >= 11 && hours < 14) phase = 'noon';
      else if (hours >= 14 && hours < 17) phase = 'afternoon';
      else if (hours >= 17 && hours < 18.5) phase = 'golden hour';
      else if (hours >= 18.5 && hours < 20) phase = 'sunset';
      else if (hours >= 20 && hours < 21.5) phase = 'dusk';
      cyclePhaseEl.textContent = phase;
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // PROCEDURAL BUILDING SHAPES
    // ═══════════════════════════════════════════════════════════════════════
    
    const BUILDING_TYPES = {
      tower: (w, h, d) => new THREE.BoxGeometry(w, h, d),
      cylinder: (w, h, d) => new THREE.CylinderGeometry(w/2, w/2, h, 8),
      tapered: (w, h, d) => new THREE.CylinderGeometry(w/3, w/2, h, 6),
      spire: (w, h, d) => new THREE.ConeGeometry(w/2, h, 6),
      dome: (w, h, d) => {
        const geo = new THREE.SphereGeometry(w, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        return geo;
      },
      hexPrism: (w, h, d) => new THREE.CylinderGeometry(w/2, w/2, h, 6),
      octagon: (w, h, d) => new THREE.CylinderGeometry(w/2, w/2, h, 8),
    };
    
    function getRandomBuildingType() {
      const types = Object.keys(BUILDING_TYPES);
      const weights = [3, 2, 2, 1, 1, 1, 1]; // Tower most common
      const total = weights.reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      for (let i = 0; i < types.length; i++) {
        r -= weights[i];
        if (r <= 0) return types[i];
      }
      return 'tower';
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // BUILDING FEATURES
    // ═══════════════════════════════════════════════════════════════════════
    
    function addAntennaArray(mesh, height, color) {
      const antennaCount = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < antennaCount; i++) {
        const antennaHeight = 2 + Math.random() * 4;
        const antennaGeo = new THREE.CylinderGeometry(0.05, 0.08, antennaHeight, 4);
        const antennaMat = new THREE.MeshBasicMaterial({ color: 0x333344 });
        const antenna = new THREE.Mesh(antennaGeo, antennaMat);
        
        const angle = (i / antennaCount) * Math.PI * 2;
        const radius = 0.5 + Math.random() * 0.5;
        antenna.position.set(
          Math.cos(angle) * radius,
          height / 2 + antennaHeight / 2,
          Math.sin(angle) * radius
        );
        mesh.add(antenna);
        
        // Blinking light on top
        const lightGeo = new THREE.SphereGeometry(0.1, 4, 4);
        const lightMat = new THREE.MeshBasicMaterial({ color: color });
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.y = antennaHeight / 2 + 0.1;
        light.userData.blink = true;
        light.userData.blinkPhase = Math.random() * Math.PI * 2;
        antenna.add(light);
      }
    }
    
    function addRooftopGarden(mesh, width, depth, height) {
      const gardenGeo = new THREE.BoxGeometry(width * 0.7, 0.5, depth * 0.7);
      const gardenMat = new THREE.MeshBasicMaterial({
        color: 0x2d5a2d,
        transparent: true,
        opacity: 0.9,
      });
      const garden = new THREE.Mesh(gardenGeo, gardenMat);
      garden.position.y = height / 2 + 0.25;
      mesh.add(garden);
      
      // Glowing foliage particles
      const particleCount = 20;
      const particleGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * width * 0.6;
        positions[i * 3 + 1] = height / 2 + 0.5 + Math.random() * 0.8;
        positions[i * 3 + 2] = (Math.random() - 0.5) * depth * 0.6;
      }
      
      particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const particleMat = new THREE.PointsMaterial({
        color: 0x6bff9d,
        size: 0.3,
        transparent: true,
        opacity: 0.7,
      });
      const particles = new THREE.Points(particleGeo, particleMat);
      mesh.add(particles);
    }
    
    function addHolographicAd(mesh, width, height, districtColor) {
      const adHeight = 2 + Math.random() * 2;
      const adWidth = width * 0.8;
      
      // Hologram base
      const holoGeo = new THREE.PlaneGeometry(adWidth, adHeight);
      const holoMat = new THREE.MeshBasicMaterial({
        color: districtColor,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
      });
      const holo = new THREE.Mesh(holoGeo, holoMat);
      
      // Position on building side
      const side = Math.floor(Math.random() * 4);
      const offset = width / 2 + 0.1;
      const yPos = height * 0.3 + Math.random() * height * 0.4;
      
      switch(side) {
        case 0: holo.position.set(offset, yPos, 0); holo.rotation.y = Math.PI / 2; break;
        case 1: holo.position.set(-offset, yPos, 0); holo.rotation.y = -Math.PI / 2; break;
        case 2: holo.position.set(0, yPos, offset); break;
        case 3: holo.position.set(0, yPos, -offset); holo.rotation.y = Math.PI; break;
      }
      
      holo.userData.hologram = true;
      holo.userData.flickerPhase = Math.random() * Math.PI * 2;
      mesh.add(holo);
      
      // Scanlines effect (horizontal bars)
      for (let i = 0; i < 3; i++) {
        const lineGeo = new THREE.PlaneGeometry(adWidth, 0.05);
        const lineMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.3,
          side: THREE.DoubleSide,
        });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.position.y = -adHeight/2 + (i + 1) * (adHeight / 4);
        line.position.z = 0.01;
        holo.add(line);
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // BUILDING GENERATION
    // ═══════════════════════════════════════════════════════════════════════
    
    function createBuilding(config) {
      const {
        x = 0, z = 0,
        width = 2 + Math.random() * 3,
        depth = 2 + Math.random() * 3,
        height = 5 + Math.random() * 20,
        district = 'core',
        label = '',
        type = getRandomBuildingType(),
      } = config;
      
      const districtData = DISTRICTS[district] || DISTRICTS.core;
      
      // Create geometry based on type
      const geometry = BUILDING_TYPES[type](width, height, depth);
      
      const material = new THREE.MeshStandardMaterial({
        color: districtData.color.clone().multiplyScalar(0.25),
        emissive: districtData.emissive,
        emissiveIntensity: 0.5,
        roughness: 0.6,
        metalness: 0.4,
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      
      // Position adjustment for different types
      if (type === 'dome') {
        mesh.position.set(x, width, z);
      } else {
        mesh.position.set(x, height / 2, z);
      }
      
      mesh.castShadow = !isMobile;
      mesh.receiveShadow = !isMobile;
      
      // Window glow strips (not for domes/spires)
      if (type !== 'dome' && type !== 'spire') {
        const windowCount = Math.floor(height / 4);
        for (let i = 0; i < windowCount; i++) {
          const isGlowing = Math.random() > 0.3;
          if (!isGlowing) continue;
          
          let windowGeo;
          if (type === 'cylinder' || type === 'tapered' || type === 'hexPrism' || type === 'octagon') {
            windowGeo = new THREE.TorusGeometry(width / 2 + 0.05, 0.08, 4, type === 'hexPrism' ? 6 : 8);
          } else {
            windowGeo = new THREE.BoxGeometry(width * 0.85, 0.2, depth + 0.1);
          }
          
          const windowMat = new THREE.MeshBasicMaterial({
            color: districtData.color,
            transparent: true,
            opacity: 0.5 + Math.random() * 0.5,
          });
          const windowMesh = new THREE.Mesh(windowGeo, windowMat);
          
          if (type === 'cylinder' || type === 'tapered' || type === 'hexPrism' || type === 'octagon') {
            windowMesh.rotation.x = Math.PI / 2;
          }
          
          windowMesh.position.y = -height / 2 + 2 + i * 4;
          mesh.add(windowMesh);
        }
      }
      
      // Random features
      const featureRoll = Math.random();
      if (height > 12 && featureRoll < 0.25) {
        addAntennaArray(mesh, height, districtData.color);
      } else if (height > 8 && featureRoll < 0.45) {
        addRooftopGarden(mesh, width, depth, height);
      } else if (height > 10 && featureRoll < 0.65) {
        addHolographicAd(mesh, width, height, districtData.color);
      }
      
      // Top beacon for tall buildings
      if (height > 15 && type !== 'spire') {
        const beaconGeo = new THREE.SphereGeometry(0.25, 6, 6);
        const beaconMat = new THREE.MeshBasicMaterial({ color: districtData.color });
        const beacon = new THREE.Mesh(beaconGeo, beaconMat);
        beacon.position.y = type === 'dome' ? width : height / 2 + 0.4;
        beacon.userData.pulse = true;
        beacon.userData.pulsePhase = Math.random() * Math.PI * 2;
        mesh.add(beacon);
      }
      
      scene.add(mesh);
      
      const building = {
        mesh,
        district,
        label,
        type,
        x, z,
        width, depth, height,
        createdAt: Date.now(),
      };
      
      city.buildings.push(building);
      
      if (!city.districts.has(district)) {
        city.districts.set(district, []);
      }
      city.districts.get(district).push(building);
      
      updateStats();
      return building;
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // CONNECTION LINES
    // ═══════════════════════════════════════════════════════════════════════
    
    function createConnection(building1, building2) {
      const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(building1.x, 0.5, building1.z),
        new THREE.Vector3(
          (building1.x + building2.x) / 2,
          2 + Math.random() * 2,
          (building1.z + building2.z) / 2
        ),
        new THREE.Vector3(building2.x, 0.5, building2.z)
      );
      
      const points = curve.getPoints(20);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.25,
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      
      city.connections.push({ line, from: building1, to: building2 });
      updateStats();
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // HOLOGRAPHIC DISTRICT LABELS
    // ═══════════════════════════════════════════════════════════════════════
    
    function createDistrictLabels() {
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;
        
        // Transparent background
        ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Glowing text
        ctx.font = 'bold 48px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Glow effect
        ctx.shadowColor = '#' + district.color.getHexString();
        ctx.shadowBlur = 20;
        ctx.fillStyle = '#' + district.color.getHexString();
        ctx.fillText(district.name, canvas.width / 2, canvas.height / 2);
        
        // Brighter center
        ctx.shadowBlur = 5;
        ctx.fillStyle = '#ffffff';
        ctx.fillText(district.name, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const labelMat = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.8,
        });
        
        const label = new THREE.Sprite(labelMat);
        label.position.set(
          district.position.x,
          25 + Math.random() * 5,
          district.position.z
        );
        label.scale.set(15, 4, 1);
        
        label.userData.baseY = label.position.y;
        label.userData.floatPhase = Math.random() * Math.PI * 2;
        
        scene.add(label);
        city.districtLabels.push(label);
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // FLYING DRONES/VEHICLES
    // ═══════════════════════════════════════════════════════════════════════
    
    function createDrones() {
      const droneCount = isMobile ? 8 : 15;
      
      for (let i = 0; i < droneCount; i++) {
        const droneGroup = new THREE.Group();
        
        // Main body
        const bodyGeo = new THREE.SphereGeometry(0.3, 6, 4);
        const bodyMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.8,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        droneGroup.add(body);
        
        // Light trail
        const trailGeo = new THREE.ConeGeometry(0.15, 1.5, 4);
        const trailMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.rotation.x = Math.PI / 2;
        trail.position.z = 0.8;
        droneGroup.add(trail);
        
        // Random patrol path
        const pathRadius = 15 + Math.random() * 40;
        const pathHeight = 10 + Math.random() * 25;
        const pathSpeed = 0.2 + Math.random() * 0.3;
        const pathOffset = Math.random() * Math.PI * 2;
        const pathTilt = (Math.random() - 0.5) * 0.5;
        
        droneGroup.userData = {
          pathRadius,
          pathHeight,
          pathSpeed,
          pathOffset,
          pathTilt,
        };
        
        scene.add(droneGroup);
        city.drones.push(droneGroup);
      }
    }
    
    function updateDrones(time) {
      city.drones.forEach((drone, i) => {
        const { pathRadius, pathHeight, pathSpeed, pathOffset, pathTilt } = drone.userData;
        
        const t = time * pathSpeed + pathOffset;
        const x = Math.cos(t) * pathRadius;
        const z = Math.sin(t) * pathRadius + Math.sin(t * 2) * pathRadius * 0.2;
        const y = pathHeight + Math.sin(t * 1.5) * 5;
        
        drone.position.set(x, y, z);
        
        // Face movement direction
        const nextT = t + 0.1;
        const nextX = Math.cos(nextT) * pathRadius;
        const nextZ = Math.sin(nextT) * pathRadius + Math.sin(nextT * 2) * pathRadius * 0.2;
        drone.lookAt(nextX, y, nextZ);
        
        // Update drone lighting based on time of day
        drone.children.forEach(child => {
          if (child.material) {
            // Brighter at night, dimmer during bright day
            const baseOpacity = 0.5 + city.nightIntensity * 0.4;
            child.material.opacity = baseOpacity;
            
            // Color shift: warmer during golden hour, cooler at night
            if (lighting.goldenHourIntensity > 0) {
              child.material.color.setHex(0x44ffcc);
            } else if (city.nightIntensity > 0.5) {
              child.material.color.setHex(0x4488ff);
            } else {
              child.material.color.setHex(0x00ffff);
            }
          }
        });
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // AMBIENT PARTICLES
    // ═══════════════════════════════════════════════════════════════════════
    
    function createParticles() {
      const particleCount = isMobile ? 200 : 500;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        velocities[i * 3] = (Math.random() - 0.5) * 0.02;
        velocities[i * 3 + 1] = Math.random() * 0.02 + 0.01;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.userData = { velocities };
      
      const material = new THREE.PointsMaterial({
        color: 0x66ddff,
        size: 0.15,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
      });
      
      city.particles = new THREE.Points(geometry, material);
      scene.add(city.particles);
    }
    
    function updateParticles() {
      if (!city.particles) return;
      
      const positions = city.particles.geometry.attributes.position.array;
      const velocities = city.particles.geometry.userData.velocities;
      
      for (let i = 0; i < positions.length / 3; i++) {
        positions[i * 3] += velocities[i * 3];
        positions[i * 3 + 1] += velocities[i * 3 + 1];
        positions[i * 3 + 2] += velocities[i * 3 + 2];
        
        // Reset particles that go too high
        if (positions[i * 3 + 1] > 60) {
          positions[i * 3] = (Math.random() - 0.5) * 100;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        }
      }
      
      city.particles.geometry.attributes.position.needsUpdate = true;
      
      // Particle color and visibility responds to time
      // Brighter and more visible at night, almost invisible during bright day
      const dayVisibility = 0.3;
      const nightVisibility = 0.8;
      city.particles.material.opacity = dayVisibility + (nightVisibility - dayVisibility) * city.nightIntensity;
      
      // Color shift with atmosphere
      if (lighting.goldenHourIntensity > 0) {
        city.particles.material.color.setHex(0xffdd88); // Warm golden
      } else if (city.nightIntensity > 0.5) {
        city.particles.material.color.setHex(0x88ccff); // Cool blue
      } else {
        city.particles.material.color.setHex(0x66ddff); // Neutral cyan
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // CORE SPIRE
    // ═══════════════════════════════════════════════════════════════════════
    
    function createCoreSpire() {
      // Main crystalline spire
      const spireGeo = new THREE.CylinderGeometry(0.3, 2.5, 40, 8);
      const spireMat = new THREE.MeshStandardMaterial({
        color: 0x001a1a,
        emissive: 0x00ffff,
        emissiveIntensity: 1.0,
        roughness: 0.2,
        metalness: 0.8,
        transparent: true,
        opacity: 0.9,
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.set(0, 20, 0);
      spire.castShadow = !isMobile;
      scene.add(spire);
      
      // Inner glow core
      const coreGeo = new THREE.SphereGeometry(1.5, 16, 16);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.8,
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      core.position.set(0, 8, 0);
      core.userData.pulse = true;
      scene.add(core);
      city.coreGlow = core;
      
      // Rotating energy rings
      for (let i = 0; i < 4; i++) {
        const ringGeo = new THREE.TorusGeometry(3 + i * 2, 0.08, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.6 - i * 0.1,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(0, 8 + i * 7, 0);
        ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
        ring.userData.rotationSpeed = 0.4 + i * 0.15;
        ring.userData.rotationAxis = i % 2 === 0 ? 'z' : 'y';
        ring.userData.wobble = Math.random() * 0.02;
        scene.add(ring);
        city.coreRings.push(ring);
      }
      
      // Energy beams shooting up
      for (let i = 0; i < 3; i++) {
        const beamGeo = new THREE.CylinderGeometry(0.05, 0.15, 50, 4);
        const beamMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3,
        });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        const angle = (i / 3) * Math.PI * 2;
        beam.position.set(Math.cos(angle) * 2, 25, Math.sin(angle) * 2);
        beam.userData.beamPhase = i * 0.7;
        scene.add(beam);
        city.coreRings.push(beam);
      }
      
      // Base platform with glow
      const baseGeo = new THREE.CylinderGeometry(6, 7, 1.5, 8);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x0a1a1a,
        emissive: 0x004444,
        emissiveIntensity: 0.8,
        roughness: 0.4,
        metalness: 0.6,
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, 0.75, 0);
      base.receiveShadow = true;
      scene.add(base);
      
      // Pulsing floor rings
      for (let i = 0; i < 3; i++) {
        const floorRingGeo = new THREE.TorusGeometry(8 + i * 3, 0.15, 4, 32);
        const floorRingMat = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3 - i * 0.08,
        });
        const floorRing = new THREE.Mesh(floorRingGeo, floorRingMat);
        floorRing.rotation.x = -Math.PI / 2;
        floorRing.position.y = 0.1;
        floorRing.userData.pulseRing = true;
        floorRing.userData.pulsePhase = i * 0.5;
        scene.add(floorRing);
        city.coreRings.push(floorRing);
      }
      
      city.buildings.push({
        mesh: spire,
        district: 'core',
        label: 'Nexus Core',
        x: 0, z: 0,
        height: 40,
        createdAt: Date.now(),
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // SEED CITY
    // ═══════════════════════════════════════════════════════════════════════
    
    function seedCity() {
      createCoreSpire();
      
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        if (key === 'core') return;
        
        const pos = district.position;
        
        // District anchor - always a significant tower
        createBuilding({
          x: pos.x,
          z: pos.z,
          height: 18 + Math.random() * 12,
          width: 4 + Math.random() * 2,
          depth: 4 + Math.random() * 2,
          district: key,
          label: `${district.name} Hub`,
          type: Math.random() > 0.5 ? 'tapered' : 'tower',
        });
        
        // Surrounding buildings with variety
        const buildingCount = isMobile ? 4 : 6;
        for (let i = 0; i < buildingCount; i++) {
          const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.5;
          const radius = 6 + Math.random() * 8;
          createBuilding({
            x: pos.x + Math.cos(angle) * radius,
            z: pos.z + Math.sin(angle) * radius,
            height: 5 + Math.random() * 15,
            district: key,
          });
        }
      });
      
      // Create connections
      const districtKeys = Object.keys(DISTRICTS).filter(k => k !== 'core');
      districtKeys.forEach(key => {
        const districtBuildings = city.districts.get(key) || [];
        if (districtBuildings.length > 0) {
          createConnection(city.buildings[0], districtBuildings[0]);
        }
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // ENVIRONMENT ANIMATION
    // ═══════════════════════════════════════════════════════════════════════
    
    function updateEnvironment(dt) {
      // Animate clouds - color responds to fog/sky
      if (city.clouds) {
        city.clouds.forEach(cloud => {
          cloud.userData.angle += cloud.userData.speed;
          cloud.position.x = Math.cos(cloud.userData.angle) * cloud.userData.radius;
          cloud.position.z = Math.sin(cloud.userData.angle) * cloud.userData.radius;
          cloud.position.y = cloud.userData.baseY + Math.sin(dt * 0.2 + cloud.userData.angle) * 3;
          
          // Cloud color matches fog with slight warmth during golden hour
          if (cloud.material.color) {
            cloud.material.color.copy(lighting.currentFogColor).multiplyScalar(2.5);
            if (lighting.goldenHourIntensity > 0) {
              cloud.material.color.r += lighting.goldenHourIntensity * 0.15;
              cloud.material.color.g += lighting.goldenHourIntensity * 0.05;
            }
          }
          // Clouds more opaque at night (denser atmosphere feel)
          cloud.material.opacity = 0.12 + city.nightIntensity * 0.1;
        });
      }
      
      // Animate floating rocks - subtle glow at night
      if (city.floatingRocks) {
        city.floatingRocks.forEach(rock => {
          rock.position.y = rock.userData.baseY + 
            Math.sin(dt * rock.userData.floatSpeed + rock.userData.floatPhase) * 2;
          rock.rotation.y += 0.001;
          
          // Emissive glow intensifies at night
          if (rock.material.emissiveIntensity !== undefined) {
            rock.material.emissiveIntensity = 0.2 + city.nightIntensity * 0.5;
            // Moonlight tint
            if (city.nightIntensity > 0.3) {
              rock.material.emissive.setHex(0x112244);
            } else {
              rock.material.emissive.setHex(0x001122);
            }
          }
        });
      }
      
      // Pulse island edge - color shifts with time
      if (city.islandEdge) {
        const basePulse = Math.sin(dt * 0.5) * 0.1;
        city.islandEdge.material.opacity = 0.25 + basePulse + city.nightIntensity * 0.15;
        // Warmer during golden hour, cooler at night
        if (lighting.goldenHourIntensity > 0) {
          city.islandEdge.material.color.setHex(0xffaa44);
        } else if (city.nightIntensity > 0.3) {
          city.islandEdge.material.color.setHex(0x3366ff);
        } else {
          city.islandEdge.material.color.setHex(0x00aaff);
        }
      }
      
      // Pulse horizon ring - atmospheric glow
      if (city.horizonRing) {
        const scale = 1 + Math.sin(dt * 0.3) * 0.02;
        city.horizonRing.scale.set(scale, scale, 1);
        city.horizonRing.material.opacity = 0.2 + Math.sin(dt * 0.4) * 0.1 + city.nightIntensity * 0.2;
        
        // Horizon color matches atmosphere
        if (lighting.goldenHourIntensity > 0) {
          city.horizonRing.material.color.setHex(0xff7744);
        } else if (city.nightIntensity > 0.5) {
          city.horizonRing.material.color.setHex(0x1a3366);
        } else {
          city.horizonRing.material.color.setHex(0x003355);
        }
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // GROWTH SYSTEM
    // ═══════════════════════════════════════════════════════════════════════
    
    let lastGrowth = Date.now();
    const GROWTH_INTERVAL = 30000;
    
    function growCity() {
      const now = Date.now();
      if (now - lastGrowth < GROWTH_INTERVAL) return;
      lastGrowth = now;
      
      const districtKeys = Object.keys(DISTRICTS);
      const district = districtKeys[Math.floor(Math.random() * districtKeys.length)];
      const districtData = DISTRICTS[district];
      
      const existing = city.districts.get(district) || [];
      let x, z;
      
      if (existing.length > 0) {
        const parent = existing[Math.floor(Math.random() * existing.length)];
        const angle = Math.random() * Math.PI * 2;
        const radius = 5 + Math.random() * 8;
        x = parent.x + Math.cos(angle) * radius;
        z = parent.z + Math.sin(angle) * radius;
      } else {
        x = districtData.position.x + (Math.random() - 0.5) * 10;
        z = districtData.position.z + (Math.random() - 0.5) * 10;
      }
      
      const newBuilding = createBuilding({
        x, z,
        district,
        height: 5 + Math.random() * 15,
      });
      
      if (existing.length > 0) {
        const nearest = existing.reduce((best, b) => {
          const d1 = Math.hypot(b.x - x, b.z - z);
          const d2 = Math.hypot(best.x - x, best.z - z);
          return d1 < d2 ? b : best;
        });
        createConnection(newBuilding, nearest);
      }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // STATS
    // ═══════════════════════════════════════════════════════════════════════
    
    function updateStats() {
      buildingCountEl.textContent = city.buildings.length;
      districtCountEl.textContent = city.districts.size;
      connectionCountEl.textContent = city.connections.length;
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATION LOOP
    // ═══════════════════════════════════════════════════════════════════════
    
    let frameCount = 0;
    let lastFpsTime = 0;
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      const dt = time * 0.001;
      
      // FPS
      frameCount++;
      if (time - lastFpsTime > 1000) {
        fpsEl.textContent = `${frameCount} fps`;
        frameCount = 0;
        lastFpsTime = time;
      }
      
      controls.update();
      updateLighting();
      
      // Core animations - more vibrant at night
      if (city.coreRings) {
        const coreNightBoost = 1 + city.nightIntensity * 0.5;
        city.coreRings.forEach(ring => {
          if (ring.userData.rotationAxis === 'z') {
            ring.rotation.z += ring.userData.rotationSpeed * 0.01;
            ring.rotation.x = Math.PI / 2 + Math.sin(dt + ring.userData.wobble) * 0.1;
            ring.material.opacity = (0.5 + city.nightIntensity * 0.3) * coreNightBoost;
          } else if (ring.userData.rotationAxis === 'y') {
            ring.rotation.y += ring.userData.rotationSpeed * 0.01;
            ring.material.opacity = (0.4 + city.nightIntensity * 0.4) * coreNightBoost;
          } else if (ring.userData.beamPhase !== undefined) {
            const beamPulse = Math.sin(dt * 2 + ring.userData.beamPhase) * 0.15;
            ring.material.opacity = (0.15 + beamPulse + city.nightIntensity * 0.2) * coreNightBoost;
          } else if (ring.userData.pulseRing) {
            const scale = 1 + Math.sin(dt * 1.5 + ring.userData.pulsePhase) * 0.1;
            ring.scale.set(scale, scale, 1);
            ring.material.opacity = (0.25 + city.nightIntensity * 0.2) * coreNightBoost;
          }
        });
      }
      
      // Core glow pulse - heart of the city
      if (city.coreGlow) {
        const nightIntensity = 1 + city.nightIntensity * 0.4;
        const pulse = 1 + Math.sin(dt * 2) * 0.2 * nightIntensity;
        city.coreGlow.scale.set(pulse, pulse, pulse);
        city.coreGlow.material.opacity = (0.5 + Math.sin(dt * 3) * 0.2) * nightIntensity;
        
        // Color shifts slightly with time
        if (lighting.goldenHourIntensity > 0) {
          city.coreGlow.material.color.setHex(0x44ffcc); // Warm cyan
        } else if (city.nightIntensity > 0.5) {
          city.coreGlow.material.color.setHex(0x00ddff); // Cool cyan
        } else {
          city.coreGlow.material.color.setHex(0x00ffff); // Neutral cyan
        }
      }
      
      // Building effects with cinematic lighting response
      if (Math.floor(time) % 100 < 16) {
        // Golden hour surface glow factor
        const goldenGlow = lighting.goldenHourIntensity;
        const rimFactor = lighting.rimLightIntensity;
        const windowProgress = lighting.windowLightProgress;
        
        city.buildings.forEach((b, buildingIndex) => {
          if (b.mesh.material && b.mesh.material.emissive) {
            // Base emissive from district
            const districtData = DISTRICTS[b.district] || DISTRICTS.core;
            
            // Night boost for emissives
            const nightBoost = 0.5 + city.nightIntensity * 1.5;
            
            // Golden hour warm tint on surfaces
            if (goldenGlow > 0) {
              const warmTint = new THREE.Color(0xff9944).multiplyScalar(goldenGlow * 0.3);
              b.mesh.material.emissive.copy(districtData.emissive).add(warmTint);
            } else {
              b.mesh.material.emissive.copy(districtData.emissive);
            }
            
            b.mesh.material.emissiveIntensity = 0.4 * nightBoost;
            
            // Moonlight blue tint at night
            if (city.nightIntensity > 0.3) {
              const moonTint = new THREE.Color(0x2244aa).multiplyScalar(city.nightIntensity * 0.1);
              b.mesh.material.emissive.add(moonTint);
            }
          }
          
          // Animate child elements (windows, antennas, holograms)
          b.mesh.children.forEach((child, childIndex) => {
            // Antenna blink lights
            if (child.userData.blink) {
              const blinkSpeed = 3 + (buildingIndex % 3); // Varied speeds
              child.material.opacity = Math.sin(dt * blinkSpeed + child.userData.blinkPhase) > 0.7 ? 1 : 0.2;
            }
            
            // Beacon pulse
            if (child.userData.pulse) {
              const pulseIntensity = 0.2 + city.nightIntensity * 0.3;
              const p = 1 + Math.sin(dt * 2 + child.userData.pulsePhase) * pulseIntensity;
              child.scale.set(p, p, p);
            }
            
            // Window strips - gradual lighting response
            if (child.geometry && (child.geometry.type === 'BoxGeometry' || child.geometry.type === 'TorusGeometry')) {
              // Some windows are "always on" (odd indices), others respond to time
              const alwaysOn = childIndex % 3 === 0;
              const baseOpacity = alwaysOn ? 0.4 : 0.1;
              const nightOpacity = alwaysOn ? 0.8 : windowProgress * 0.7;
              
              // Slight flicker for realism
              const flicker = Math.random() > 0.98 ? 0.1 : 0;
              child.material.opacity = baseOpacity + nightOpacity + flicker;
              
              // Windows get warmer at night (interior glow)
              if (city.nightIntensity > 0.2 && child.material.color) {
                const warmth = city.nightIntensity * 0.2;
                child.material.color.setRGB(
                  1, 
                  0.9 - warmth * 0.1, 
                  0.7 - warmth * 0.3
                );
              }
            }
            
            // Holographic ads - much brighter at night
            if (child.userData.hologram) {
              const nightMultiplier = 1 + city.nightIntensity * 1.5;
              const baseFlicker = Math.sin(dt * 5 + child.userData.flickerPhase) * 0.15;
              const glitchChance = Math.random() > 0.97 ? -0.3 : 0;
              child.material.opacity = (0.25 + baseFlicker + glitchChance) * nightMultiplier;
              
              // Scanline children also brighten
              child.children.forEach(scanline => {
                if (scanline.material) {
                  scanline.material.opacity = 0.2 + city.nightIntensity * 0.4;
                }
              });
            }
          });
        });
      }
      
      // Connection pulse - brighter energy flow at night
      city.connections.forEach((conn, i) => {
        const baseSpeed = 2 + (i % 3) * 0.3; // Varied speeds
        const pulse = Math.sin(dt * baseSpeed + i * 0.5) * 0.12 + 0.2;
        const nightBoost = 1 + city.nightIntensity * 1.2;
        conn.line.material.opacity = pulse * nightBoost;
        
        // Shift connection color slightly warmer during golden hour
        if (lighting.goldenHourIntensity > 0) {
          const warmShift = lighting.goldenHourIntensity * 0.2;
          conn.line.material.color.setRGB(0 + warmShift, 1, 1 - warmShift * 0.5);
        } else {
          conn.line.material.color.setHex(0x00ffff);
        }
      });
      
      // District labels float - more visible at night, subtle during day
      city.districtLabels.forEach(label => {
        label.position.y = label.userData.baseY + Math.sin(dt * 0.5 + label.userData.floatPhase) * 1;
        // Fade based on time: subtle during bright day, prominent at night
        const dayFade = Math.max(0, 1 - city.nightIntensity * 0.5 - (1 - city.nightIntensity) * 0.4);
        label.material.opacity = 0.3 + dayFade * 0.2 + city.nightIntensity * 0.5;
      });
      
      // Drones
      updateDrones(dt);
      
      // Particles
      updateParticles();
      
      // Environment animations
      updateEnvironment(dt);
      
      // City growth
      growCity();
      
      // Render with bloom
      composer.render();
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // RESIZE
    // ═══════════════════════════════════════════════════════════════════════
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ═══════════════════════════════════════════════════════════════════════
    // WEBSOCKET (Live Knowledge Connection)
    // ═══════════════════════════════════════════════════════════════════════
    
    const WS_URL = 'wss://itself-partners-integrate-memories.trycloudflare.com';
    let cityWebSocket = null;
    let districtGlowIntensities = {};
    let cityLoadedFromServer = false;
    
    const API_URL = 'https://itself-partners-integrate-memories.trycloudflare.com';
    
    // Try HTTP first (more reliable), then WebSocket for live updates
    async function loadCityFromAPI() {
      try {
        console.log('[API] Fetching city state from:', `${API_URL}/city-state`);
        const res = await fetch(`${API_URL}/city-state`);
        console.log('[API] Response status:', res.status);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const cityState = await res.json();
        console.log('[API] Parsed JSON, buildings:', cityState.buildings?.length);
        console.log('[API] First building:', JSON.stringify(cityState.buildings?.[0]));
        if (cityState.buildings && cityState.buildings.length > 0) {
          loadCityFromState(cityState);
          return true;
        } else {
          console.error('[API] No buildings in response');
          return false;
        }
      } catch (err) {
        console.error('[API] Failed:', err.message, err);
        return false;
      }
    }
    
    function connectKnowledge() {
      cityWebSocket = new WebSocket(WS_URL);
      
      cityWebSocket.onopen = () => {
        console.log('[WS] Connected to knowledge engine');
        // Don't request city state - we already loaded via HTTP
      };
      
      cityWebSocket.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          
          // Live updates if city changes
          if (msg.type === 'city:state' && msg.city) {
            console.log('[WS] City update:', msg.city.buildings?.length, 'buildings');
            loadCityFromState(msg.city);
          }
          
          if (msg.type === 'state') {
            handleCognitiveState(msg.mode, msg.message);
          }
          
          if (msg.type === 'graph:full') {
            console.log('[WS] Received knowledge graph:', msg.graph?.nodes?.length, 'nodes');
          }
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };
      
      cityWebSocket.onclose = () => {
        console.log('[WS] Disconnected, reconnecting...');
        setTimeout(connectKnowledge, 5000);
      };
      cityWebSocket.onerror = () => cityWebSocket.close();
    }
    
    /**
     * Load city buildings from server state
     */
    function loadCityFromState(cityState) {
      console.log('[LoadCity] Called with', cityState?.buildings?.length, 'buildings');
      if (!cityState.buildings || cityState.buildings.length === 0) {
        console.log('[City] No buildings in state');
        return;
      }
      
      cityLoadedFromServer = true;
      console.log('[LoadCity] Creating buildings...');
      
      // Clear existing buildings except core spire (first building)
      while (city.buildings.length > 1) {
        const b = city.buildings.pop();
        scene.remove(b.mesh);
      }
      city.connections.forEach(c => scene.remove(c.line));
      city.connections = [];
      
      // Reset districts, keep core
      city.districts.clear();
      if (city.buildings.length > 0) {
        city.districts.set('core', [city.buildings[0]]);
      }
      
      // Create buildings from state
      console.log('[LoadCity] Iterating', cityState.buildings.length, 'building specs');
      let created = 0;
      for (const spec of cityState.buildings) {
        try {
          createBuilding({
            x: spec.x,
            z: spec.z,
            width: spec.width || 2.5,
            depth: spec.depth || 2.5,
            height: spec.height,
            district: spec.district,
            label: spec.label
          });
          created++;
        } catch (err) {
          console.error('[LoadCity] Failed to create building:', spec.label, err);
        }
      }
      console.log('[LoadCity] Created', created, 'buildings');
      
      // Create connections from state
      if (cityState.connections) {
        const idToBuilding = new Map();
        cityState.buildings.forEach((spec, i) => {
          // Match spec to building by position
          const b = city.buildings.find(bld => 
            Math.abs(bld.x - spec.x) < 0.5 && Math.abs(bld.z - spec.z) < 0.5
          );
          if (b) idToBuilding.set(spec.id, b);
        });
        
        for (const conn of cityState.connections) {
          const fromB = idToBuilding.get(conn.from);
          const toB = idToBuilding.get(conn.to);
          if (fromB && toB) {
            createConnection(fromB, toB);
          }
        }
      }
      
      // Set district activity
      if (cityState.districtActivity) {
        districtGlowIntensities = { ...cityState.districtActivity };
      }
      
      console.log(`[City] Loaded ${city.buildings.length} buildings from knowledge`);
      updateStats();
    }
    
    /**
     * Handle cognitive state changes - district glow mapping
     */
    function handleCognitiveState(mode, message = '') {
      const districtKeywords = {
        trading: ['stock', 'trading', 'market', 'ticker', 'price', 'portfolio', 'scan', 'asymmetry'],
        infrastructure: ['server', 'deploy', 'api', 'docker', 'tunnel', 'pm2', 'cloudflare'],
        projects: ['project', 'build', 'app', 'visualization', 'face', 'city', 'mind'],
        memory: ['memory', 'remember', 'decision', 'note', 'log', 'history'],
        core: ['self', 'absalom', 'knowledge', 'engine', 'think', 'process']
      };
      
      const lower = (message || '').toLowerCase();
      
      // Reset all to base
      for (const district of Object.keys(DISTRICTS)) {
        districtGlowIntensities[district] = 0.3;
      }
      
      // Boost matching districts based on cognitive state
      if (mode === 'thinking' || mode === 'responding') {
        districtGlowIntensities['core'] = 0.8;
        
        for (const [district, keywords] of Object.entries(districtKeywords)) {
          for (const kw of keywords) {
            if (lower.includes(kw)) {
              districtGlowIntensities[district] = 1.0;
              break;
            }
          }
        }
      }
      
      // Apply glow to buildings
      city.buildings.forEach(b => {
        const intensity = districtGlowIntensities[b.district] || 0.3;
        if (b.mesh.material && b.mesh.material.emissiveIntensity !== undefined) {
          b.mesh.material.emissiveIntensity = 0.3 + intensity * 0.7;
        }
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // INIT
    // ═══════════════════════════════════════════════════════════════════════
    
    createSkyDome();
    createCelestialBodies();
    createStarfield();
    createGround();
    createEnvironment();
    createLighting();
    createDistrictLabels();
    createDrones();
    createParticles();
    
    // Create core spire first (always present)
    createCoreSpire();
    city.districts.set('core', [city.buildings[0]]);
    
    // Load city from HTTP API first (reliable), then connect WebSocket for live updates
    loadCityFromAPI().then(success => {
      if (!success) {
        console.log('[City] API failed, using seed fallback');
        seedCityFallback();
      }
      // Connect WebSocket for live cognitive state updates
      connectKnowledge();
    });
    
    animate(0);
    
    console.log('Absalom City — A Mind Made Manifest (Knowledge-Powered Edition)');
    console.log(`Quality: ${qualityLevel} | Mobile: ${isMobile}`);
    
    /**
     * Fallback seeding when WebSocket unavailable
     */
    function seedCityFallback() {
      Object.entries(DISTRICTS).forEach(([key, district]) => {
        if (key === 'core') return;
        const pos = district.position;
        
        createBuilding({
          x: pos.x,
          z: pos.z,
          height: 18 + Math.random() * 12,
          width: 4 + Math.random() * 2,
          depth: 4 + Math.random() * 2,
          district: key,
          label: `${district.name} Hub`,
          type: Math.random() > 0.5 ? 'tapered' : 'tower',
        });
        
        const buildingCount = isMobile ? 4 : 6;
        for (let i = 0; i < buildingCount; i++) {
          const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.5;
          const radius = 6 + Math.random() * 8;
          createBuilding({
            x: pos.x + Math.cos(angle) * radius,
            z: pos.z + Math.sin(angle) * radius,
            height: 5 + Math.random() * 15,
            district: key,
          });
        }
      });
      
      // Connect districts to core
      const districtKeys = Object.keys(DISTRICTS).filter(k => k !== 'core');
      districtKeys.forEach(key => {
        const districtBuildings = city.districts.get(key) || [];
        if (districtBuildings.length > 0) {
          createConnection(city.buildings[0], districtBuildings[0]);
        }
      });
      
      updateStats();
    }
  </script>
</body>
</html>
