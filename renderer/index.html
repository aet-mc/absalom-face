<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' wss: ws:;">
  <title>Absalom - Electron</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #050d0a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      color: #a8c5b8;
      overflow: hidden;
      /* Transparent for menubar overlay */
      -webkit-app-region: drag;
    }
    
    #main-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      -webkit-app-region: no-drag;
    }
    
    .overlay {
      position: fixed;
      bottom: 20px;
      text-align: center;
      z-index: 10;
      -webkit-app-region: no-drag;
    }
    
    .name {
      font-size: 0.9rem;
      letter-spacing: 0.3em;
      color: #2a5a45;
      text-transform: uppercase;
      text-shadow: 0 0 20px rgba(42, 90, 69, 0.5);
    }
    
    .status {
      margin-top: 4px;
      font-size: 0.6rem;
      color: #1a3d2e;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: #1a6b4a;
      animation: statusPulse 2s ease-in-out infinite;
    }
    
    @keyframes statusPulse {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    .status.thinking .status-dot { background: #c9a227; animation-duration: 0.5s; }
    .status.responding .status-dot { background: #1a6b4a; animation-duration: 0.3s; }
    
    /* Graph info overlay */
    .graph-info {
      position: fixed;
      top: 10px;
      left: 10px;
      font-size: 9px;
      color: #1a3d2e;
      z-index: 10;
      -webkit-app-region: no-drag;
    }
    
    .conn-indicator {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 9px;
      color: #333;
      z-index: 10;
      -webkit-app-region: no-drag;
    }
  </style>
</head>
<body>
  <canvas id="main-canvas"></canvas>
  
  <div class="overlay">
    <div class="name">Absalom</div>
    <div class="status" id="status">
      <span class="status-dot"></span>
      <span id="status-text">present</span>
    </div>
  </div>
  
  <div class="graph-info" id="graph-info"></div>
  <div class="conn-indicator" id="conn-indicator">○ connecting...</div>

  <script src="graph-client.js"></script>
  
  <script>
    // ============================================
    // Electron Renderer - Compact Version
    // Optimized for menubar/overlay display
    // ============================================
    
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Colors
    const colors = {
      bg: '#050d0a',
      emerald: '#1a6b4a',
      emeraldDark: '#0d4d3d',
      emeraldLight: '#2a8a5a',
      gold: '#c9a227',
      nodeActive: '#2dd4a8',
      nodeInactive: '#1a3a30',
      nodeHot: '#fbbf24',
      waterCaustic: 'rgba(94, 234, 212, 0.4)'
    };
    
    // State
    let state = {
      mode: 'idle',
      time: 0,
      heartbeat: 0,
      energy: 0,
      waterLineY: 0.55 // Slightly higher for compact view
    };
    
    // Graph data
    let graphData = { nodes: [], edges: [] };
    let layoutNodes = [];
    let layoutEdges = [];
    let graphActivations = new Map();
    
    // ============================================
    // GraphClient Integration
    // ============================================
    
    let graphClient = null;
    
    // Get WebSocket URL from Electron preload or localStorage
    const WS_URL = window.electronAPI?.getWsUrl?.() || 
                   localStorage.getItem('absalom_ws') ||
                   new URLSearchParams(window.location.search).get('ws');
    
    if (WS_URL && typeof GraphClient !== 'undefined') {
      graphClient = new GraphClient(WS_URL, {
        reconnectDelay: 1000,
        maxReconnectDelay: 30000,
        autoConnect: true
      });
      
      graphClient.on('connect', () => {
        updateConnIndicator(true);
      });
      
      graphClient.on('disconnect', () => {
        updateConnIndicator(false);
      });
      
      graphClient.on('graph', (graph) => {
        graphData = graph;
        layoutGraph(graph);
        updateGraphInfo();
      });
      
      graphClient.on('state', (newState) => {
        state.mode = newState;
        updateStatus();
        triggerModeEffects();
      });
      
      graphClient.on('activate', (nodeIds, intensity) => {
        const now = Date.now();
        for (const nodeId of nodeIds) {
          graphActivations.set(nodeId, { intensity, time: now });
        }
      });
      
      graphClient.on('activate:path', (path, intensity) => {
        const now = Date.now();
        path.forEach((nodeId, idx) => {
          graphActivations.set(nodeId, { 
            intensity: intensity * Math.max(0.3, 1 - idx * 0.1), 
            time: now + idx * 80 
          });
        });
      });
    }
    
    function updateConnIndicator(connected) {
      const el = document.getElementById('conn-indicator');
      el.textContent = connected ? '● live' : '○ reconnecting...';
      el.style.color = connected ? '#1a6b4a' : '#4a2020';
    }
    
    function updateStatus() {
      const statusEl = document.getElementById('status');
      const textEl = document.getElementById('status-text');
      statusEl.className = 'status ' + state.mode;
      textEl.textContent = state.mode === 'idle' ? 'present' : state.mode;
    }
    
    function updateGraphInfo() {
      const el = document.getElementById('graph-info');
      el.textContent = `${graphData.nodes.length} nodes · ${graphData.edges.length} edges`;
    }
    
    function triggerModeEffects() {
      if (state.mode === 'thinking') {
        activateRandomNodes(3, 1);
      } else if (state.mode === 'responding') {
        activateOutward(1);
      }
    }
    
    // ============================================
    // Graph Layout
    // ============================================
    
    function layoutGraph(graph) {
      if (!graph.nodes || graph.nodes.length === 0) {
        layoutNodes = [];
        layoutEdges = [];
        return;
      }
      
      const waterLine = canvas.height * state.waterLineY;
      const depthHeight = canvas.height - waterLine;
      const centerX = canvas.width / 2;
      const centerY = waterLine + depthHeight * 0.5;
      
      layoutNodes = graph.nodes.map((node, idx) => {
        const angle = (idx / graph.nodes.length) * Math.PI * 2;
        const radius = 50 + Math.random() * 80;
        
        return {
          ...node,
          x: centerX + Math.cos(angle) * radius,
          y: centerY + Math.sin(angle) * 30 + Math.random() * 40,
          vx: 0,
          vy: 0
        };
      });
      
      layoutEdges = graph.edges.map(e => ({ ...e }));
      
      // Quick force simulation
      for (let i = 0; i < 30; i++) {
        forceStep();
      }
    }
    
    function forceStep() {
      const waterLine = canvas.height * state.waterLineY;
      const centerX = canvas.width / 2;
      
      for (let i = 0; i < layoutNodes.length; i++) {
        for (let j = i + 1; j < layoutNodes.length; j++) {
          const a = layoutNodes[i], b = layoutNodes[j];
          const dx = b.x - a.x, dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          
          if (dist < 60) {
            const force = (60 - dist) * 0.08;
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;
            a.vx -= fx; a.vy -= fy;
            b.vx += fx; b.vy += fy;
          }
        }
      }
      
      for (const edge of layoutEdges) {
        const a = layoutNodes.find(n => n.id === edge.source);
        const b = layoutNodes.find(n => n.id === edge.target);
        if (!a || !b) continue;
        
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        
        if (dist > 40) {
          const force = (dist - 40) * 0.015;
          a.vx += (dx / dist) * force;
          a.vy += (dy / dist) * force;
          b.vx -= (dx / dist) * force;
          b.vy -= (dy / dist) * force;
        }
      }
      
      for (const node of layoutNodes) {
        node.x += node.vx;
        node.y += node.vy;
        node.vx *= 0.75;
        node.vy *= 0.75;
        
        node.y = Math.max(waterLine + 20, Math.min(canvas.height - 15, node.y));
        node.x = Math.max(20, Math.min(canvas.width - 20, node.x));
        node.vx += (centerX - node.x) * 0.002;
      }
    }
    
    // ============================================
    // Activation
    // ============================================
    
    function activateRandomNodes(count, intensity) {
      if (layoutNodes.length === 0) return;
      const now = Date.now();
      for (let i = 0; i < count; i++) {
        const node = layoutNodes[Math.floor(Math.random() * layoutNodes.length)];
        graphActivations.set(node.id, { intensity, time: now });
      }
    }
    
    function activateOutward(intensity) {
      if (layoutNodes.length === 0) return;
      const now = Date.now();
      const waterLine = canvas.height * state.waterLineY;
      const cx = canvas.width / 2, cy = waterLine + (canvas.height - waterLine) * 0.5;
      
      const sorted = [...layoutNodes].sort((a, b) => {
        return Math.hypot(a.x - cx, a.y - cy) - Math.hypot(b.x - cx, b.y - cy);
      });
      
      sorted.forEach((node, idx) => {
        graphActivations.set(node.id, { 
          intensity: intensity * Math.max(0.3, 1 - idx * 0.12), 
          time: now + idx * 40 
        });
      });
    }
    
    function getActivation(nodeId) {
      const a = graphActivations.get(nodeId);
      if (!a) return 0;
      const age = Date.now() - a.time;
      if (age < 0) return 0;
      return a.intensity * Math.exp(-age / 1500);
    }
    
    // ============================================
    // Render Loop
    // ============================================
    
    function draw() {
      const W = canvas.width, H = canvas.height;
      const cx = W / 2, cy = H * 0.35;
      const waterLine = H * state.waterLineY;
      
      state.time += 0.016;
      state.heartbeat += 0.02;
      state.energy = Math.sin(state.heartbeat) * 0.5 + 0.5;
      
      // Background
      const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
      bgGrad.addColorStop(0, colors.bg);
      bgGrad.addColorStop(state.waterLineY, '#0a1f1a');
      bgGrad.addColorStop(1, '#050a08');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);
      
      // Depth layer (graph)
      drawGraph(waterLine);
      
      // Water line
      drawWaterLine(waterLine);
      
      // Face (compact)
      drawFace(cx, cy);
      
      // Prune old activations
      if (state.time % 2 < 0.016) {
        for (const [id, a] of graphActivations) {
          if (Date.now() - a.time > 4000) graphActivations.delete(id);
        }
      }
      
      requestAnimationFrame(draw);
    }
    
    function drawGraph(waterLine) {
      if (layoutNodes.length === 0) return;
      
      const breathe = Math.sin(state.time * 0.3) * 2;
      
      // Edges
      for (const edge of layoutEdges) {
        const a = layoutNodes.find(n => n.id === edge.source);
        const b = layoutNodes.find(n => n.id === edge.target);
        if (!a || !b) continue;
        
        const act = Math.max(getActivation(a.id), getActivation(b.id));
        const alpha = 0.1 + act * 0.5;
        
        ctx.beginPath();
        ctx.moveTo(a.x, a.y + breathe);
        ctx.lineTo(b.x, b.y + breathe);
        ctx.strokeStyle = act > 0.3 ? `rgba(45, 212, 168, ${alpha})` : `rgba(26, 58, 48, ${alpha})`;
        ctx.lineWidth = 1 + act * 1.5;
        ctx.stroke();
      }
      
      // Nodes
      for (const node of layoutNodes) {
        const act = getActivation(node.id);
        const y = node.y + breathe;
        const size = 3 + (node.displayWeight || 1) * 1.5 + act * 3;
        
        if (act > 0.1) {
          ctx.beginPath();
          ctx.arc(node.x, y, size + 8, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(45, 212, 168, ${act * 0.3})`;
          ctx.fill();
        }
        
        ctx.beginPath();
        ctx.arc(node.x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = act > 0.5 ? colors.nodeActive : act > 0.1 ? colors.emeraldLight : colors.nodeInactive;
        ctx.fill();
        
        // Idle pulse
        if (state.mode === 'idle' && act < 0.1) {
          const pulse = (Math.sin(state.time * 0.8 + node.x * 0.02) * 0.5 + 0.5) * 0.2;
          ctx.beginPath();
          ctx.arc(node.x, y, size + 4, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(26, 107, 74, ${pulse})`;
          ctx.fill();
        }
      }
    }
    
    function drawWaterLine(waterLine) {
      const W = canvas.width;
      
      // Main line
      ctx.beginPath();
      ctx.moveTo(0, waterLine);
      for (let x = 0; x <= W; x += 8) {
        const y = waterLine + Math.sin(x * 0.03 + state.time * 0.8) * 2 + Math.sin(x * 0.015 + state.time * 0.5) * 3;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = 'rgba(94, 234, 212, 0.25)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Caustic shimmer
      for (let i = 0; i < 6; i++) {
        const x = ((i / 6) * W + state.time * 15) % W;
        const alpha = (Math.sin(state.time * 1.5 + i) * 0.5 + 0.5) * 0.12;
        
        ctx.beginPath();
        ctx.moveTo(x, waterLine - 5);
        ctx.lineTo(x + 4, waterLine + 25);
        ctx.lineTo(x + 10, waterLine + 25);
        ctx.lineTo(x + 6, waterLine - 5);
        ctx.closePath();
        ctx.fillStyle = `rgba(94, 234, 212, ${alpha})`;
        ctx.fill();
      }
    }
    
    function drawFace(cx, cy) {
      const breathe = Math.sin(state.time * 0.8) * 3;
      const pulse = state.energy;
      
      ctx.save();
      ctx.translate(cx, cy + breathe);
      
      // Aura
      const auraSize = 90 + pulse * 10;
      const auraGrad = ctx.createRadialGradient(0, 0, 40, 0, 0, auraSize);
      auraGrad.addColorStop(0, 'rgba(26, 107, 74, 0.1)');
      auraGrad.addColorStop(0.6, `rgba(26, 107, 74, ${0.05 + pulse * 0.05})`);
      auraGrad.addColorStop(1, 'rgba(26, 107, 74, 0)');
      ctx.beginPath();
      ctx.arc(0, 0, auraSize, 0, Math.PI * 2);
      ctx.fillStyle = auraGrad;
      ctx.fill();
      
      // Hexagon
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const r = 55 + Math.sin(state.time * 2 + i) * 1.5 + pulse * 3;
        const x = Math.cos(angle) * r, y = Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = colors.emerald;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Vertices
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) - Math.PI / 2;
        const r = 55 + pulse * 3;
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 2.5 + pulse, 0, Math.PI * 2);
        ctx.fillStyle = colors.gold;
        ctx.fill();
      }
      
      // Eyes
      const eyeY = -12;
      const eyeSpacing = 28;
      
      [-1, 1].forEach(side => {
        const eyeX = side * eyeSpacing;
        
        // Socket
        ctx.beginPath();
        ctx.moveTo(eyeX, eyeY - 16);
        ctx.lineTo(eyeX + 16, eyeY);
        ctx.lineTo(eyeX, eyeY + 16);
        ctx.lineTo(eyeX - 16, eyeY);
        ctx.closePath();
        ctx.fillStyle = '#08120e';
        ctx.fill();
        ctx.strokeStyle = colors.emeraldDark;
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Iris
        const irisSize = 8 + (state.mode === 'thinking' ? 2 : 0);
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, irisSize, 0, Math.PI * 2);
        ctx.fillStyle = colors.emeraldDark;
        ctx.fill();
        
        // Pupil
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 3.5 + (state.mode === 'thinking' ? 1 : 0), 0, Math.PI * 2);
        ctx.fillStyle = '#030806';
        ctx.fill();
        
        // Gold ring
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, irisSize - 1, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(201, 162, 39, ${0.3 + pulse * 0.3})`;
        ctx.lineWidth = 0.8;
        ctx.stroke();
        
        // Highlight
        ctx.beginPath();
        ctx.arc(eyeX - 2.5, eyeY - 2.5, 1.8, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(168, 197, 184, 0.5)';
        ctx.fill();
      });
      
      ctx.restore();
    }
    
    // Mode-triggered effects
    setInterval(() => {
      if (state.mode === 'thinking') {
        activateRandomNodes(2, 0.8);
      } else if (state.mode === 'responding') {
        activateOutward(0.6);
      }
    }, 500);
    
    // Initialize
    draw();
    
    window.addEventListener('resize', () => {
      if (graphData.nodes.length > 0) {
        setTimeout(() => layoutGraph(graphData), 100);
      }
    });
    
    // Click for demo mode cycling
    canvas.addEventListener('click', () => {
      const modes = ['idle', 'listening', 'thinking', 'responding'];
      state.mode = modes[(modes.indexOf(state.mode) + 1) % modes.length];
      updateStatus();
      triggerModeEffects();
    });
  </script>
</body>
</html>
